# Java基础

## 一、基础语法

### 1. 基本数据类型

| 数据类型 | 关键字 |内存占用|取值范围|
| -------- | ---- | ---- | ---- |
| 整数类型 | byte         | 1        | -128~127                                                     |
|          | short        | 2        | -32768~32767                                                 |
|          | int(默认)    | 4        | -2的31次方到2的31次方-1                                      |
|          | long         | 8        | -2的63次方到2的63次方-1                                      |
| 浮点类型 | float        | 4        | 负数：-3.402823e+38 ~ -1.401298e-45<br/>正数：1.401298e-45 ~ 3.402823e+38 |
|          | double(默认) | 8        | 负数：-1.797693e+308 ~ -4.9000000e-324<br/>正数：4.9000000e-324 ~ 1.797693e+308 |
| 字符类型 | char         | 2        | 0-65535                                                      |
| 布尔类型 | boolean      | 1        | true，false                                                  |

> 1. e+38表示的是乘以10的38次方，e-45表示乘以10的负45次方
> 2. 在Java中整数默认的是int类型，浮点数默认是double类型

### 2. 运算符

**算术运算符**

| 符号 | 作用 | 说明                         |
| ---- | ---- | ---------------------------- |
| +    | 加   |                              |
| -    | 减   |                              |
| *    | 乘   |                              |
| /    | 除   |                              |
| %    | 取余 | 获取的是两个数据做除法的余数 |

>1. /和%的区别：两个数据做除法，/取结果的商，%取结果的余数。
>2. 整数操作只能得到整数，要想得到小数，必须有浮点数参与运算。

1. 字符的“+”操作
	char类型参与算术运算，使用的是计算机底层对应的十进制数值。需要我们记住三个字符对应的数值：
	
	'a'  --  97		a-z是连续的，所以'b'对应的数值是98，'c'是99，依次递加
	
	'A'  --  65		A-Z是连续的，所以'B'对应的数值是66，'C'是67，依次递加
	
	'0'  --  48		0-9是连续的，所以'1'对应的数值是49，'2'是50，依次递加

> 算术表达式中包含不同的基本数据类型的值的时候，整个算术表达式的类型会自动进行提升。
>
> 提升规则：
>
> byte类型，short类型和char类型将被提升到int类型，不管是否有其他类型参与运算。
>
> 整个表达式的类型自动提升到与表达式中最高等级的操作数相同的类型
>
> ​       等级顺序：byte,short,char --> int --> long --> float --> double

2. 字符串的“+”操作

	当“+”操作中出现字符串时，这个”+”是字符串连接符，而不是算术运算。

~~~java
System.out.println("java"+ 666); // 输出：java666
~~~

	在”+”操作中，如果出现了字符串，就是连接运算符，否则就是算术运算。当连续进行“+”操作时，从左到右逐个执行。

~~~java
System.out.println(1 + 2 + "java"); // 输出：3java
System.out.println(1 + 2 + "java" + 3 + 4); // 输出：3java34
// 可以使用小括号改变运算的优先级 
System.out.println(1 + 2 + "java" + (3 + 4)); // 输出：3java7
~~~

**赋值运算符**

​	赋值运算符的作用是将一个表达式的值赋给左边，左边必须是可修改的，不能是常量。

| 符号 | 作用       | 说明                  |
| ---- | ---------- | --------------------- |
| =    | 赋值       | a=10，将10赋值给变量a |
| +=   | 加后赋值   | a+=b，将a+b的值给a    |
| -=   | 减后赋值   | a-=b，将a-b的值给a    |
| *=   | 乘后赋值   | a*=b，将a×b的值给a    |
| /=   | 除后赋值   | a/=b，将a÷b的商给a    |
| %=   | 取余后赋值 | a%=b，将a÷b的余数给a  |

**自增自减运算符**

| 符号 | 作用 | 说明        |
| ---- | ---- | ----------- |
| ++   | 自增 | 变量的值加1 |
| --   | 自减 | 变量的值减1 |

​	注意事项：

​		++和--，既可以放在变量前面，也可以反正放在变量后面。

​		单独使用的时候， ++和--无论是放在变量的前边还是后边，结果是一样的。

​		参与操作的时候，如果放在变量的后边，先拿变量参与操作，后拿变量做++或者--。

​		参与操作的时候，如果放在变量的前边，先拿变量做++或者--，后拿变量参与操作。

​		最常见的用法：单独使用。

~~~java
int i = 10;
i++; // 单独使用
System.out.println("i:" + i); // i:11

int j = 10;
++j; // 单独使用
System.out.println("j:" + j); // j:11

int x = 10;
int y = x++; // 赋值运算，++在后边，所以是使用x原来的值赋值给y，x本身自增1
System.out.println("x:" + x + ", y:" + y); // x:11，y:10

int m = 10;
int n = ++m; // 赋值运算，++在前边，所以是使用m自增后的值赋值给n，m本身自增1
System.out.println("m:" + m + ", m:" + m); // m:11，m:11
~~~

**关系运算符**


​	关系运算符有6种关系，分别为小于、小于等于、大于、等于、大于等于、不等于。

| 符号 | 说明                                                    |
| ---- | ------------------------------------------------------- |
| ==   | a==b，判断a和b的值是否相等，成立为true，不成立为false   |
| !=   | a!=b，判断a和b的值是否不相等，成立为true，不成立为false |
| >    | a>b，判断a是否大于b，成立为true，不成立为false          |
| >=   | a>=b，判断a是否大于等于b，成立为true，不成立为false     |
| <    | a<b，判断a是否小于b，成立为true，不成立为false          |
| <=   | a<=b，判断a是否小于等于b，成立为true，不成立为false     |

注意事项：

​	关系运算符的结果都是boolean类型，要么是true，要么是false。

​	千万不要把“==”误写成“=”，"=="是判断是否相等的关系，"="是赋值。

~~~java
int a = 10;
int b = 20;
System.out.println(a == b); // false
System.out.println(a != b); // true
System.out.println(a > b); // false
System.out.println(a >= b); // false
System.out.println(a < b); // true
System.out.println(a <= b); // true
~~~

**逻辑运算符**

​	逻辑运算符把各个运算的关系表达式连接起来组成一个复杂的逻辑表达式，以判断程序中的表达式是否成立，判断的结果是 true 或 false。

| 符号 | 作用     | 说明                                         |
| ---- | -------- | -------------------------------------------- |
| &    | 逻辑与   | a&b，a和b都是true，结果为true，否则为false   |
| \|   | 逻辑或   | a\|b，a和b都是false，结果为false，否则为true |
| ^    | 逻辑异或 | a^b，a和b结果不同为true，相同为false         |
| !    | 逻辑非   | !a，结果和a的结果正好相反                    |

**短路逻辑运算符**

| 符号 | 作用   | 说明                         |
| ---- | ------ | ---------------------------- |
| &&   | 短路与 | 作用和&相同，但是有短路效果  |
| \|\| | 短路或 | 作用和\|相同，但是有短路效果 |

​	在逻辑与运算中，只要有一个表达式的值为false，那么结果就可以判定为false了，没有必要将所有表达式的值都计算出来，短路与操作就有这样的效果，可以提高效率。同理在逻辑或运算中，一旦发现值为true，右边的表达式将不再参与运算。

- 逻辑与&，无论左边真假，右边都要执行。

- 短路与&&，如果左边为真，右边执行；如果左边为假，右边不执行。

- 逻辑或|，无论左边真假，右边都要执行。

- 短路或||，如果左边为假，右边执行；如果左边为真，右边不执行。

**三元运算符**

​	三元运算符语法格式：

~~~java
关系表达式 ? 表达式1 : 表达式2;
~~~

​	解释：问号前面的位置是判断的条件，判断结果为boolean型，为true时调用表达式1，为false时调用表达式2。其逻辑为：如果条件表达式成立或者满足则执行表达式1，否则执行第二个。

~~~java
int a = 10;
int b = 20;
int c = a > b ? a : b; // 判断 a>b 是否为真，如果为真取a的值，如果为假，取b的值
~~~

### 3. 数据输入和随机数（Scanner和Random）

1. Scanner

```java
import java.util.Scanner;
public class ScannerDemo {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int x = sc.nextInt();
		System.out.println("x:" + x);
	}
}
```

2. Random

```java
import java.util.Random;
public class RandomDemo {
	public static void main(String[] args) {
		Random r = new Random();
		for(int i=0; i<10; i++) {
			int number = r.nextInt(10);
			System.out.println("number:" + number);
		}
		int x = r.nextInt(100) + 1;
		System.out.println(x);
	}
}

```

### 4. 流程控制

流程控制语句分类：

1. 顺序结构
2. 分支结构（if, switch）
3. 循环结构（for, while, do...while）

1. **顺序结构**
顺序结构是程序中最简单最基本的流程控制，没有特定的语法结构，按照代码的先后顺序，依次执行。

2. **分支结构**

**if语句**

```java
格式1：
if(关系表达式){
    语句体;
}

格式2：
if (关系表达式) {
    语句体1;	
} else {
    语句体2;	
}

格式3：
if (关系表达式1) {
    语句体1;	
} else if (关系表达式2) {
    语句体2;	
} 
…
else {
    语句体n+1;
}
```

**提示：如果if的语句体只有一行，则可以省略大括号。**

**switch语句**

```java
格式：
switch (表达式) {
	case 1:
		语句体1;
		break;
	case 2:
		语句体2;
		break;
	...
	default:
		语句体n+1;
		break;
}
```

**注意：如果switch中的case没有对应break的话，则会出现case穿透的现象。**

3. **循环结构**

**for循环**

```java 
for (初始化语句;条件判断语句;条件控制语句) {
	循环体语句;
}
```

格式解释：

* 初始化语句：  用于表示循环开启时的起始状态，简单说就是循环开始的时候什么样
* 条件判断语句：用于表示循环反复执行的条件，简单说就是判断循环是否能一直执行下去
* 循环体语句：  用于表示循环反复执行的内容，简单说就是循环反复执行的事情
* 条件控制语句：用于表示循环执行中每次变化的内容，简单说就是控制循环是否能执行下去

执行流程：

①执行初始化语句

②执行条件判断语句，看其结果是true还是false

​             如果是false，循环结束

​             如果是true，继续执行

③执行循环体语句

④执行条件控制语句

⑤回到②继续

**while循环**

* while循环完整格式：

  ```java
  初始化语句;
  while (条件判断语句) {
  	循环体语句;
      条件控制语句;
  }
  ```

* while循环执行流程：

  ①执行初始化语句

  ②执行条件判断语句，看其结果是true还是false

  ​             如果是false，循环结束

  ​             如果是true，继续执行

  ③执行循环体语句

  ④执行条件控制语句

  ⑤回到②继续

**do...while循环**

* 完整格式：

  ```java
  初始化语句;
  do {
  	循环体语句;
  	条件控制语句;
  }while(条件判断语句);
  ```

* 执行流程：

  ① 执行初始化语句

  ② 执行循环体语句

  ③ 执行条件控制语句

  ④ 执行条件判断语句，看其结果是true还是false

  如果是false，循环结束

  如果是true，继续执行

  ⑤ 回到②继续

1. 三种循环的区别

* 三种循环的区别
  * for循环和while循环先判断条件是否成立，然后决定是否执行循环体（先判断后执行）
  * do...while循环先执行一次循环体，然后判断条件是否成立，是否继续执行循环体（先执行后判断）
* for循环和while的区别
  * 条件控制语句所控制的自增变量，因为归属for循环的语法结构中，在for循环结束后，就不能再次被访问到了
  * 条件控制语句所控制的自增变量，对于while循环来说不归属其语法结构中，在while循环结束后，该变量还可以继续使用
* 死循环（无限循环）的三种格式
  1. for(;;){}
  2. while(true){}
  3. do {} while(true);

2. 循环跳转

* 跳转控制语句（break）
  * 跳出循环，结束循环
* 跳转控制语句（continue）
  * 跳过本次循环，继续下次循环
* 注意： continue只能在循环中进行使用！

### 5. 数组

数组就是存储数据长度固定的容器，存储多个数据的数据类型要一致。 

**数组定义格式**

* 数据类型[] 数组名;	int[] arr;
* 数据类型 数组名[];	int arr[];

**数组动态初始化**

数组动态初始化就是只给定数组的长度，由系统给出默认初始化值

* 格式

数据类型[] 数组名 = new 数据类型[数组长度];

**数组元素访问**

每一个存储到数组的元素，都会自动的拥有一个编号，从0开始。

这个自动编号称为数组索引(index)，可以通过数组的索引访问到数组中的元素。

* 格式

数组名[索引];

**Java中内存分配**

| 区域名称   | 作用                                                       |
| ---------- | ---------------------------------------------------------- |
| 寄存器     | 给CPU使用，和我们开发无关。                                |
| 本地方法栈 | JVM在使用操作系统功能的时候使用，和我们开发无关。          |
| 方法区     | 存储可以运行的class文件。                                  |
| 堆内存     | 存储对象或者数组，new来创建的，都存储在堆内存。            |
| 方法栈     | 方法运行时使用的内存，比如main方法运行，进入方法栈中执行。 |

**静态初始化**

- 完整版格式

  ```java
  数据类型[] 数组名 = new 数据类型[]{元素1,元素2,...};
  ```

- 简化版格式

  ```java
  数据类型[] 数组名 = {元素1,元素2,...};
  ```

### 6. 方法

方法（method）是将具有独立功能的代码块组织成为一个整体，使其具有特殊功能的代码集。

* 注意：
  * 方法必须先创建才可以使用，该过程成为方法定义
  * 方法创建后并不是直接可以运行的，需要手动使用后，才执行，该过程成为方法调用

**无参数**

![image-20201130081653929](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/image-20201130081653929.png)

* 总结：每个方法在被调用执行的时候，都会进入栈内存，并且拥有自己独立的内存空间，方法内部代码调用完毕之后，会从栈内存中弹栈消失。

**有参数**

1. 有参
2. 无参

**带返回值**

注意：

* 方法定义时return后面的返回值与方法定义上的数据类型要匹配，否则程序将报错

**方法重载**

* 方法重载概念

  方法重载指同一个类中定义的多个方法之间的关系，满足下列条件的多个方法相互构成重载

  * 多个方法在同一个类中
  * 多个方法具有相同的方法名
  * 多个方法的参数不相同，类型不同或者数量不同

* 注意：

  * 重载仅对应方法的定义，与方法的调用无关，调用方式参照标准格式
  * 重载仅针对同一个类中方法的名称与参数进行识别，与返回值无关，换句话说不能通过返回值来判定两个方法是否相互构成重载

**方法的参数传递**

1. 基本类型

* 基本数据类型的参数，形式参数的改变，不影响实际参数 。
* 每个方法在栈内存中，都会有独立的栈空间，方法运行结束后就会弹栈消失

![image-20201130082124593](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/image-20201130082124593.png)

2. 引用类型

   * 对于引用类型的参数，形式参数的改变，影响实际参数的值 

   * 引用数据类型的传参，传入的是地址值，内存中会造成两个引用指向同一个内存的效果，所以即使方法弹栈，堆内存中的数据也已经是改变后的结果 


![image-20201130082300920](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/image-20201130082300920.png)

### 7. 类和对象

**类和对象的理解**

客观存在的事物皆为对象 ，所以我们也常常说万物皆对象。

* 类
  * 类的理解
    * 类是对现实生活中一类具有共同属性和行为的事物的抽象
    * 类是对象的数据类型，类是具有相同属性和行为的一组对象的集合
    * 简单理解：类就是对现实事物的一种描述
  * 类的组成
    * 属性：指事物的特征，例如：手机事物（品牌，价格，尺寸）
    * 行为：指事物能执行的操作，例如：手机事物（打电话，发短信）
* 类和对象的关系
  * 类：类是对现实生活中一类具有共同属性和行为的事物的抽象
  * 对象：是能够看得到摸的着的真实存在的实体
  * 简单理解：**类是对事物的一种描述，对象则为具体存在的事物**

**对象内存图**

1. 单个对象内存图

![image-20201130082848256](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/image-20201130082848256.png)

2. 多个对象内存图

![image-20201130082942400](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/image-20201130082942400.png)

3. 多个对象指定相同内存图

![image-20201130083008515](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/image-20201130083008515.png)

* 总结

  当多个对象的引用指向同一个内存空间（变量所记录的地址值是一样的）

  只要有任何一个对象修改了内存中的数据，随后，无论使用哪一个对象进行数据获取，都是修改后的数据。

**成员变量和局部变量的区别**

* 类中位置不同：成员变量（类中方法外）局部变量（方法内部或方法声明上）
* 内存中位置不同：成员变量（堆内存）局部变量（栈内存）
* 生命周期不同：成员变量（随着对象的存在而存在，随着对象的消失而消失）局部变量（随着方法的调用而存在，醉着方法的调用完毕而消失）
* 初始化值不同：成员变量（有默认初始化值）局部变量（没有默认初始化值，必须先定义，赋值才能使用）

**构造方法**

​	用来给对象中的属性进行初始化

#### 封装

​	是面向对象三大特征之一（封装，继承，多态），是面向对象编程语言对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界是无法直接操作的。

**封装原则**
	将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问，成员变量private，提供对应的getXxx()/setXxx()方法

**封装好处**
	通过方法来控制成员变量的操作，提高了代码的安全性，把代码用方法进行封装，提高了代码的复用性

#### 继承

​	继承是面向对象三大特征之一，可以使得子类具有父类的属性和方法，还可以在子类中重新定义，以及追加属性和方法。

**实现继承格式**

* 继承通过extends实现
* 格式：class 子类 extends 父类{}

**继承的好处**

​	继承可以让类与类之间产生子夫类关系，通过这种关系，子类可以使用父类中非私有成员。

* 提高了代码复用性（多个类相同的方法可以放到同一个类中）
* 提高了代码的维护性（如果方法的代码需要修改，只需要修改一处即可）

**继承的弊端**

​	继承让类与类之间产生了关系，类的耦合性增强了，当父类发生变化时子类实现也不得不跟着变化，削弱了子类的独立性。

**继承中变量访问特点**

在子类方法中访问一个变量，采用的是就近原则。

1. 子类局部范围查找
2. 子类成员范围查找
3. 父类成员范围查找
4. 如果都没有就报错

**super和this关键字**

* this代表本类对象的引用
* super代表父类存储空间的标识，是父类对象引用

>this和super使用区别
>
>成员变量：
>
>​	this.成员变量	访问本类成员变量
>
>​	super.成员变量	访问父类成员变量
>
>成员方法：
>
>​	this.成员方法	访问本类成员方法
>
>​	super.成员方法访	问父类成员方法
>
>构造方法：
>
>​	this(...)	访问本类构造方法
>
>​	super(...)	问父类构造方法

**继承中构造方法的访问特点**

> 子类中所有的构造方法都会默认访问父类的无参的构造方法

​	子类会继承父类中的数据可能还会使用父类的数据。所以，子类初始化之前，一定要先完成父类数据的初始化，原因在于每一个子类构造方法的第一条语句默认都是：super()

**继承中成员方法访问的特点**

通过子类对象访问一个方法

1. 子类成员范围找
2. 父类成员范围找
3. 如果都没有就报错(不考虑父亲的父亲…)

**super内存图**

​	对象在堆内存中，会单独存在一块super的区域，用来存放父类数据。

![image-20201201155730257](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/image-20201201155730257.png)

**方法重写**

​	子类中出现了和父类一模一样的方法声明。使用Override注解来校验是否是重写的方法

> 注意事项：
>
> 	1. 私有方法不能被重写
>
>  	2. 子类方法访问权想不能更低（public > 默认 > 私有）

**继承注意事项**

​	Java中仅支持单继承。

#### 多态

​	同一个对象，在不同时刻表现出来的不同形态。

> 多态的前提：
>
> * 要有继承或者实现关系
> * 要有方法的重写
> * 要有父类引用子类对象

**多态中成员访问特点**

> 成员变量
>
> ​	编译看父类，运行看父类
>
> 成员方法
>
> ​	编译看父类，运行看子类

**多态的好处和弊端**

* 好处：提高程序的扩展性。定义方法的时候，使用父类型作为参数，在使用的时候，使用具体的子类参与操作

* 弊端：不能使用子类的特有成员

**多态中的转型**

* 向上转型：父类引用指向子类对象就是向上转型
* 向下转型：子类型 对象名 = （子类型）父类引用：

#### 抽象类

​	当我们在做子类共性功能抽取时，有些方法在父类中并没有具体的体现，这个时候就需要抽象类了！

​	在Java中，一个没有方法体的方法应该定义为抽象方法，而类中如果有抽象方法，该类必须定义为抽象类！

**抽象类的特点**

* 抽象类和抽象方法必须使用abstract关键字修饰
* 抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类
* 抽象类不能实例化
* 抽象类的子类要么重写抽象类中所有的抽象方法，要么就是抽象类

#### 接口

​	接口是一种公共的规范标准，只要符合规范标准，大家都可以通用。Java中接口的更多的体现在对行为的抽象。

**接口的特点**

* 接口用interface修饰
* 类实现接口用implements表示
* 接口不能实例化
* 接口的子类要么重写接口中所有的抽象方法，要么子类也是抽象类

**接口中成员的特点**

* 成员变量的默认修饰方法public static final
* 没有构造方法
* 成员方法只能是抽象方法，默认修饰符public abstarct

**类和接口的关系**

* 类与类只能单继承
* 类可以实现多个接口
* 接口可以继承多个接口

#### 内部类

​	在一个类中定义一个类。举例：在一个类A的内部定义一个类B，类B就被称为内部类

格式：

    class 外部类名{
    	修饰符 class 内部类名{
    	}
    }
**内部类的访问特点**

* 内部类可以直接访问外部类的成员，包括私有
* 外部类要访问内部类的成员，必须要先创建对象
* 外界创建成员内部类格式：外部类名.内部类名 对象名 = 外部类对象.内部类对象

**匿名内部类**

​	存在一个类或者接口，这里的类可以是具体类也可以是抽象类。

​	本质：是一个继承了该类或者实现了该接口的子类匿名对象

#### 泛型

​	它的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数参数化类型就是将类型由原来的具体的类型参数化，然后在使用/调用时传入具体的类型。这种参数类型可以用在类、方法和接口中，分别被称为泛型类、泛型方法、泛型接口

**好处**

- 把运行时期的问题提前到了编译期间
- 避免了强制类型转换

**类型通配符**

- 类型通配符：<?>
  - List<?>：表示元素类型未知的List，它的元素可以匹配任何的类型
  - 这种带通配符的List仅表示它是各种泛型List的父类，并不能把元素添加到其中
- 类型通配符上限：<? extends 类型>
  - List<? extends Number>：它表示的类型是Number或者其子类型
- 类型通配符下限：<? super 类型>
  - List<? super Number>：它表示的类型是Number或者其父类型

### 8. 修饰符

**package**

​	包就是文件夹，用来管理类文件的。

​	格式：package 包名;

**import**

​	格式：import 包名;

**权限修饰符**

![image-20201201160703821](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/image-20201201160703821.png)

**final**

​	final代表最终的意思，可以修饰成员方法（不能重写），成员变量（不能再次赋值），类（不能被继承）

**static**

​	static是静态的意思，可以修饰成员方法，成员变量。被类的所有对象共享，这也是判断是否是静态关键字的条件，可以使用类名调用。

​	<b>静态成员方法只能访问静态成员</b>

## 二、 常用API

- 什么是API

  ​	API (Application Programming Interface) ：应用程序编程接口

- java中的API

  ​	指的就是 JDK 中提供的各种功能的 Java类，这些类将底层的实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可，我们可以通过帮助文档来学习这些API如何使用。

* API 文档

### 1. String类

​	String 类代表字符串，Java 程序中的所有字符串文字（例如“abc”）都被实现为此类的实例。也就是说，Java 程序中所有的双引号字符串，都是 String 类的对象。String 类在 java.lang 包下，所以使用的时候不需要导包！

**特点**

* 字符串不可变，他们的值在创建之后不能改变。
* 虽然String的值不可变，但是它们可以被共享。
* 字符串效果上相当于字符串数组(char[])，但是底层原理是字节数组(byte[])

**构造方法**

| 方法名                    | 说明                                      |
| ------------------------- | ----------------------------------------- |
| public String()           | 创建一个空白字符串，不含任何内容          |
| public String(char[] chs) | 根据字符数组的内容来创建字符串对象        |
| public String(byte[] bys) | 根据字节数组的内容来创建字符串对象        |
| String str = "abc";       | 直接复制的方式创建字符串对象，内容就是abc |

**创建字符串对象两种方式的区别**

* 通过构造方法创建

  ​	通过new创建的字符串对象，每一次new都会申请一个内存空间，虽然内容相同，但是地址值不同

* 直接赋值方式创建

  ​	以""方式给出的字符串，只要字符序列相同（顺序和大小写），无论在程序代码中出现几次，JVM 都只会建立一个String对象，并在字符串池中维护。

**字符串的比较**

1. ==号的作用

   * 比较基本数据类型：比较的是具体的值
   * 比较引用数据类型：比较的是对象地址值

2. equals方法的作用

   比较两个字符串内容是否相同、区分大小写。

| String类常用方法                            | 说明                           |
| ------------------------------------------- | ------------------------------ |
| public boolean equals(Object obj)           | 比较字符串内容，严格区别大小写 |
| public boolean equalsIgnoreCase(Object obj) | 比较字符串内容，不区分大小写   |
| public char charAt(int index)               | 返回指定索引处的char值         |
| public int length()                         | 返回字符串的长度               |

### 2. String Builder类

​	StringBuilder类是一个可变的字符串类，可以把它看成一个容器。可变指的是StringBuilder对象中的内容可变。

**StringBuilder和String的区别**

* String 内容不可变
* StringBuilder 内容可变

**构造方法**

| 方法名                           | 说明                                       |
| -------------------------------- | ------------------------------------------ |
| public StringBuilder()           | 创建一个空白可变字符串对象，不含有任何内容 |
| public StringBuilder(String str) | 根据字符串的内容创建可变字符串对象         |

**StringBuilder类添加和反转方法**

| 方法名                                  | 说明                     |
| --------------------------------------- | ------------------------ |
| public StringBuilder append(Object obj) | 添加数据，并返回对象本身 |
| public StringBuilder reverse()          | 返回相反的字符序列       |

**StringBuilder和String相互转换**

* StringBuilder转换成String

  ​	public String toString(): 通过toString()就可以实现把StringBuilder转换成String

* String转换为StringBuilder

  ​	public StringBuilder(String str): 通过构造方法

**StringBuilder常用方法**

| 方法名                                 | 说明                                                |
| -------------------------------------- | --------------------------------------------------- |
| public StringBuilder append (任意类型) | 添加数据，并返回对象本身                            |
| public StringBuilder reverse()         | 返回相反的字符序列                                  |
| public int length()                    | 返回长度，实际存储值                                |
| public String toString()               | 通过toString()就可以实现把StringBuilder转换为String |

### 3. Math类

​	Math包含执行基本数字运算的方法，内部的方法都是静态的，可用过<b>类名.</b>进行调用

**常用方法**

| 方法名    方法名                               | 说明                                           |
| ---------------------------------------------- | ---------------------------------------------- |
| public static int abs(int a)                 | 返回参数的绝对值                               |
| public static double ceil(double a)            | 返回大于或等于参数的最小double值，等于一个整数 |
| public static double floor(double a)           | 返回小于或等于参数的最大double值，等于一个整数 |
| public static int round(float a)             | 按照四舍五入返回最接近参数的int                |
| public static int max(int a,int b)           | 返回两个int值中的较大值                        |
| public static int min(int a,int b)           | 返回两个int值中的较小值                        |
| public static double pow (double a,double b) | 返回a的b次幂的值                               |
| public static double random()                | 返回值为double的正值，[0.0,1.0)                |

### 4. System类

| 方法名                                  | 说明                                       |
| --------------------------------------- | ------------------------------------------ |
| public  static void exit(int status)    | 终止当前运行的Java虚拟机，非零表示异常终止 |
| public  static long currentTimeMillis() | 返回当前时间(以毫秒为单位)                 |

### 5. Object类

​	Object 是类层次结构的根，每个类都可以将 Object 作为超类。所有类都直接或者间接的继承自该类，换句话说，该类所具备的方法，所有类都会有一份。

**toString()方法**

​	以良好的格式，更方便的展示对象中的属性值。

**equals()方法**

​	用于对象之间的比较，返回true和false的结果。如果想结合对象属性进行比较的时候，可以重写equals()和hashCode()方法。

### 6. Arrays类

| 方法名                                   | 说明                                                         |
| ---------------------------------------- | ------------------------------------------------------------ |
| public static String toString(int[] a)   | 返回指定数组的内容的字符串表示形式                           |
| public static <T> List<T> asList(T... a) | 返回由指定数组支持的固定大小的列表<br>返回的集合不能做增删操作，可以做修改操作 |
| public static void sort(int[] a)         | 按照数字顺序排列指定的数组                                   |

### 7. 包装类

​	将基本数据类型封装成对象的好处在于可以在对象中定义更多的功能方法操作该数据

​	常用的操作之一：用于基本数据类型与字符串之间的转换

| 基本数据类型 | 包装类    |
| ------------ | --------- |
| byte         | Byte      |
| short        | Short     |
| int          | Integer   |
| long         | Long      |
| float        | Float     |
| double       | Double    |
| char         | Character |
| boolean      | Boolean   |

**Integer类**

​	包装一个对象中的原始类型Int的值

* 构造方法

| 方法名                                  | 说明                                     |
| --------------------------------------- | ---------------------------------------- |
| public Integer(int   value)             | 根据 int 值创建 Integer 对象(过时)       |
| public Integer(String s)                | 根据 String 值创建 Integer 对象(过时)    |
| public static Integer valueOf(int i)    | 返回表示指定的 int 值的 Integer   实例   |
| public static Integer valueOf(String s) | 返回一个保存指定值的 Integer 对象 String |

* int和String类型的互相转换

> String to int
>
> 	* 先将字符串数字转成Integer，再调用valueOf()方法
> 	* 通过Integer静态方法parseInt()进行转换
>
> int to String
>
> 	* 直接在数字后加一个空字符串
> 	* 通过String类静态方法valueOf()

### 8. 时间日期类

**Date类**

* 构造方法

| 方法名                 | 说明                                                         |
| ---------------------- | ------------------------------------------------------------ |
| public Date()          | 分配一个 Date对象，并初始化，以便它代表它被分配的时间，精确到毫秒 |
| public Date(long date) | 分配一个 Date对象，并将其初始化为表示从标准基准时间起指定的毫秒数 |

* 常用方法

| 方法名                         | 说明                                                  |
| ------------------------------ | ----------------------------------------------------- |
| public long getTime()          | 获取的是日期对象从1970年1月1日 00:00:00到现在的毫秒值 |
| public void setTime(long time) | 设置时间，给的是毫秒值                                |

**SimpleDataFormat类**

​	SimpleDateFormat是一个具体的类，用于以区域设置敏感的方式格式化和解析日期。

* 构造方法

| 方法名                                  | 说明                                                   |
| --------------------------------------- | ------------------------------------------------------ |
| public SimpleDateFormat()               | 构造一个SimpleDateFormat，使用默认模式和日期格式       |
| public SimpleDateFormat(String pattern) | 构造一个SimpleDateFormat使用给定的模式和默认的日期格式 |

* 常用方法

| 方法名                                | 说明                                 |
| ------------------------------------- | ------------------------------------ |
| public final String format(Date date) | 将日期格式化成日期/时间字符串        |
| public Date parse(String source)      | 从给定字符串的开始解析文本以生成日期 |

**Calender类**

​	Calendar 为特定瞬间与一组日历字段之间的转换提供了一些方法，并为操作日历字段提供了一些方法。

​	Calendar 提供了一个类方法 getInstance 用于获取这种类型的一般有用的对象，该方法返回一个Calendar 对象，其日历字段已使用当前日期和时间初始化：Calendar cld= Calendar.getInstance();

- 常用方法

| 方法名                                             | 说明                                                   |
| -------------------------------------------------- | ------------------------------------------------------ |
| public int  get(int field)                         | 返回给定日历字段的值                                   |
| public abstract void add(int field, int amount)    | 根据日历的规则，将指定的时间量添加或减去给定的日历字段 |
| public final void set(int year,int month,int date) | 设置当前日历的年月日                                   |

## 三、异常

​	异常就是程序出现了不正常的情况

![image-20201201172328304](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/image-20201201172328304.png)

**JVM默认异常处理**

​	如果程序出现任何问题，我们没有做任何处理，最终JVM会做默认处理，把异常的名称，错误原因及异常出现的位置等信息输出在控制台上，异常停止执行。

**try-catch方式处理**

格式：

```java
try {
    可能出现异常的代码;
} catch(异常类名 变量名) {
    异常处理代码;
}
```

**Throwable成员方法**

| 方法名                        | 说明                              |
| ----------------------------- | --------------------------------- |
| public String getMessage()    | 返回此 throwable 的详细消息字符串 |
| public String toString()      | 返回此可抛出的简短描述            |
| public void printStackTrace() | 把异常的错误信息输出在控制台      |

**编译时异常和运行时异常的区别**

* 编译时异常

  都是Exception类及其子类，必须显式处理，否则程序会发生错误，无法编译通过。

* 运行时异常

  都是RuntimeException类及其子类，无需显式处理，也可以和编译时异常处理一样。

**throws方式处理异常**

​	格式：

```java
public void 方法() throws 异常类名 {
}
```

- 这个throws格式是跟在方法的括号后面的
- 编译时异常必须要进行处理，两种处理方案：try...catch …或者 throws，如果采用 throws 这种方案，将来谁调用谁处理
- 运行时异常可以不处理，出现问题后，需要我们回来修改代码

## 四、集合

​	集合类特点：提供一种存储空间可变的存储模型，存储的数据容量可以随时发生改变。

![image-20201201174810438](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/image-20201201174810438.png)

**数据结构**

* 栈结构：先进后出
* 队列结构：先进先出
* 数组结构：查询快，增删慢
* 链表结构：查询慢、增删快

**Collection集合**

​	是单例集合的顶层接口，它白哦是一组对象，这些对象也成为Collection的元素。

* 常用方法

| 方法名                     | 说明                               |
| -------------------------- | ---------------------------------- |
| boolean add(E e)           | 添加元素                           |
| boolean remove(Object o)   | 从集合中移除指定的元素             |
| void clear()               | 清空集合中的元素                   |
| boolean contains(Object o) | 判断集合中是否存在指定的元素       |
| boolean isEmpty()          | 判断集合是否为空                   |
| int size()                 | 集合的长度，也就是集合中元素的个数 |

**Collection集合的遍历**

* 迭代器Iterator

  集合的专用遍历方式。

  Iterator<E> iterator(): 返回此集合中元素的迭代器

**List集合**

​	有序集合，用户可以精确控制列表中每个元素的插入位置。用户剋通过整数索引访问元素，并搜索列表中的元素。

特点：

* 有索引
* 可以存储重复元素
* 元素存取有序

​	<b>List集合特有方法</b>

| 方法名                         | 描述                                   |
| ------------------------------ | -------------------------------------- |
| void add(int index, E element) | 在此集合中的指定位置插入指定的元素     |
| E remove(int index)            | 删除指定索引处的元素，返回被删除的元素 |
| E set(int index, E element)    | 修改指定索引处的元素，返回被修改的元素 |
| E get(int index)               | 返回指定索引处的元素                   |

​		<b>并发修改异常</b>

​	迭代器遍历的过程中，通过集合对象修改了集合中的元素，造成了迭代器获取元素中判断预期值修改值和实际修改值不一致，则会出现：ConcurrentModificationException

​		<b>Listlterator列表迭代器</b>

​	通过List集合的listlterator()方法得到，是List集合的特有迭代器。允许程序员沿任意方向遍历的列表迭代器，在迭代期间修改列表，并获取列表中迭代器的当前位置。

​		<b>增强for循环</b>

```java
for(元素数据类型 变量名 : 数组/集合对象名) {
    循环体;
}
```

**List集合子类**

* ArrayList集合：底层是数组结构，查询快、增删慢
* LinkedList集合：底层是链表结构，查询慢，增删快

1. **ArrayList**

| 方法名                               | 说明                                   |
| ------------------------------------ | -------------------------------------- |
| public boolean remove(Object o)      | 删除指定的元素，返回删除是否成功       |
| public E remove(int index)           | 删除指定索引处的元素，返回被删除的元素 |
| public E set(int index, E element)   | 修改指定索引处的元素，返回被修改的元素 |
| public E get(int index)              | 返回指定索引处的元素                   |
| public int size()                    | 返回集合中的元素的个数                 |
| public boolean add(E e)              | 将指定的元素追加到此集合的末尾         |
| public void add(int index,E element) | 在此集合中的指定位置插入指定的元素     |

2. **LinkedList集合特有方法**

| 方法名                    | 说明                             |
| ------------------------- | -------------------------------- |
| public void addFirst(E e) | 在该列表开头插入指定的元素       |
| public void addLast(E e)  | 将指定的元素追加到此列表的末尾   |
| public E getFirst()       | 返回此列表中的第一个元素         |
| public   E getLast()      | 返回此列表中的最后一个元素       |
| public E removeFirst()    | 从此列表中删除并返回第一个元素   |
| public   E removeLast()   | 从此列表中删除并返回最后一个元素 |

**Set集合**

* 元素存取无序
* 没有索引，只能通过迭代器或者增强for循环遍历
* 不能存储重复元素

1. 哈希值

   JDK根据对象的地址或者字符串或者数字算出来的int类型的数值

   特点：同一个对象多次调用hashCode()方法返回的哈希值是相同的。

   ​			默认情况下，不同对象的哈希值是不同的。重写hashCode()方法可以实现让不同对象的哈希值相同。

2. HashSet集合

   * 底层数据结构是哈希表
   * 对集合的迭代顺序不做任何保证，也就是说不保证存储和去除的元素顺序一致
   * 没有带索引的写法，所以不能使用普通for循环遍历
   * 由于是Set集合，所以是不包含重复元素的集合

   保证唯一性图解：

   ![](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/image-20201201184454374.png)

3. LinkedHashSet集合
   * 哈希表和链表实现的Set接口，具有可预测的迭代次序
   * 有链表保证元素有序
   * 哈希表保证元素唯一
4. TreeSet集合
   * 元素有序，可以按照一定的规则进行排序，具体排序取决于构造方法
     * TreeSet(): 根据其元素的自然排序进行排序
     * TreeSet(Comparator comparator): 根据指定的比较器进行排序
   * 没有带索引的方法，所以不能使用普通for循环遍历
   * 不包含重复元素

5. 自然排序Comparable的使用

   ​	让元素所属的类实现Comparable接口，重写compareTo(T o)方法。重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写。

6. 比较器排序Comparator

   ​	比较器排序，就是让集合构造方法接收Comparator的实现类对象，重写compare(T o1,T o2)方法。

   重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写。

**Map集合**

- 键值对映射关系
- 一个键对应一个值
- 键不能重复，值可以重复
- 元素存取无序

| 方法名                              | 说明                                 |
| ----------------------------------- | ------------------------------------ |
| V put(K key, V value)               | 添加元素                             |
| V remove(Object key)                | 根据键删除键值对元素                 |
| void clear()                        | 移除所有的键值对元素                 |
| boolean containsKey(Object key)     | 判断集合是否包含指定的键             |
| boolean containsValue(Object value) | 判断集合是否包含指定的值             |
| boolean isEmpty()                   | 判断集合是否为空                     |
| int size()                          | 集合的长度，也就是集合中键值对的个数 |

| 方法名                           | 说明                     |
| -------------------------------- | ------------------------ |
| V   get(Object key)              | 根据键获取值             |
| Set<K>   keySet()                | 获取所有键的集合         |
| Collection<V>   values()         | 获取所有值的集合         |
| Set<Map.Entry<K,V>>   entrySet() | 获取所有键值对对象的集合 |

1. Map集合遍历1
   - 获取所有键的集合。用keySet()方法实现
   - 遍历键的集合，获取到每一个键。用增强for实现  
   - 根据键去找值。用get(Object key)方法实现

2. Map集合遍历2
   - 获取所有键值对对象的集合
     - Set<Map.Entry<K,V>> entrySet()：获取所有键值对对象的集合
   - 遍历键值对对象的集合，得到每一个键值对对象
     - 用增强for实现，得到每一个Map.Entry
   - 根据键值对对象获取键和值
     - 用getKey()得到键
     - 用getValue()得到值

**Collections集合工具类**

| 方法名                                   | 说明                               |
| ---------------------------------------- | ---------------------------------- |
| public static void sort(List<T> list)    | 将指定的列表按升序排序             |
| public static void reverse(List<?> list) | 反转指定列表中元素的顺序           |
| public static void shuffle(List<?> list) | 使用默认的随机源随机排列指定的列表 |

## 五、流

1. ### **File类**

**介绍：**

* 它是文件和目录路径名的抽象表示
* 文件和目录是可以通过File封装成对象的
* 对于File而言，其封装的并不是一个真正存在的文件，仅仅是一个路径名而已。它可以是存在的，也可以是不存在的。将来是要将通过具体的操作把这个路径的内容转换为具体存在的。

**构造方法**

| 方法名                            | 说明                                                        |
| --------------------------------- | ----------------------------------------------------------- |
| File(String pathname)             | 通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例 |
| File(String parent, String child) | 从父路径名字符串和子路径名字符串创建新的File实例            |
| File(File parent, String child)   | 从父抽象路径名和子路径名字符串创建新的File实例              |

**File类的创建功能**

| 方法名                         | 说明                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| public boolean createNewFile() | 当具有该名称的文件不存在时，创建一个由该抽象路径名命名的新空文件 |
| public boolean mkdir()         | 创建由此抽象路径名命名的目录                                 |
| public boolean mkdirs()        | 创建由此抽象路径名命名的目录，包括任何必需但不存在的父目录   |

**File类判断和获取功能**

- 判断功能

  | 方法名                         | 说明                                 |
  | ------------------------------ | ------------------------------------ |
  | public   boolean isDirectory() | 测试此抽象路径名表示的File是否为目录 |
  | public   boolean isFile()      | 测试此抽象路径名表示的File是否为文件 |
  | public   boolean   exists()    | 测试此抽象路径名表示的File是否存在   |

- 获取功能

  | 方法名                            | 说明                                                     |
  | --------------------------------- | -------------------------------------------------------- |
  | public   String getAbsolutePath() | 返回此抽象路径名的绝对路径名字符串                       |
  | public   String getPath()         | 将此抽象路径名转换为路径名字符串                         |
  | public   String getName()         | 返回由此抽象路径名表示的文件或目录的名称                 |
  | public   String[] list()          | 返回此抽象路径名表示的目录中的文件和目录的名称字符串数组 |
  | public   File[] listFiles()       | 返回此抽象路径名表示的目录中的文件和目录的File对象数组   |

**FIle类的删除功能**

| 方法名                    | 说明                               |
| ------------------------- | ---------------------------------- |
| public boolean   delete() | 删除由此抽象路径名表示的文件或目录 |

2. ### **IO流**

* IO流介绍
  * IO：输入/输出(Input/Output)
  * 流：是一种抽象概念，是对数据传输的总称。也就是说数据在设备间的传输称为流，流的本质是数据传输
  * IO流就是用来出来设备间数据传输问题的。
* IO流的分类
  * 按照数据的流向：输入流、输出流
  * 按照数据类型：字节流、字符流
* IO流使用场景
  * 如果是纯文本文件，优先使用字符流
  * 如果是图片、视频、音频等二进制文件。优先使用字节流
  * 如果不确定文件类型，优先使用字节流。字节流是万能流

### 字节流读写数据

* 字节流抽象基类
  * InputStream: 这个抽象类是表示字节输入流的所有类的超类
  * OutputStream: 这个抽象类是表示字节输出流的所有类的超类
  * 子类名特点：子类名称都是以其父类名作为子类名的后缀
* 字节输出流：FileOutputStream(String str): 创建文件输出流以指定的名称写入文件
* 字节输出流使用步骤：①创建字节输出流对象②调用字节输出流对象的写数据方法③释放资源

字节输出流写数据方法

| 方法名                                   | 说明                                                         |
| ---------------------------------------- | ------------------------------------------------------------ |
| void   write(int b)                      | 将指定的字节写入此文件输出流   一次写一个字节数据            |
| void   write(byte[] b)                   | 将 b.length字节从指定的字节数组写入此文件输出流   一次写一个字节数组数据 |
| void   write(byte[] b, int off, int len) | 将 len字节从指定的字节数组开始，从偏移量off开始写入此文件输出流   一次写一个字节数组的部分数据 |

* 字节流写数据实现追加数据：public FileOutputStream(String name,boolean append)创建文件输出流以指定的名称写入文件。如果第二个参数为true ，则字节将写入文件的末尾而不是开头。
* 字节输入流：FileInputStream(String name)：通过打开与实际文件的连接来创建一个FileInputStream ，该文件由文件系统中的路径名name命名
* 字节输入流使用：①创建字节输入流对象②调用字节输入流对象的读数据方法③释放资源

### 字节缓冲流

* 字节缓冲流介绍：
  * BufferOutputStream: 该类实现缓冲输出流。通过设置这样的输出流，应用程序额可以向底层输出流写入字节，而不必为写入的每个字节导致底层系统的调用。
  * BufferInputStream: 创建BufferedInputStream将创建一个内部缓冲区数组。 当从流中读取或跳过字节时，内部缓冲区将根据需要从所包含的输入流中重新填充，一次很多字节

构造方法

| 方法名                                 | 说明                   |
| -------------------------------------- | ---------------------- |
| BufferedOutputStream(OutputStream out) | 创建字节缓冲输出流对象 |
| BufferedInputStream(InputStream in)    | 创建字节缓冲输入流对象 |

### 字符流

* 字符流 = 字节流 + 编码表

* 汉字在存储的过程中，无论选择哪种编码储存，第一个字节数都是负数

* 字符集是一个系统支持的所有字符的集合，包含各国家文字、标点符号、图形符号、数字等。

* 计算机要准确的存储和识别各种字符集符号，就需要进行字符编码，一套字符集必然至少有一套字符编码。常见的字符集有ASCII字符集、GB字符集、Unicode字符集等

* ASCII字符集：

  基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符(回车键、退格、换行键等)和可显示字符(英文大小写字符、阿拉伯数字和西文符号) 。基本的ASCII字符集，使用7位表示一个字符，共128字符。ASCII的扩展字符集使用8位表示一个字符，共256字符，方便支持欧洲常用字符。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等

* GB字符集：

  GBK：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等

* Unicode字符集：

  UTF-8编码：可以用来表示Unicode标准中任意字符，它是电子邮件、网页及其他存储或传送文字的应用 中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。它使用一至四个字节为每个字符编码

  编码规则：

  * 128个US-ASCII字符，只需要一个字节编码
  * 拉丁文等字符，需要两个字节编码
  * 大部分常用字（含中文），使用三个字节编码
  * 其他极少数使用Unicode辅助字符，使用四字节编码

字符串编码解码问题

| 方法名                                   | 说明                                               |
| ---------------------------------------- | -------------------------------------------------- |
| byte[] getBytes()                        | 使用平台的默认字符集将该 String编码为一系列字节    |
| byte[] getBytes(String charsetName)      | 使用指定的字符集将该 String编码为一系列字节        |
| String(byte[] bytes)                     | 使用平台的默认字符集解码指定的字节数组来创建字符串 |
| String(byte[] bytes, String charsetName) | 通过指定的字符集解码指定的字节数组来创建字符串     |

字符流中编码解码问题

* 字符流中和编码解码两个问题相关的两个类

  * InputStreamReader: 是从字节流到字符流的桥梁

    它读取字节，并使用指定的编码将其解码为字符

    它使用的字符集可以由名称指定，也可以被明确指定，或者可以接受平台的默认字符集

  * OutputStreamWriter: 是从字符流到到字节流的桥梁

    是从字符流到字节流的桥梁，使用指定的编码将写入的字符编码为字节

    它使用的字符集可以由名称指定，也可以被明确指定，或者可以接受平台的默认字符集

* 构造方法

| 方法名                                              | 说明                                         |
| --------------------------------------------------- | -------------------------------------------- |
| InputStreamReader(InputStream in)                   | 使用默认字符编码创建InputStreamReader对象    |
| InputStreamReader(InputStream in,String chatset)    | 使用指定的字符编码创建InputStreamReader对象  |
| OutputStreamWriter(OutputStream out)                | 使用默认字符编码创建OutputStreamWriter对象   |
| OutputStreamWriter(OutputStream out,String charset) | 使用指定的字符编码创建OutputStreamWriter对象 |

字符流写数据的5种方式

| 方法名                                    | 说明                 |
| ----------------------------------------- | -------------------- |
| void write(int c)                         | 写一个字符           |
| void write(char[] cbuf)                   | 写入一个字符数组     |
| void write(char[] cbuf, int off, int len) | 写入字符数组的一部分 |
| void write(String str)                    | 写一个字符串         |
| void write(String str, int off, int len)  | 写一个字符串的一部分 |

刷新和关闭的方法

| 方法名  | 说明                                                         |
| ------- | ------------------------------------------------------------ |
| flush() | 刷新流，之后还可以继续写数据                                 |
| close() | 关闭流，释放资源，但是在关闭之前会先刷新流。一旦关闭，就不能再写数据 |

字符流读数据的2种方式

| 方法名                | 说明                   |
| --------------------- | ---------------------- |
| int read()            | 一次读一个字符数据     |
| int read(char[] cbuf) | 一次读一个字符数组数据 |

### 字符缓冲流

* BufferedWriter：将文本写入字符输出流，缓冲字符，以提供单个字符，数组和字符串的高效写入，可以指定缓冲区大小，或者可以接受默认大小。默认值足够大，可用于大多数用途
* BufferedReader：从字符输入流读取文本，缓冲字符，以提供字符，数组和行的高效读取，可以指定缓冲区大小，或者可以使用默认大小。 默认值足够大，可用于大多数用途

| 方法名                     | 说明                   |
| -------------------------- | ---------------------- |
| BufferedWriter(Writer out) | 创建字符缓冲输出流对象 |
| BufferedReader(Reader in)  | 创建字符缓冲输入流对象 |

字符流特有功能

BufferedWriter：

| 方法名         | 说明                                         |
| -------------- | -------------------------------------------- |
| void newLine() | 写一行行分隔符，行分隔符字符串由系统属性定义 |

  BufferedReader:

| 方法名            | 说明                                                         |
| ----------------- | ------------------------------------------------------------ |
| String readLine() | 读一行文字。 结果包含行的内容的字符串，不包括任何行终止字符如果流的结尾已经到达，则为null |

### 打印流

* 字节打印流： PrintStream
* 字符打印流： PrintWriter
* 打印流只负责输出数据，不负责读取数据，永不抛出IOException异常，与自己特有方法
* 字节打印流：PrintStream(String fileName)：使用指定的文件名创建新的打印流
  * 使用继承父类的方法写数据，查看的时候会转码；使用自己的特有方法写数据，查看的数据原样输出
  * public static void setOut(PrintStream out)：重新分配“标准”输出流
* 字符打印流构造方法

| 方法名                                       | 说明                                                         |
| -------------------------------------------- | ------------------------------------------------------------ |
| PrintWriter(String   fileName)               | 使用指定的文件名创建一个新的PrintWriter，而不需要自动执行刷新 |
| PrintWriter(Writer   out, boolean autoFlush) | 创建一个新的PrintWriter    out：字符输出流    autoFlush： 一个布尔值，如果为真，则println ， printf ，或format方法将刷新输出缓冲区 |

### 对象序列化流

- 对象序列化介绍

  - 对象序列化：就是将对象保存到磁盘中，或者在网络中传输对象
  - 这种机制就是使用一个字节序列表示一个对象，该字节序列包含：对象的类型、对象的数据和对象中存储的属性等信息
  - 字节序列写到文件之后，相当于文件中持久保存了一个对象的信息
  - 反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化

- 对象序列化流： ObjectOutputStream

  - 将Java对象的原始数据类型和图形写入OutputStream。 可以使用ObjectInputStream读取（重构）对象。 可以通过使用流的文件来实现对象的持久存储。 如果流是网络套接字流，则可以在另一个主机上或另一个进程中重构对象 

- 构造方法

  | 方法名                               | 说明                                               |
  | ------------------------------------ | -------------------------------------------------- |
  | ObjectOutputStream(OutputStream out) | 创建一个写入指定的OutputStream的ObjectOutputStream |

- 序列化对象的方法

  | 方法名                       | 说明                               |
  | ---------------------------- | ---------------------------------- |
  | void writeObject(Object obj) | 将指定的对象写入ObjectOutputStream |

注意事项

- 一个对象要想被序列化，该对象所属的类必须必须实现Serializable 接口
- Serializable是一个标记接口，实现该接口，不需要重写任何方法

### ****对象反序列化流****

- 对象反序列化流： ObjectInputStream

  - ObjectInputStream反序列化先前使用ObjectOutputStream编写的原始数据和对象

- 构造方法

  | 方法名                            | 说明                                           |
  | --------------------------------- | ---------------------------------------------- |
  | ObjectInputStream(InputStream in) | 创建从指定的InputStream读取的ObjectInputStream |

- 反序列化对象的方法

  | 方法名              | 说明                            |
  | ------------------- | ------------------------------- |
  | Object readObject() | 从ObjectInputStream读取一个对象 |

### Properties集合

Properties介绍

- 是一个Map体系的集合类
- Properties可以保存到流中或从流中加载
- 属性列表中的每个键及其对应的值都是一个字符串

- 特有方法

  | 方法名                                         | 说明                                                         |
  | ---------------------------------------------- | ------------------------------------------------------------ |
  | Object   setProperty(String key, String value) | 设置集合的键和值，都是String类型，底层调用   Hashtable方法 put |
  | String   getProperty(String key)               | 使用此属性列表中指定的键搜索属性                             |
  | Set<String>   stringPropertyNames()            | 从该属性列表中返回一个不可修改的键集，其中键及其对应的值是字符串 |

Properties和IO流相结合的方法

| 方法名                                          | 说明                                                         |
| ----------------------------------------------- | ------------------------------------------------------------ |
| void   load(InputStream inStream)               | 从输入字节流读取属性列表（键和元素对）                       |
| void   load(Reader reader)                      | 从输入字符流读取属性列表（键和元素对）                       |
| void   store(OutputStream out, String comments) | 将此属性列表（键和元素对）写入此   Properties表中，以适合于使用   load(InputStream)方法的格式写入输出字节流 |
| void   store(Writer writer, String comments)    | 将此属性列表（键和元素对）写入此   Properties表中，以适合使用   load(Reader)方法的格式写入输出字符流 |

## 六、多线程

### **进程和线程**

* 进程是正在运行的程序、是系统进行资源分配和调用的独立单位、每一个进程都有自己的内存空间和系统资源
* 线程是进程中的单个顺序控制流，是一条执行路径。单线程：一个进行如果只有一条1执行路径，则称为单线程程序；多线程：一个进程如果拥有多条执行路径，则称为多线程程序。

### 实现多线程方式一：继承Thread类

- 方法介绍

  | 方法名       | 说明                                        |
  | ------------ | ------------------------------------------- |
  | void run()   | 在线程开启后，此方法将被调用执行            |
  | void start() | 使此线程开始执行，Java虚拟机会调用run方法() |

- 实现步骤
  - 定义一个类MyThread继承Thread类
  - 在MyThread类中重写run()方法
  - 创建MyThread类的对象
  - 启动线程

```java
public class ThreadTest1 {
    public static void main(String[] args) {
        new MyThread("高铁").start();
        new MyThread("飞机").start();
    }
}
class MyThread extends Thread {
    public MyThread() {
    }
    public MyThread(String name) {
        super(name);
    }
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName());
    }
}
```

* run()是用来封装被线程执行的代码

* start()：启动线程；然后由JVM调用此线程的run()方法

  run()：封装线程执行的代码，直接调用，相当于普通方法的调用

设置和获取线程名称

- 方法介绍

  | 方法名                     | 说明                               |
  | -------------------------- | ---------------------------------- |
  | void  setName(String name) | 将此线程的名称更改为等于参数name   |
  | String  getName()          | 返回此线程的名称                   |
  | Thread  currentThread()    | 返回对当前正在执行的线程对象的引用 |

### 线程的实现方式二：实现Runnable接口

- Thread构造方法

  | 方法名                               | 说明                   |
  | ------------------------------------ | ---------------------- |
  | Thread(Runnable target)              | 分配一个新的Thread对象 |
  | Thread(Runnable target, String name) | 分配一个新的Thread对象 |

- 实现步骤

  - 定义一个类MyRunnable实现Runnable接口
  - 在MyRunnable类中重写run()方法
  - 创建MyRunnable类的对象
  - 创建Thread类的对象，把MyRunnable对象作为构造方法的参数
  - 启动线程

```java
class MyRunnable implements Runnable {
    public void run() {
        System.out.println(Thread.currentThread().getName() + ":" + i);
    }
}
public class Test {
    public static void main(String[] args) {
        //创建MyRunnable类的对象
        MyRunnable my = new MyRunnable();
        new Thread(my, "高铁").start();
        new Thread(my, "飞机").start();
    }
}
```

相比继承Thread类，实现Runnable接口的好处

- 避免了Java单继承的局限性
- 适合多个相同程序的代码去处理同一个资源的情况，把线程和程序的代码、数据有效分离，较好的体现了面向对象的设计思想

### 其他实现多线程方式

匿名内部类

```java
public class Demo3 {
    public static void main(String[] args) {
        //方式1：相当于继承了Thread类，作为子类重写run()实现
        new Thread() {
            public void run() {
                System.out.println("匿名内部类创建线程方式1...");
            }
        }.start();
        //方式2:实现Runnable,Runnable作为匿名内部类
        new Thread(new Runnable() {
            public void run() {
                System.out.println("匿名内部类创建线程方式2...");
            }
        }).start();
    }
}
```

带返回值的线程(实现implements Callable<返回值类型>)

```java
public class Demo5 implements Callable<String> {
    public String call() throws Exception {
        System.out.println("正在执行新建线程任务");
        Thread.sleep(2000);
        return "新建线程睡了2s后返回执行结果";
    }
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        Demo5 demo5 = new Demo5();
        /**
         * call()只是线程任务,对线程任务进行封装
         * class FutureTask<V> implements RunnableFuture<V>
         * interface RunnableFuture<V> extends Runnable, Future<V>
         */
        FutureTask<String> task = new FutureTask<>(demo5);
        new Thread(task).start();
        System.out.println("线程执行结果为: " + task.get());
    }
}
```

定时器(java.util.Timer)

```java
public class Demo6 {
    public static void main(String[] args) {
        Timer timer = new Timer();
        timer.schedule(new TimerTask() {
            @Override
            public void run() {
                System.out.println("定时任务延迟0(即立刻执行),每隔1000ms执行一次");
            }
        }, 0, 1000);
    }
}
```

线程池的实现(java.util.concurrent.Executor接口)

```java
public class Demo7 {
    public static void main(String[] args) {
        // 创建带有5个线程的线程池
        // 返回的实际上是ExecutorService,而ExecutorService是Executor的子接口
        Executor threadPool = Executors.newFixedThreadPool(5);
        for (int i = 0; i < 10; i++) {
            threadPool.execute(new Runnable() {
                public void run() {
                    System.out.println(Thread.currentThread().getName() + " is running");
                }
            });
        }
    }
}
```

### 线程优先级

线程调度方式

* 分时调度模型：所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间片
* 抢占式调度模型：优先让优先级高的线程使用CPU，如果线程的优先级相同，那么会随机挑选一个，优先级高的线程获取的CPU时间片相对多一些

Java使用的是抢占式调度模型

优先级相关方法

| 方法名                                  | 说明                                                         |
| --------------------------------------- | ------------------------------------------------------------ |
| final int getPriority()                 | 返回此线程的优先级                                           |
| final void setPriority(int newPriority) | 更改此线程的优先级<br/>线程默认优先级是5；线程优先级的范围是：1-10 |

```java
class ThreadPriority extends Thread {
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println(getName() + ":" + i);
        }
    }
}

public class ThreadPriorityDemo {
    public static void main(String[] args) {
        ThreadPriority tp1 = new ThreadPriority();
        ThreadPriority tp2 = new ThreadPriority();
        ThreadPriority tp3 = new ThreadPriority();

        tp1.setName("高铁");
        tp2.setName("飞机");
        tp3.setName("汽车");

        // public final int getPriority()：返回此线程的优先级
        System.out.println(tp1.getPriority()); //5
        System.out.println(tp2.getPriority()); //5
        System.out.println(tp3.getPriority()); //5

        // public final void setPriority(int newPriority)：更改此线程的优先级
//        tp1.setPriority(10000); //IllegalArgumentException
        System.out.println(Thread.MAX_PRIORITY); //10
        System.out.println(Thread.MIN_PRIORITY); //1
        System.out.println(Thread.NORM_PRIORITY); //5

        //设置正确的优先级
        tp1.setPriority(5);
        tp2.setPriority(10);
        tp3.setPriority(1);

        tp1.start();
        tp2.start();
        tp3.start();
    }
}
```

### 线程控制

| 方法名                         | 说明                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| static void sleep(long millis) | 使当前正在执行的线程停留（暂停执行）指定的毫秒数             |
| void join()                    | 等待这个线程死亡                                             |
| void setDaemon(boolean on)     | 将此线程标记为守护线程，当运行的线程都是守护线程时，Java虚拟机将退出 |

```java
sleep演示：
class ThreadSleep extends Thread {
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println(getName() + ":" + i);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

public class ThreadSleepDemo {
    public static void main(String[] args) {
        ThreadSleep ts1 = new ThreadSleep();
        ThreadSleep ts2 = new ThreadSleep();
        ThreadSleep ts3 = new ThreadSleep();

        ts1.setName("曹操");
        ts2.setName("刘备");
        ts3.setName("孙权");

        ts1.start();
        ts2.start();
        ts3.start();
    }
}

Join演示：

class ThreadJoin extends Thread {
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println(getName() + ":" + i);
        }
    }
}

public class ThreadJoinDemo {
    public static void main(String[] args) {
        ThreadJoin tj1 = new ThreadJoin();
        ThreadJoin tj2 = new ThreadJoin();
        ThreadJoin tj3 = new ThreadJoin();

        tj1.setName("康熙");
        tj2.setName("四阿哥");
        tj3.setName("八阿哥");

        tj1.start();
        try {
            tj1.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        tj2.start();
        tj3.start();
    }
}

Daemon演示：
class ThreadDaemon extends Thread {
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println(getName() + ":" + i);
        }
    }
}

public class ThreadDaemonDemo {
    public static void main(String[] args) {
        ThreadDaemon td1 = new ThreadDaemon();
        ThreadDaemon td2 = new ThreadDaemon();

        td1.setName("关羽");
        td2.setName("张飞");

        //设置主线程为刘备
        Thread.currentThread().setName("刘备");

        //设置守护线程
        td1.setDaemon(true);
        td2.setDaemon(true);

        td1.start();
        td2.start();

        for (int i = 0; i < 10; i++) {
            System.out.println(Thread.currentThread().getName() + ":" + i);
        }
    }
}
```

### 线程的生命周期

![image-20201202184457858](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/image-20201202184457858.png)

### 线程同步

#### 同步代码块解决数据安全问题

- 安全问题出现的条件

  - 是多线程环境

  - 有共享数据

  - 有多条语句操作共享数据

- 如何解决多线程安全问题呢?

  - 基本思想：让程序没有安全问题的环境

- 怎么实现呢?

  - 把多条语句操作共享数据的代码给锁起来，让任意时刻只能有一个线程执行即可
  - Java提供了同步代码块的方式来解决

```java
synchronized(任意对象) { 
	多条语句操作共享数据的代码 
}

synchronized(任意对象)：就相当于给代码加锁了，任意对象就可以看成是一把锁
```

* 同步的好处和弊端  
  * 好处：解决了多线程的数据安全问题

  * 弊端：当线程很多时，因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会降低程序的运行效率

#### 同步方法解决数据安全问题

```java
修饰符 synchronized 返回值类型 方法名(方法参数) { 
	方法体；
}
同步方法的锁对象是 this
    
修饰符 static synchronized 返回值类型 方法名(方法参数) { 
	方法体；
}
同步静态方法的锁对象是 类名.class
```

#### 线程安全的类

- StringBuffer

  - 线程安全，可变的字符序列

  - 从版本JDK 5开始，被StringBuilder 替代。 通常应该使用StringBuilder类，因为它支持所有相同的操作，但它更快，因为它不执行同步

- Vector
  - 从Java 2平台v1.2开始，该类改进了List接口，使其成为Java Collections Framework的成员。 与新的集合实现不同， Vector被同步。 如果不需要线程安全的实现，建议使用ArrayList代替Vector

- Hashtable
  - 该类实现了一个哈希表，它将键映射到值。 任何非null对象都可以用作键或者值
  - 从Java 2平台v1.2开始，该类进行了改进，实现了Map接口，使其成为Java Collections Framework的成员。 与新的集合实现不同， Hashtable被同步。 如果不需要线程安全的实现，建议使用HashMap代替Hashtable

#### Lock锁

虽然我们可以理解同步代码块和同步方法的锁对象问题，但是我们并没有直接看到在哪里加上了锁，在哪里释放了锁，为了更清晰的表达如何加锁和释放锁，JDK5以后提供了一个新的锁对象Lock

Lock是接口不能直接实例化，这里采用它的实现类ReentrantLock来实例化

- ReentrantLock构造方法

  | 方法名          | 说明                        |
  | --------------- | --------------------------- |
  | ReentrantLock() | 创建一个ReentrantLock的实例 |

- 加锁解锁方法

  | 方法名        | 说明   |
  | ------------- | ------ |
  | void lock()   | 获得锁 |
  | void unlock() | 释放锁 |

- 代码演示

  ```java
  class SellTicket implements Runnable {
      private int tickets = 100;
      private Lock lock = new ReentrantLock();
  
      @Override
      public void run() {
          while (true) {
              try {
                  lock.lock();
                  if (tickets > 0) {
                      try {
                          Thread.sleep(100);
                      } catch (InterruptedException e) {
                          e.printStackTrace();
                      }
                      System.out.println(Thread.currentThread().getName() + "正在出售第" + tickets + "张票");
                      tickets--;
                  }
              } finally {
                  lock.unlock();
              }
          }
      }
  }
  
  public class SellTicketDemo {
      public static void main(String[] args) {
          SellTicket st = new SellTicket();
  
          Thread t1 = new Thread(st, "窗口1");
          Thread t2 = new Thread(st, "窗口2");
          Thread t3 = new Thread(st, "窗口3");
  
          t1.start();
          t2.start();
          t3.start();
      }
  }
  ```

### 生产者消费者

​	生产者消费者模式是一个十分经典的多线程协作的模式，弄懂生产者消费者问题能够让我们对多线程编程的理解更加深刻。

​	所谓生产者消费者问题，实际上主要是包含了两类线程：

​		一类是生产者线程用于生产数据

​		一类是消费者线程用于消费数据

​	为了解耦生产者和消费者的关系，通常会采用共享的数据区域，就像是一个仓库

​	生产者生产数据之后直接放置在共享数据区中，并不需要关心消费者的行为

​	消费者只需要从共享数据区中去获取数据，并不需要关心生产者的行为

![image-20201202185656570](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/image-20201202185656570.png)

- Object类的等待和唤醒方法

  | 方法名           | 说明                                                         |
  | ---------------- | ------------------------------------------------------------ |
  | void wait()      | 导致当前线程等待，直到另一个线程调用该对象的 notify()方法或 notifyAll()方法 |
  | void notify()    | 唤醒正在等待对象监视器的单个线程                             |
  | void notifyAll() | 唤醒正在等待对象监视器的所有线程                             |

## 七、网络编程

 **网络编程概述**

- 计算机网络

  是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统

- 网络编程

  在网络通信协议下，实现网络互连的不同计算机上运行的程序间可以进行数据交换

 **网络编程三要素**

- IP地址

  要想让网络中的计算机能够互相通信，必须为每台计算机指定一个标识号，通过这个标识号来指定要接收数据的计算机和识别发送的计算机，而IP地址就是这个标识号。也就是设备的标识

- 端口

  网络的通信，本质上是两个应用程序的通信。每台计算机都有很多的应用程序，那么在网络通信时，如何区分这些应用程序呢？如果说IP地址可以唯一标识网络中的设备，那么端口号就可以唯一标识设备中的应用程序了。也就是应用程序的标识

- 协议

  通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。常见的协议有UDP协议和TCP协议

**IP地址**

IP地址：是网络中设备的唯一标识

- IP地址分为两大类

  - IPv4：是给每个连接在网络上的主机分配一个32bit地址。按照TCP/IP规定，IP地址用二进制来表示，每个IP地址长32bit，也就是4个字节。例如一个采用二进制形式的IP地址是“11000000 10101000 00000001 01000010”，这么长的地址，处理起来也太费劲了。为了方便使用，IP地址经常被写成十进制的形式，中间使用符号“.”分隔不同的字节。于是，上面的IP地址可以表示为“192.168.1.66”。IP地址的这种表示法叫做“点分十进制表示法”，这显然比1和0容易记忆得多

  - IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发紧张。为了扩大地址空间，通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数，这样就解决了网络地址资源数量不够的问题

- DOS常用命令：

  - ipconfig：查看本机IP地址

  - ping IP地址：检查网络是否连通

- 特殊IP地址：
  - 127.0.0.1：是回送地址，可以代表本机地址，一般用来测试使用

**InetAddress**

InetAddress：此类表示Internet协议（IP）地址

- 相关方法

  | 方法名                                    | 说明                                                         |
  | ----------------------------------------- | ------------------------------------------------------------ |
  | static InetAddress getByName(String host) | 确定主机名称的IP地址。主机名称可以是机器名称，也可以是IP地址 |
  | String getHostName()                      | 获取此IP地址的主机名                                         |
  | String getHostAddress()                   | 返回文本显示中的IP地址字符串                                 |

- 代码演示

  ```java
  public class InetAddressDemo {
      public static void main(String[] args) throws UnknownHostException {
          InetAddress address = InetAddress.getByName("192.168.36.10");
  
          // public String getHostName()：获取此IP地址的主机名
          String name = address.getHostName();
          // public String getHostAddress()：返回文本显示中的IP地址字符串
          String ip = address.getHostAddress();
  
          System.out.println("主机名：" + name);
          System.out.println("IP地址：" + ip);
      }
  }
  ```

端口和协议

- 端口

  - 设备上应用程序的唯一标识

- 端口号

  - 用两个字节表示的整数，它的取值范围是0~65535。其中，0~1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败

- 协议

  - 计算机网络中，连接和通信的规则被称为网络通信协议

- UDP协议
  - 用户数据报协议(User Datagram Protocol)
  - UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。
  - 由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输
  - 例如视频会议通常采用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议

- TCP协议

  - 传输控制协议 (Transmission Control Protocol)

  - TCP协议是面向连接的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”

  - 三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠

    第一次握手，客户端向服务器端发出连接请求，等待服务器确认

    第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求

    第三次握手，客户端再次向服务器端发送确认信息，确认连接

  - 完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛。例如上传文件、下载文件、浏览网页等

### UDP通信程序

**UDP发送数据**

- Java中的UDP通信
  - UDP协议是一种不可靠的网络协议，它在通信的两端各建立一个Socket对象，但是这两个Socket只是发送，接收数据的对象，因此对于基于UDP协议的通信双方而言，没有所谓的客户端和服务器的概念
  - Java提供了DatagramSocket类作为基于UDP协议的Socket

- 构造方法

  | 方法名                                                      | 说明                                                 |
  | ----------------------------------------------------------- | ---------------------------------------------------- |
  | DatagramSocket()                                            | 创建数据报套接字并将其绑定到本机地址上的任何可用端口 |
  | DatagramPacket(byte[] buf,int len,InetAddress add,int port) | 创建数据包,发送长度为len的数据包到指定主机的指定端口 |

- 相关方法

  | 方法名                         | 说明                   |
  | ------------------------------ | ---------------------- |
  | void send(DatagramPacket p)    | 发送数据报包           |
  | void close()                   | 关闭数据报套接字       |
  | void receive(DatagramPacket p) | 从此套接字接受数据报包 |

- 发送数据的步骤
  - 创建发送端的Socket对象(DatagramSocket)
  - 创建数据，并把数据打包
  - 调用DatagramSocket对象的方法发送数据
  - 关闭发送端

- 代码演示

  ```java
  public class SendDemo {
      public static void main(String[] args) throws IOException {
          // 创建发送端的Socket对象(DatagramSocket)
          // DatagramSocket() 构造数据报套接字并将其绑定到本地主机上的任何可用端口
          DatagramSocket ds = new DatagramSocket();
  
          //创建数据，并把数据打包
          //DatagramPacket(byte[] buf, int length, InetAddress address, int port)
          //构造一个数据包，发送长度为 length的数据包到指定主机上的指定端口号。
          byte[] bys = "hello,udp,我来了".getBytes();
  
          DatagramPacket dp = new DatagramPacket(bys, bys.length, InetAddress.getByName("192.168.36.10"), 10086);
  
          // 调用DatagramSocket对象的方法发送数据
          // void send(DatagramPacket p) 从此套接字发送数据报包
          ds.send(dp);
  
          // 关闭发送端
          // void close() 关闭此数据报套接字
          ds.close();
      }
  }
  ```

**UDP接收数据**

- 接收数据的步骤
  - 创建接收端的Socket对象(DatagramSocket)
  - 创建一个数据包，用于接收数据
  - 调用DatagramSocket对象的方法接收数据
  - 解析数据包，并把数据在控制台显示
  - 关闭接收端

- 构造方法

  | 方法名                              | 说明                                            |
  | ----------------------------------- | ----------------------------------------------- |
  | DatagramPacket(byte[] buf, int len) | 创建一个DatagramPacket用于接收长度为len的数据包 |

- 相关方法

  | 方法名            | 说明                                     |
  | ----------------- | ---------------------------------------- |
  | byte[]  getData() | 返回数据缓冲区                           |
  | int  getLength()  | 返回要发送的数据的长度或接收的数据的长度 |

- 示例代码

  ```java
  public class ReceiveDemo {
      public static void main(String[] args) throws IOException {
          //创建接收端的Socket对象(DatagramSocket)
          DatagramSocket ds = new DatagramSocket(12345);
  
          while (true) {
              //创建一个数据包，用于接收数据
              byte[] bys = new byte[1024];
              DatagramPacket dp = new DatagramPacket(bys, bys.length);
  
              //调用DatagramSocket对象的方法接收数据
              ds.receive(dp);
  
              //解析数据包，并把数据在控制台显示
              System.out.println("数据是：" + new String(dp.getData(), 0, dp.getLength()));
          }
      }
  }
  ```

**UDP通信程序练习**

- 案例需求

  UDP发送数据：数据来自于键盘录入，直到输入的数据是886，发送数据结束

  UDP接收数据：因为接收端不知道发送端什么时候停止发送，故采用死循环接收

- 代码实现

  ```java
  /*
      UDP发送数据：
          数据来自于键盘录入，直到输入的数据是886，发送数据结束
   */
  public class SendDemo {
      public static void main(String[] args) throws IOException {
          //创建发送端的Socket对象(DatagramSocket)
          DatagramSocket ds = new DatagramSocket();
          //自己封装键盘录入数据
          BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
          String line;
          while ((line = br.readLine()) != null) {
              //输入的数据是886，发送数据结束
              if ("886".equals(line)) {
                  break;
              }
              //创建数据，并把数据打包
              byte[] bys = line.getBytes();
              DatagramPacket dp = new DatagramPacket(bys, bys.length, InetAddress.getByName("192.168.1.66"), 12345);
  
              //调用DatagramSocket对象的方法发送数据
              ds.send(dp);
          }
          //关闭发送端
          ds.close();
      }
  }
  
  /*
      UDP接收数据：
          因为接收端不知道发送端什么时候停止发送，故采用死循环接收
   */
  public class ReceiveDemo {
      public static void main(String[] args) throws IOException {
          //创建接收端的Socket对象(DatagramSocket)
          DatagramSocket ds = new DatagramSocket(12345);
          while (true) {
              //创建一个数据包，用于接收数据
              byte[] bys = new byte[1024];
              DatagramPacket dp = new DatagramPacket(bys, bys.length);
              //调用DatagramSocket对象的方法接收数据
              ds.receive(dp);
              //解析数据包，并把数据在控制台显示
              System.out.println("数据是：" + new String(dp.getData(), 0, dp.getLength()));
          }
          //关闭接收端
  //        ds.close();
      }
  }
  ```

### TCP通信程序

**TCP发送数据**

- Java中的TCP通信

  - Java对基于TCP协议的的网络提供了良好的封装，使用Socket对象来代表两端的通信端口，并通过Socket产生IO流来进行网络通信。
  - Java为客户端提供了Socket类，为服务器端提供了ServerSocket类

- 构造方法

  | 方法名                               | 说明                                           |
  | ------------------------------------ | ---------------------------------------------- |
  | Socket(InetAddress address,int port) | 创建流套接字并将其连接到指定IP指定端口号       |
  | Socket(String host, int port)        | 创建流套接字并将其连接到指定主机上的指定端口号 |

- 相关方法

  | 方法名                         | 说明                 |
  | ------------------------------ | -------------------- |
  | InputStream  getInputStream()  | 返回此套接字的输入流 |
  | OutputStream getOutputStream() | 返回此套接字的输出流 |

- 示例代码

  ```java
  public class ClientDemo {
      public static void main(String[] args) throws IOException {
          //创建客户端的Socket对象(Socket)
          //Socket(String host, int port) 创建流套接字并将其连接到指定主机上的指定端口号
          Socket s = new Socket("192.168.1.66", 10000);
  
          //获取输出流，写数据
          //OutputStream getOutputStream() 返回此套接字的输出流
          OutputStream os = s.getOutputStream();
          os.write("hello,tcp,我来了".getBytes());
  
          //释放资源
          s.close();
      }
  }
  ```

**TCP接收数据**

- 构造方法

  | 方法名                  | 说明                             |
  | ----------------------- | -------------------------------- |
  | ServletSocket(int port) | 创建绑定到指定端口的服务器套接字 |

- 相关方法

  | 方法名          | 说明                           |
  | --------------- | ------------------------------ |
  | Socket accept() | 监听要连接到此的套接字并接受它 |

- 示例代码

  ```java
  public class ServerDemo {
      public static void main(String[] args) throws IOException {
          //创建服务器端的Socket对象(ServerSocket)
          //ServerSocket(int port) 创建绑定到指定端口的服务器套接字
          ServerSocket ss = new ServerSocket(10000);
  
          //Socket accept() 侦听要连接到此套接字并接受它
          Socket s = ss.accept();
  
          //获取输入流，读数据，并把数据显示在控制台
          InputStream is = s.getInputStream();
          byte[] bys = new byte[1024];
          int len = is.read(bys);
          String data = new String(bys,0,len);
          System.out.println("数据是：" + data);
  
          //释放资源
          s.close();
          ss.close();
      }
  }
  ```

**TCP通信程序练习**

- 案例需求

  客户端：发送数据，接受服务器反馈

  服务器：收到消息后给出反馈

- 案例分析
  - 客户端创建对象，使用输出流输出数据
  - 服务端创建对象，使用输入流接受数据
  - 服务端使用输出流给出反馈数据
  - 客户端使用输入流接受反馈数据

- 代码实现

  ```java
  public class ServerDemo {
      public static void main(String[] args) throws IOException {
          //创建服务器端的Socket对象(ServerSocket)
          ServerSocket ss = new ServerSocket(10000);
  
          //监听客户端连接，返回一个Socket对象
          Socket s = ss.accept();
  
          //获取输入流，读数据，并把数据显示在控制台
          InputStream is = s.getInputStream();
          byte[] bys = new byte[1024];
          int len = is.read(bys);
          String data = new String(bys, 0, len);
          System.out.println("服务器：" + data);
  
          //给出反馈
          OutputStream os = s.getOutputStream();
          os.write("数据已经收到".getBytes());
  
          //释放资源
  //        s.close();
          ss.close();
      }
  }
  
  public class ClientDemo {
      public static void main(String[] args) throws IOException {
          //创建客户端的Socket对象(Socket)
          Socket s = new Socket("192.168.1.66", 10000);
  
          //获取输出流，写数据
          OutputStream os = s.getOutputStream();
          os.write("hello,tcp,我来了".getBytes());
  
          //接收服务器反馈
          InputStream is = s.getInputStream();
          byte[] bys = new byte[1024];
          int len = is.read(bys);
          String data = new String(bys, 0, len);
          System.out.println("客户端：" + data);
  
          //释放资源
  //        is.close();
  //        os.close();
          s.close();
      }
  }
  ```

**TCP通信程序练习**

- 案例需求

  客户端：数据来自于键盘录入, 直到输入的数据是886，发送数据结束

  服务端：接收到数据在控制台输出

- 案例分析
  - 客户端创建对象，使用键盘录入循环接受数据，接受一行发送一行，直到键盘录入886为止
  - 服务端创建对象，使用输入流按行循环接受数据，直到接受到null为止

- 代码实现

  ```java
  public class ClientDemo {
      public static void main(String[] args) throws IOException {
          //创建客户端Socket对象
          Socket s = new Socket("192.168.1.66",10000);
  
          //数据来自于键盘录入，直到输入的数据是886，发送数据结束
          BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
          //封装输出流对象
          BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(s.getOutputStream()));
          String line;
          while ((line=br.readLine())!=null) {
              if("886".equals(line)) {
                  break;
              }
  
              //获取输出流对象
              bw.write(line);
              bw.newLine();
              bw.flush();
          }
  
          //释放资源
          s.close();
      }
  }
  
  public class ServerDemo {
      public static void main(String[] args) throws IOException {
          //创建服务器Socket对象
          ServerSocket ss = new ServerSocket(10000);
  
          //监听客户端的连接，返回一个对应的Socket对象
          Socket s = ss.accept();
  
          //获取输入流
          BufferedReader br = new BufferedReader(new InputStreamReader(s.getInputStream()));
          String line;
          while ((line = br.readLine()) != null) {
              System.out.println(line);
          }
  
          //释放资源
          ss.close();
      }
  }
  ```

**TCP通信程序练习**

- 案例需求

  客户端：数据来自于键盘录入，直到输入的数据是886,发送数据结束

  服务端：接受到的数据写入文本文件中

- 案例分析
  - 客户端创建对象，使用键盘录入循环接受数据，接受一行发送一行，直到键盘录入886为止
  - 服务端创建对象，创建输出流对象指向文件，每接受一行数据后使用输出流输出到文件中，直到接受到null为止

- 代码实现

  ```java
  ublic class ClientDemo {
      public static void main(String[] args) throws IOException {
          //创建客户端Socket对象
          Socket s = new Socket("192.168.1.66",10000);
          //数据来自于键盘录入，直到输入的数据是886，发送数据结束
          BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
          //封装输出流对象
          BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(s.getOutputStream()));
          String line;
          while ((line=br.readLine())!=null) {
              if("886".equals(line)) {
                  break;
              }
              bw.write(line);
              bw.newLine();
              bw.flush();
          }
          //释放资源
          s.close();
      }
  }
  
  public class ServerDemo {
      public static void main(String[] args) throws IOException {
          //创建服务器Socket对象
          ServerSocket ss = new ServerSocket(10000);
          //监听客户端连接，返回一个对应的Socket对象
          Socket s = ss.accept();
          //接收数据
          BufferedReader br = new BufferedReader(new InputStreamReader(s.getInputStream()));
          //把数据写入文本文件
          BufferedWriter bw = new BufferedWriter(new FileWriter("myNet\\s.txt"));
  
          String line;
          while ((line=br.readLine())!=null) {
              bw.write(line);
              bw.newLine();
              bw.flush();
          }
  
          //释放资源
          bw.close();
          ss.close();
      }
  }
  ```

**TCP通信程序练习**

- 案例需求

  客户端：数据来自于文本文件

  服务器：接收到的数据写入文本文件

- 案例分析
  - 创建客户端，创建输入流对象指向文件，从文件循环读取数据，每读取一行就使用输出流给服务器输出一行
  - 创建服务端，创建输出流对象指向文件，从客户端接受数据，每接受一行就给文件中输出一行

- 代码实现

  ```java
  public class ClientDemo {
      public static void main(String[] args) throws IOException {
          //创建客户端Socket对象
          Socket s = new Socket("192.168.1.66",10000);
  
          //封装文本文件的数据
          BufferedReader br = new BufferedReader(new FileReader("myNet\\InetAddressDemo.java"));
          //封装输出流写数据
          BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(s.getOutputStream()));
  
          String line;
          while ((line=br.readLine())!=null) {
              bw.write(line);
              bw.newLine();
              bw.flush();
          }
  
          //释放资源
          br.close();
          s.close();
      }
  }
  
  public class ServerDemo {
      public static void main(String[] args) throws IOException {
          //创建服务器Socket对象
          ServerSocket ss = new ServerSocket(10000);
  
          //监听客户端连接，返回一个对应的Socket对象
          Socket s = ss.accept();
  
          //接收数据
          BufferedReader br = new BufferedReader(new InputStreamReader(s.getInputStream()));
          //把数据写入文本文件
          BufferedWriter bw = new BufferedWriter(new FileWriter("myNet\\Copy.java"));
  
          String line;
          while ((line=br.readLine())!=null) {
              bw.write(line);
              bw.newLine();
              bw.flush();
          }
  
          //释放资源
          bw.close();
          ss.close();
      }
  }
  
  ```

**TCP通信程序练习**

- 案例需求

  客户端：数据来自于文本文件，接收服务器反馈

  服务器：接收到的数据写入文本文件，给出反馈

- 案例分析
  - 创建客户端对象，创建输入流对象指向文件，每读入一行数据就给服务器输出一行数据，输出结束后使用shutdownOutput()方法告知服务端传输结束
  - 创建服务器对象，创建输出流对象指向文件，每接受一行数据就使用输出流输出到文件中，传输结束后。使用输出流给客户端反馈信息
  - 客户端接受服务端的回馈信息

- 相关方法

  | 方法名                | 说明                               |
  | --------------------- | ---------------------------------- |
  | void shutdownInput()  | 将此套接字的输入流放置在“流的末尾” |
  | void shutdownOutput() | 禁止用此套接字的输出流             |

- 代码实现

  ```java
  public class ClientDemo {
      public static void main(String[] args) throws IOException {
          //创建客户端Socket对象
          Socket s = new Socket("192.168.1.66",10000);
  
          //封装文本文件的数据
          BufferedReader br = new BufferedReader(new FileReader("myNet\\InetAddressDemo.java"));
          //封装输出流写数据
          BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(s.getOutputStream()));
  
          String line;
          while ((line=br.readLine())!=null) {
              bw.write(line);
              bw.newLine();
              bw.flush();
          }
  
          //public void shutdownOutput()
          s.shutdownOutput();
  
          //接收反馈
          BufferedReader brClient = new BufferedReader(new InputStreamReader(s.getInputStream()));
          String data = brClient.readLine(); //等待读取数据
          System.out.println("服务器的反馈：" + data);
  
          //释放资源
          br.close();
          s.close();
      }
  }
  
  public class ServerDemo {
      public static void main(String[] args) throws IOException {
          //创建服务器Socket对象
          ServerSocket ss = new ServerSocket(10000);
  
          //监听客户端连接，返回一个对应的Socket对象
          Socket s = ss.accept();
  
          //接收数据
          BufferedReader br = new BufferedReader(new InputStreamReader(s.getInputStream()));
          //把数据写入文本文件
          BufferedWriter bw = new BufferedWriter(new FileWriter("myNet\\Copy.java"));
  
          String line;
          while ((line=br.readLine())!=null) { //等待读取数据
              bw.write(line);
              bw.newLine();
              bw.flush();
          }
          //给出反馈
          BufferedWriter bwServer = new BufferedWriter(new OutputStreamWriter(s.getOutputStream()));
          bwServer.write("文件上传成功");
          bwServer.newLine();
          bwServer.flush();
  
          //释放资源
          bw.close();
          ss.close();
      }
  }
  
  ```

**TCP通信程序练习**

- 案例需求

  客户端：数据来自于文本文件，接收服务器反馈

  服务器：接收到的数据写入文本文件，给出反馈，代码用线程进行封装，为每一个客户端开启一个线程

- 案例分析
  - 创建客户端对象，创建输入流对象指向文件，每读入一行数据就给服务器输出一行数据，输出结束后使用shutdownOutput()方法告知服务端传输结束
  - 创建多线程类，在run()方法中读取客户端发送的数据，为了防止文件重名，使用计数器给文件名编号，接受结束后使用输出流给客户端发送反馈信息。
  - 创建服务端对象，每监听到一个客户端则开启一个新的线程接受数据。
  - 客户端接受服务端的回馈信息

- 代码实现

  ```java
  public class ClientDemo {
      public static void main(String[] args) throws IOException {
          //创建客户端Socket对象
          Socket s = new Socket("192.168.1.66",10000);
  
          //封装文本文件的数据
          BufferedReader br = new BufferedReader(new FileReader("myNet\\InetAddressDemo.java"));
          //封装输出流写数据
          BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(s.getOutputStream()));
  
          String line;
          while ((line=br.readLine())!=null) {
              bw.write(line);
              bw.newLine();
              bw.flush();
          }
  
          s.shutdownOutput();
  
          //接收反馈
          BufferedReader brClient = new BufferedReader(new InputStreamReader(s.getInputStream()));
          String data = brClient.readLine(); //等待读取数据
          System.out.println("服务器的反馈：" + data);
  
          //释放资源
          br.close();
          s.close();
      }
  }
  
  public class ServerThread implements Runnable {
      private Socket s;
  
      public ServerThread(Socket s) {
          this.s = s;
      }
  
      @Override
      public void run() {
          try {
              //接收数据写到文本文件
              BufferedReader br = new BufferedReader(new InputStreamReader(s.getInputStream()));
              //解决名称冲突问题
              int count = 0;
              File file = new File("myNet\\Copy["+count+"].java");
              while (file.exists()) {
                  count++;
                  file = new File("myNet\\Copy["+count+"].java");
              }
              BufferedWriter bw = new BufferedWriter(new FileWriter(file));
  
              String line;
              while ((line=br.readLine())!=null) {
                  bw.write(line);
                  bw.newLine();
                  bw.flush();
              }
  
              //给出反馈
              BufferedWriter bwServer = new BufferedWriter(new OutputStreamWriter(s.getOutputStream()));
              bwServer.write("文件上传成功");
              bwServer.newLine();
              bwServer.flush();
  
              //释放资源
              s.close();
          } catch (IOException e) {
              e.printStackTrace();
          }
      }
  }
  
  public class ServerDemo {
      public static void main(String[] args) throws IOException {
          //创建服务器Socket对象
          ServerSocket ss = new ServerSocket(10000);
  
          while (true) {
              //监听客户端连接，返回一个对应的Socket对象
              Socket s = ss.accept();
              //为每一个客户端开启一个线程
              new Thread(new ServerThread(s)).start();
          }
  
      }
  }
  ```

## 八、JDK新特征

### Lambda表达式

- 函数式编程思想概述

  函数式思想则尽量忽略面向对象的复杂语法：“强调做什么，而不是以什么形式去做”

  而我们要学习的Lambda表达式就是函数式思想的体现

- 格式：

  	(形式参数) -> {代码块}

  - 形式参数：如果有多个参数，参数之间用逗号隔开；如果没有参数，留空即可

  - ->：由英文中画线和大于符号组成，固定写法。代表指向动作

  - 代码块：是我们具体要做的事情，也就是以前我们写的方法体内容

- 组成Lambda表达式的三要素：

  - 形式参数，箭头，代码块

* Lambda表达式的使用前提
  * 有一个接口
  * 接口中有且仅有一个抽象方法

* 省略的规则
  * 参数类型可以省略。但是有多个参数的情况下，不能只省略一个
  * 如果参数有且仅有一个，那么小括号可以省略
  * 如果代码块的语句只有一条，可以省略大括号和分号，和return关键字

**Lambda表达式的注意事项**

- 使用Lambda必须要有接口，并且要求接口中有且仅有一个抽象方法

- 必须有上下文环境，才能推导出Lambda对应的接口

  - 根据局部变量的赋值得知Lambda对应的接口

    ​	Runnable r = () -> System.out.println("Lambda表达式");

  - 根据调用方法的参数得知Lambda对应的接口

    ​	new Thread(() -> System.out.println("Lambda表达式")).start();

**Lambda表达式和匿名内部类的区别**

- 所需类型不同
  - 匿名内部类：可以是接口，也可以是抽象类，还可以是具体类
  - Lambda表达式：只能是接口

- 使用限制不同

  - 如果接口中有且仅有一个抽象方法，可以使用Lambda表达式，也可以使用匿名内部类

  - 如果接口中多于一个抽象方法，只能使用匿名内部类，而不能使用Lambda表达式

- 实现原理不同
  - 匿名内部类：编译之后，产生一个单独的.class字节码文件
  - Lambda表达式：编译之后，没有一个单独的.class字节码文件。对应的字节码会在运行的时候动态生成

### 接口组成更新

- 常量

  public static final

- 抽象方法

  public abstract

- 默认方法(Java 8)

- 静态方法(Java 8)

- 私有方法(Java 9)

### 方法引用

- 方法引用的出现原因

  在使用Lambda表达式的时候，我们实际上传递进去的代码就是一种解决方案：拿参数做操作

  那么考虑一种情况：如果我们在Lambda中所指定的操作方案，已经有地方存在相同方案，那是否还有必要再写重复逻辑呢？答案肯定是没有必要

  那我们又是如何使用已经存在的方案的呢？

  这就是我们要讲解的方法引用，我们是通过方法引用来使用已经存在的方案

**方法引用符**

::  该符号为引用运算符，而它所在的表达式被称为方法引用

**推导与省略**

- 如果使用Lambda，那么根据“可推导就是可省略”的原则，无需指定参数类型，也无需指定的重载形式，它们都将被自动推导
- 如果使用方法引用，也是同样可以根据上下文进行推导
- 方法引用是Lambda的孪生兄弟

引用类方法，其实就是引用类的静态方法 

​	类名::静态方法

引用对象的实例方法，其实就引用类中的成员方法 

​	对象::成员方法

引用类的实例方法，其实就是引用类中的成员方法 

​	类名::成员方法

引用构造器，其实就是引用构造方法 

​	类名::new

**函数式接口**

* 函数式接口概述
  * 概念

    有且仅有一个抽象方法的接口

  * 如何检测一个接口是不是函数式接口

    @FunctionalInterface

    放在接口定义的上方：如果接口是函数式接口，编译通过；如果不是，编译失败

  * 注意事项

    我们自己定义函数式接口的时候，@FunctionalInterface是可选的，就算我不写这个注解，只要保证满足函数式接口定义的条件，也照样是函数式接口。但是，建议加上该注解

#### Supplier

- Supplier接口

  Supplier<T>接口也被称为生产型接口，如果我们指定了接口的泛型是什么类型，那么接口中的get方法就会生产什么类型的数据供我们使用。

- 常用方法

  只有一个无参的方法

  | 方法名  |                       说明                       |
  | ------- | :----------------------------------------------: |
  | T get() | 按照某种实现逻辑(由Lambda表达式实现)返回一个数据 |

- 代码演示

  ```java
  public class SupplierDemo {
      public static void main(String[] args) {
          String s = getString(() -> "林青霞");
          System.out.println(s);
          Integer i = getInteger(() -> 30);
          System.out.println(i);
      }
  
      //定义一个方法，返回一个整数数据
      private static Integer getInteger(Supplier<Integer> sup) {
          return sup.get();
      }
  
      //定义一个方法，返回一个字符串数据
      private static String getString(Supplier<String> sup) {
          return sup.get();
      }
  }
  ```

#### Consumer

- Consumer接口

  Consumer<T>接口也被称为消费型接口，它消费的数据的数据类型由泛型指定

- 常用方法

  Consumer<T>：包含两个方法

  | 方法名                                               | 说明                                                       |
  | ---------------------------------------------------- | ---------------------------------------------------------- |
  | void  accept(T t)                                    | 对给定的参数执行此操作                                     |
  | default Consumer<T>          andThen(Consumer after) | 返回一个组合的Consumer，依次执行此操作，然后执行 after操作 |

- 代码演示

  ```java
  public class ConsumerDemo {
      public static void main(String[] args) {
          // 操作一
          operatorString("林青霞", s -> System.out.println(s));
          // 操作二
          operatorString("林青霞", s -> System.out.println(new StringBuilder(s).reverse().toString()));
  
          System.out.println("--------");
          //传入两个操作使用andThen完成
          operatorString("林青霞", s -> System.out.println(s), s -> System.out.println(new StringBuilder(s).reverse().toString()));
      }
  
      //定义一个方法，用不同的方式消费同一个字符串数据两次
      private static void operatorString(String name, Consumer<String> con1, Consumer<String> con2) {
  //        con1.accept(name);
  //        con2.accept(name);
          con1.andThen(con2).accept(name);
      }
  
      //定义一个方法，消费一个字符串数据
      private static void operatorString(String name, Consumer<String> con) {
          con.accept(name);
      }
  }
  ```

#### Predicate

- Predicate接口

  Predicate<T>接口通常用于判断参数是否满足指定的条件

- 常用方法

  | 方法名                                    | 说明                                                         |
  | ----------------------------------------- | ------------------------------------------------------------ |
  | boolean test(T t)                         | 对给定的参数进行判断(判断逻辑由Lambda表达式实现)，返回一个布尔值 |
  | default Predicate<T> negate()             | 返回一个逻辑的否定，对应逻辑非                               |
  | default Predicate<T> and(Predicate other) | 返回一个组合判断，对应短路与                                 |
  | default Predicate<T> or(Predicate other)  | 返回一个组合判断，对应短路或                                 |

- 代码演示

  ```java
  public class PredicateDemo01 {
      public static void main(String[] args) {
          boolean b1 = checkString("hello", s -> s.length() > 8);
          System.out.println(b1);
  
          boolean b2 = checkString("helloworld",s -> s.length() > 8);
          System.out.println(b2);
  
      }
  
      //判断给定的字符串是否满足要求
      private static boolean checkString(String s, Predicate<String> pre) {
  //        return !pre.test(s);
          return pre.negate().test(s);
      }
  }
  
  public class PredicateDemo02 {
      public static void main(String[] args) {
          boolean b1 = checkString("hello", s -> s.length() > 8);
          System.out.println(b1);
          boolean b2 = checkString("helloworld", s -> s.length() > 8);
          System.out.println(b2);
  
          boolean b3 = checkString("hello", s -> s.length() > 8, s -> s.length() < 15);
          System.out.println(b3);
  
          boolean b4 = checkString("helloworld", s -> s.length() > 8, s -> s.length() < 15);
          System.out.println(b4);
      }
  
      //同一个字符串给出两个不同的判断条件，最后把这两个判断的结果做逻辑与运算的结果作为最终的结果
      private static boolean checkString(String s, Predicate<String> pre1, Predicate<String> pre2) {
          return pre1.or(pre2).test(s);
      }
  
      //判断给定的字符串是否满足要求
      private static boolean checkString(String s, Predicate<String> pre) {
          return pre.test(s);
      }
  }
  ```

#### Function

- Function接口

  Function<T,R>接口通常用于对参数进行处理，转换(处理逻辑由Lambda表达式实现)，然后返回一个新的值

- 常用方法

  | 方法名                                       | 说明                                                         |
  | -------------------------------------------- | ------------------------------------------------------------ |
  | R  apply(T t)                                | 将此函数应用于给定的参数                                     |
  | default <V> Function andThen(Function after) | 返回一个组合函数，首先将该函数应用于输入，然后将after函数应用于结果 |

- 代码演示

  ```java
  public class FunctionDemo {
      public static void main(String[] args) {
          //操作一
          convert("100", s -> Integer.parseInt(s));
          //操作二
          convert(100, i -> String.valueOf(i + 566));
          //使用andThen的方式连续执行两个操作
          convert("100", s -> Integer.parseInt(s), i -> String.valueOf(i + 566));
      }
      //定义一个方法，把一个字符串转换int类型，在控制台输出
      private static void convert(String s, Function<String, Integer> fun) {
  //        Integer i = fun.apply(s);
          int i = fun.apply(s);
          System.out.println(i);
      }
      //定义一个方法，把一个int类型的数据加上一个整数之后，转为字符串在控制台输出
      private static void convert(int i, Function<Integer, String> fun) {
          String s = fun.apply(i);
          System.out.println(s);
      }
      //定义一个方法，把一个字符串转换int类型，把int类型的数据加上一个整数之后，转为字符串在控制台输出
      private static void convert(String s, Function<String, Integer> fun1, Function<Integer, String> fun2) {
          String ss = fun1.andThen(fun2).apply(s);
          System.out.println(ss);
      }
  }
  ```

### Strem流

- #### 生成Stream流的方式

  - Collection体系集合

    使用默认方法stream()生成流， default Stream<E> stream()

  - Map体系集合

    把Map转成Set集合，间接的生成流

  - 数组

    通过Stream接口的静态方法of(T... values)生成流

- 代码演示

  ```java
  public class StreamDemo {
      public static void main(String[] args) {
          //Collection体系的集合可以使用默认方法stream()生成流
          List<String> list = new ArrayList<String>();
          Stream<String> listStream = list.stream();
  
          Set<String> set = new HashSet<String>();
          Stream<String> setStream = set.stream();
  
          //Map体系的集合间接的生成流
          Map<String,Integer> map = new HashMap<String, Integer>();
          Stream<String> keyStream = map.keySet().stream();
          Stream<Integer> valueStream = map.values().stream();
          Stream<Map.Entry<String, Integer>> entryStream = map.entrySet().stream();
  
          //数组可以通过Stream接口的静态方法of(T... values)生成流
          String[] strArray = {"hello","world","java"};
          Stream<String> strArrayStream = Stream.of(strArray);
          Stream<String> strArrayStream2 = Stream.of("hello", "world", "java");
          Stream<Integer> intStream = Stream.of(10, 20, 30);
      }
  }
  ```

#### **Stream流中间操作方法**

- 概念

  中间操作的意思是，执行完此方法之后，Stream流依然可以继续执行其他操作。

- 常见方法

  | 方法名                                          | 说明                                                       |
  | ----------------------------------------------- | ---------------------------------------------------------- |
  | Stream<T> filter(Predicate predicate)           | 用于对流中的数据进行过滤                                   |
  | Stream<T> limit(long maxSize)                   | 返回此流中的元素组成的流，截取前指定参数个数的数据         |
  | Stream<T> skip(long n)                          | 跳过指定参数个数的数据，返回由该流的剩余元素组成的流       |
  | static <T> Stream<T> concat(Stream a, Stream b) | 合并a和b两个流为一个流                                     |
  | Stream<T> distinct()                            | 返回由该流的不同元素（根据Object.equals(Object) ）组成的流 |
  | Stream<T> sorted()                              | 返回由此流的元素组成的流，根据自然顺序排序                 |
  | Stream<T> sorted(Comparator comparator)         | 返回由该流的元素组成的流，根据提供的Comparator进行排序     |
  | <R> Stream<R> map(Function mapper)              | 返回由给定函数应用于此流的元素的结果组成的流               |
  | IntStream mapToInt(ToIntFunction mapper)        | 返回一个IntStream其中包含将给定函数应用于此流的元素的结果  |

- filter代码演示

  ```java
  public class StreamDemo01 {
      public static void main(String[] args) {
          //创建一个集合，存储多个字符串元素
          ArrayList<String> list = new ArrayList<>();
  
          list.add("林青霞");
          list.add("张曼玉");
          list.add("王祖贤");
          list.add("柳岩");
          list.add("张敏");
          list.add("张无忌");
  
          //需求1：把list集合中以张开头的元素在控制台输出
          list.stream().filter(s -> s.startsWith("张")).forEach(System.out::println);
          System.out.println("--------");
          //需求2：把list集合中长度为3的元素在控制台输出
          list.stream().filter(s -> s.length() == 3).forEach(System.out::println);
          System.out.println("--------");
          //需求3：把list集合中以张开头的，长度为3的元素在控制台输出
          list.stream().filter(s -> s.startsWith("张")).filter(s -> s.length() == 3).forEach(System.out::println);
      }
  }
  ```
  
- limit&skip代码演示

  ```java
  public class StreamDemo02 {
      public static void main(String[] args) {
          //创建一个集合，存储多个字符串元素
          ArrayList<String> list = new ArrayList<>();
  
          list.add("林青霞");
          list.add("张曼玉");
          list.add("王祖贤");
          list.add("柳岩");
          list.add("张敏");
          list.add("张无忌");
  
          //需求1：取前3个数据在控制台输出
          list.stream().limit(3).forEach(System.out::println);
          System.out.println("--------");
          //需求2：跳过3个元素，把剩下的元素在控制台输出
          list.stream().skip(3).forEach(System.out::println);
          System.out.println("--------");
          //需求3：跳过2个元素，把剩下的元素中前2个在控制台输出
          list.stream().skip(2).limit(2).forEach(System.out::println);
      }
  }
  ```
  
- concat&distinct代码演示

  ```java
  public class StreamDemo03 {
      public static void main(String[] args) {
          //创建一个集合，存储多个字符串元素
          ArrayList<String> list = new ArrayList<>();
  
          list.add("林青霞");
          list.add("张曼玉");
          list.add("王祖贤");
          list.add("柳岩");
          list.add("张敏");
          list.add("张无忌");
  
          //需求1：取前4个数据组成一个流
          Stream<String> s1 = list.stream().limit(4);
          //需求2：跳过2个数据组成一个流
          Stream<String> s2 = list.stream().skip(2);
          //需求3：合并需求1和需求2得到的流，并把结果在控制台输出
  //        Stream.concat(s1,s2).forEach(System.out::println);
          //需求4：合并需求1和需求2得到的流，并把结果在控制台输出，要求字符串元素不能重复
          Stream.concat(s1,s2).distinct().forEach(System.out::println);
      }
  }
  ```
  
- sorted代码演示

  ```java
  public class StreamDemo04 {
      public static void main(String[] args) {
          //创建一个集合，存储多个字符串元素
          ArrayList<String> list = new ArrayList<>();
  
          list.add("linqingxia");
          list.add("zhangmanyu");
          list.add("wangzuxian");
          list.add("liuyan");
          list.add("zhangmin");
          list.add("zhangwuji");
  
          //需求1：按照字母顺序把数据在控制台输出
          list.stream().sorted().forEach(System.out::println);
          //需求2：按照字符串长度把数据在控制台输出
          list.stream().sorted((s1, s2) -> {
              int num = s1.length() - s2.length();
              int num2 = num == 0 ? s1.compareTo(s2) : num;
              return num2;
          }).forEach(System.out::println);
      }
  }
  ```
  
- map&mapToInt代码演示

  ```java
  public class StreamDemo05 {
      public static void main(String[] args) {
          //创建一个集合，存储多个字符串元素
          ArrayList<String> list = new ArrayList<String>();
  
          list.add("10");
          list.add("20");
          list.add("30");
          list.add("40");
          list.add("50");
  
          //需求：将集合中的字符串数据转换为整数之后在控制台输出
  //        list.stream().map(s -> Integer.parseInt(s)).forEach(System.out::println);
  //        list.stream().map(Integer::parseInt).forEach(System.out::println);
  //        list.stream().mapToInt(Integer::parseInt).forEach(System.out::println);
  
          //int sum() 返回此流中元素的总和
          int result = list.stream().mapToInt(Integer::parseInt).sum();
          System.out.println(result);
      }
  }
  ```

#### Stream流终结操作方法

- 概念

  终结操作的意思是，执行完此方法之后，Stream流将不能再执行其他操作。

- 常见方法

  | 方法名                        | 说明                     |
  | ----------------------------- | ------------------------ |
  | void forEach(Consumer action) | 对此流的每个元素执行操作 |
  | long count()                  | 返回此流中的元素数       |

- 代码演示

  ```java
  public class StreamDemo {
      public static void main(String[] args) {
          //创建一个集合，存储多个字符串元素
          ArrayList<String> list = new ArrayList<String>();
  
          list.add("林青霞");
          list.add("张曼玉");
          list.add("王祖贤");
          list.add("柳岩");
          list.add("张敏");
          list.add("张无忌");
  
          //需求1：把集合中的元素在控制台输出
  //        list.stream().forEach(System.out::println);
  
          //需求2：统计集合中有几个以张开头的元素，并把统计结果在控制台输出
          long count = list.stream().filter(s -> s.startsWith("张")).count();
          System.out.println(count);
      }
  }
  ```

#### Stream流的收集操作

- 概念

  对数据使用Stream流的方式操作完毕后，可以把流中的数据收集到集合中。

- 常用方法

  | 方法名                         | 说明               |
  | ------------------------------ | ------------------ |
  | R collect(Collector collector) | 把结果收集到集合中 |

- 工具类Collectors提供了具体的收集方式

  | 方法名                                                       | 说明                   |
  | ------------------------------------------------------------ | ---------------------- |
  | public static <T> Collector toList()                         | 把元素收集到List集合中 |
  | public static <T> Collector toSet()                          | 把元素收集到Set集合中  |
  | public static  Collector toMap(Function keyMapper,Function valueMapper) | 把元素收集到Map集合中  |

- 代码演示

  ```java
  public class CollectDemo {
      public static void main(String[] args) {
          //创建List集合对象
          List<String> list = new ArrayList<String>();
          list.add("林青霞");
          list.add("张曼玉");
          list.add("王祖贤");
          list.add("柳岩");
          //需求1：得到名字为3个字的流
          Stream<String> listStream = list.stream().filter(s -> s.length() == 3);
          //需求2：把使用Stream流操作完毕的数据收集到List集合中并遍历
          List<String> names = listStream.collect(Collectors.toList());
          for (String name : names) {
              System.out.println(name);
          }
          //创建Set集合对象
          Set<Integer> set = new HashSet<Integer>();
          set.add(10);
          set.add(20);
          set.add(30);
          set.add(33);
          set.add(35);
          //需求3：得到年龄大于25的流
          Stream<Integer> setStream = set.stream().filter(age -> age > 25);
          //需求4：把使用Stream流操作完毕的数据收集到Set集合中并遍历
          Set<Integer> ages = setStream.collect(Collectors.toSet());
          for (Integer age : ages) {
              System.out.println(age);
          }
          //定义一个字符串数组，每一个字符串数据由姓名数据和年龄数据组合而成
          String[] strArray = {"林青霞,30", "张曼玉,35", "王祖贤,33", "柳岩,25"};
          //需求5：得到字符串中年龄数据大于28的流
          Stream<String> arrayStream = Stream.of(strArray).filter(s -> Integer.parseInt(s.split(",")[1]) > 28);
          //需求6：把使用Stream流操作完毕的数据收集到Map集合中并遍历，字符串中的姓名作键，年龄作值
          Map<String, Integer> map = arrayStream.collect(Collectors.toMap(s -> s.split(",")[0], s -> Integer.parseInt(s.split(",")[1])));
          Set<String> keySet = map.keySet();
          for (String key : keySet) {
              Integer value = map.get(key);
              System.out.println(key + "," + value);
          }
      }
  }
  ```

## 九、反射

### 类加载器

**类加载**

- 类加载的描述
  - 当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过类的加载，类的连接，类的初始化这三个步骤来对类进行初始化。如果不出现意外情况，JVM将会连续完成这三个步骤，所以有时也把这三个步骤统称为类加载或者类初始化
- 类的加载
  - 就是指将class文件读入内存，并为之创建一个 java.lang.Class 对象
  - 任何类被使用时，系统都会为之建立一个 java.lang.Class 对象
- 类的连接
  - 验证阶段：用于检验被加载的类是否有正确的内部结构，并和其他类协调一致
  - 准备阶段：负责为类的类变量分配内存，并设置默认初始化值
  - 解析阶段：将类的二进制数据中的符号引用替换为直接引用
- 类的初始化
  - 在该阶段，主要就是对类变量进行初始化
- 类的初始化步骤
  - 假如类还未被加载和连接，则程序先加载并连接该类
  - 假如该类的直接父类还未被初始化，则先初始化其直接父类
  - 假如类中有初始化语句，则系统依次执行这些初始化语句
  - 注意：在执行第2个步骤的时候，系统对直接父类的初始化步骤也遵循初始化步骤1-3
- 类的初始化时机
  - 创建类的实例
  - 调用类的类方法
  - 访问类或者接口的类变量，或者为该类变量赋值
  - 使用反射方式来强制创建某个类或接口对应的java.lang.Class对象
  - 初始化某个类的子类
  - 直接使用java.exe命令来运行某个主类

**类加载器**

类加载器的作用

- 负责将.class文件加载到内存中，并为之生成对应的 java.lang.Class 对象。虽然我们不用过分关心类加载机制，但是了解这个机制我们就能更好的理解程序的运行！

JVM的类加载机制

- 全盘负责：就是当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入
- 父类委托：就是当一个类加载器负责加载某个Class时，先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类
- 缓存机制：保证所有加载过的Class都会被缓存，当程序需要使用某个Class对象时，类加载器先从缓存区中搜索该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存储到缓存区

Java中的内置类加载器

- Bootstrap class loader：它是虚拟机的内置类加载器，通常表示为null ，并且没有父null
- Platform class loader：平台类加载器可以看到所有平台类 ，平台类包括由平台类加载器或其祖先定义的Java SE平台API，其实现类和JDK特定的运行时类
- System class loader：它也被称为应用程序类加载器 ，与平台类加载器不同。 系统类加载器通常用于定义应用程序类路径，模块路径和JDK特定工具上的类
- 类加载器的继承关系：System的父加载器为Platform，而Platform的父加载器为Bootstrap

ClassLoader 中的两个方法

- 方法分类

  | 方法名                                    | 说明                       |
  | ----------------------------------------- | -------------------------- |
  | static ClassLoader getSystemClassLoader() | 返回用于委派的系统类加载器 |
  | ClassLoader getParent()                   | 返回父类加载器进行委派     |


### 反射

**反射的概述**

- 是指在运行时去获取一个类的变量和方法信息。然后通过获取到的信息来创建对象，调用方法的一种机制。由于这种动态性，可以极大的增强程序的灵活性，程序不用在编译期就完成确定，在运行期仍然可以扩展

获取Class类对象的三种方式

- 类名.class属性
- 对象名.getClass()方法
- Class.forName(全类名)方法

#### 反射获取构造方法并使用

Class类获取构造方法对象的方法

- 方法分类

  | 方法名                                                       | 说明                           |
  | ------------------------------------------------------------ | ------------------------------ |
  | Constructor<?>[] getConstructors()                           | 返回所有公共构造方法对象的数组 |
  | Constructor<?>[] getDeclaredConstructors()                   | 返回所有构造方法对象的数组     |
  | Constructor<T> getConstructor(Class<?>... parameterTypes)    | 返回单个公共构造方法对象       |
  | Constructor<T> getDeclaredConstructor(Class<?>... parameterTypes) | 返回单个构造方法对象           |


Constructor类用于创建对象的方法

| 方法名                           | 说明                       |
| -------------------------------- | -------------------------- |
| T newInstance(Object...initargs) | 根据指定的构造方法创建对象 |

#### 反射获取成员变量并使用

Class类获取成员变量对象的方法

- 方法分类

  | 方法名                              | 说明                           |
  | ----------------------------------- | ------------------------------ |
  | Field[] getFields()                 | 返回所有公共成员变量对象的数组 |
  | Field[] getDeclaredFields()         | 返回所有成员变量对象的数组     |
  | Field getField(String name)         | 返回单个公共成员变量对象       |
  | Field getDeclaredField(String name) | 返回单个成员变量对象           |


Field类用于给成员变量赋值的方法

| 方法名                            | 说明                           |
| --------------------------------- | ------------------------------ |
| void set(Object obj,Object value) | 给obj对象的成员变量赋值为value |

#### 反射获取成员方法并使用

Class类获取成员方法对象的方法

- 方法分类

  | 方法名                                                       | 说明                                       |
  | ------------------------------------------------------------ | ------------------------------------------ |
  | Method[] getMethods()                                        | 返回所有公共成员方法对象的数组，包括继承的 |
  | Method[] getDeclaredMethods()                                | 返回所有成员方法对象的数组，不包括继承的   |
  | Method getMethod(String name, Class<?>... parameterTypes)    | 返回单个公共成员方法对象                   |
  | Method getDeclaredMethod(String name, Class<?>... parameterTypes) | 返回单个成员方法对象                       |


Method类用于执行方法的方法

| 方法名                                  | 说明                                                 |
| --------------------------------------- | ---------------------------------------------------- |
| Objectinvoke(Object obj,Object... args) | 调用obj对象的成员方法，参数是args,返回值是Object类型 |

## 十、加强

### 模块化

Java 9才真正成熟起来

### 注解

