JSP入门

## 一、什么是JSP

JSP全名为Java Server Pages，java服务器页面。JSP是一种基于文本的程序，其特点就是HTML和Java代码共同存在！

## 二、为什么需要JSP

JSP是为了简化Servlet的工作出现的替代品，Servlet输出HTML非常困难，JSP就是替代Servlet输出HTML的。

## 三、简单使用一下JSP

在idea下生成一个JSP，我们来看一下JSP长什么样子

```jsp
<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8" %>
<!DOCTYPE html>
<html>
<head>
</head>
<body>
</body>
</html>
```

看起来就像一个HTML页面，前面也说了：JSP的特点就是HTML和Java代码共同存在

我们向浏览器输出一句HelloWorld，至于<%%>这个东西，我先不解释！

```jsp
<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8" %>
<!DOCTYPE html>
<html>
<head>
</head>
<body>
<%
    String str = "Hello World！";
    out.println(str);
%>
</body>
</html>
```

## 四、JSP的工作原理

Tomcat访问任何的资源都是在访问Servlet！JSP也不例外！JSP本身就是一种Servlet。为什么我说JSP本身就是一种Servlet呢？其实JSP在第一次被访问的时候会被编译为HttpJspPage类（该类是HttpServlet的一个子类）

```java
/*
 * Generated by the Jasper component of Apache Tomcat
 * Version: Apache Tomcat/9.0.40
 * Generated at: 2020-12-08 05:12:34 UTC
 * Note: The last modified time of this file was set to
 *       the last modified time of the source file after
 *       generation to assist with modification tracking.
 */
package org.apache.jsp;

import javax.servlet.*;
import javax.servlet.http.*;
import javax.servlet.jsp.*;

public final class index_jsp extends org.apache.jasper.runtime.HttpJspBase
    implements org.apache.jasper.runtime.JspSourceDependent,
                 org.apache.jasper.runtime.JspSourceImports {

  private static final javax.servlet.jsp.JspFactory _jspxFactory =
          javax.servlet.jsp.JspFactory.getDefaultFactory();

  private static java.util.Map<java.lang.String,java.lang.Long> _jspx_dependants;

  private static final java.util.Set<java.lang.String> _jspx_imports_packages;

  private static final java.util.Set<java.lang.String> _jspx_imports_classes;

  static {
    _jspx_imports_packages = new java.util.HashSet<>();
    _jspx_imports_packages.add("javax.servlet");
    _jspx_imports_packages.add("javax.servlet.http");
    _jspx_imports_packages.add("javax.servlet.jsp");
    _jspx_imports_classes = null;
  }

  private volatile javax.el.ExpressionFactory _el_expressionfactory;
  private volatile org.apache.tomcat.InstanceManager _jsp_instancemanager;

  public java.util.Map<java.lang.String,java.lang.Long> getDependants() {
    return _jspx_dependants;
  }

  public java.util.Set<java.lang.String> getPackageImports() {
    return _jspx_imports_packages;
  }

  public java.util.Set<java.lang.String> getClassImports() {
    return _jspx_imports_classes;
  }

  public javax.el.ExpressionFactory _jsp_getExpressionFactory() {
    if (_el_expressionfactory == null) {
      synchronized (this) {
        if (_el_expressionfactory == null) {
          _el_expressionfactory = _jspxFactory.getJspApplicationContext(getServletConfig().getServletContext()).getExpressionFactory();
        }
      }
    }
    return _el_expressionfactory;
  }

  public org.apache.tomcat.InstanceManager _jsp_getInstanceManager() {
    if (_jsp_instancemanager == null) {
      synchronized (this) {
        if (_jsp_instancemanager == null) {
          _jsp_instancemanager = org.apache.jasper.runtime.InstanceManagerFactory.getInstanceManager(getServletConfig());
        }
      }
    }
    return _jsp_instancemanager;
  }

  public void _jspInit() {
  }

  public void _jspDestroy() {
  }

  public void _jspService(final javax.servlet.http.HttpServletRequest request, final javax.servlet.http.HttpServletResponse response)
      throws java.io.IOException, javax.servlet.ServletException {

    if (!javax.servlet.DispatcherType.ERROR.equals(request.getDispatcherType())) {
      final java.lang.String _jspx_method = request.getMethod();
      if ("OPTIONS".equals(_jspx_method)) {
        response.setHeader("Allow","GET, HEAD, POST, OPTIONS");
        return;
      }
      if (!"GET".equals(_jspx_method) && !"POST".equals(_jspx_method) && !"HEAD".equals(_jspx_method)) {
        response.setHeader("Allow","GET, HEAD, POST, OPTIONS");
        response.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, "JSP 只允许 GET、POST 或 HEAD。Jasper 还允许 OPTIONS");
        return;
      }
    }

    final javax.servlet.jsp.PageContext pageContext;
    javax.servlet.http.HttpSession session = null;
    final javax.servlet.ServletContext application;
    final javax.servlet.ServletConfig config;
    javax.servlet.jsp.JspWriter out = null;
    final java.lang.Object page = this;
    javax.servlet.jsp.JspWriter _jspx_out = null;
    javax.servlet.jsp.PageContext _jspx_page_context = null;


    try {
      response.setContentType("text/html; charset=UTF-8");
      pageContext = _jspxFactory.getPageContext(this, request, response,
      			null, true, 8192, true);
      _jspx_page_context = pageContext;
      application = pageContext.getServletContext();
      config = pageContext.getServletConfig();
      session = pageContext.getSession();
      out = pageContext.getOut();
      _jspx_out = out;

      out.write("\n");
      out.write("<!DOCTYPE html>\n");
      out.write("<html>\n");
      out.write("<head>\n");
      out.write("</head>\n");
      out.write("<body>\n");

    String str = "Hello World！";
    out.println(str);

      out.write("\n");
      out.write("</body>\n");
      out.write("</html>");
    } catch (java.lang.Throwable t) {
      if (!(t instanceof javax.servlet.jsp.SkipPageException)){
        out = _jspx_out;
        if (out != null && out.getBufferSize() != 0)
          try {
            if (response.isCommitted()) {
              out.flush();
            } else {
              out.clearBuffer();
            }
          } catch (java.io.IOException e) {}
        if (_jspx_page_context != null) _jspx_page_context.handlePageException(t);
        else throw new ServletException(t);
      }
    } finally {
      _jspxFactory.releasePageContext(_jspx_page_context);
    }
  }
}

```

编译过程是这样子的：浏览器第一次请求index.jsp时，Tomcat会将index.jsp转化成index_jsp.java这么一个类，并将该文件编译成class文件。编译完毕后再运行class文件来响应浏览器的请求。

以后访问index.jsp就不再重新编译jsp文件了，直接调用class文件来响应浏览器。当然了，如果Tomcat检测到JSP页面改动了的话，会重新编译的。

既然JSP是一个Servlet，那JSP页面中的HTML排版标签是怎么样被发送到浏览器的？我们来看下上面index_jsp.java的源码就知道了。原来就是用write()出去的罢了。说到底，JSP就是封装了Servlet的java程序罢了。

```java
out.write("\n");
out.write("<!DOCTYPE html>\n");
out.write("<html>\n");
out.write("<head>\n");
out.write("</head>\n");
out.write("<body>\n");
```

有人可能也会问：JSP页面的代码服务器是怎么执行的？再看回index_jsp.java文件，java代码就直接在类中的service()中。

```java
String str = "Hello World！";
out.println(str);
```

JSP比Servlet更方便更简单的一个重要原因就是：内置了9个对象！内置对象有：out、session、response、request、config、page、application、pageContext、exception，这几个内置对象不在这里讲。

## 五、JSP生命周期

JSP也是Servlet，运行时只有一个实例，JSP初始化和销毁时也会调用Servlet的init()和destroy()方法。另外，JSP还有自己初始化和销毁的方法 

```java
public void _jspInit() {
}
public void _jspDestroy() {
}
```

## 六、JSP的语法

JSP代码可以分为两部分：

1. 模板数据：就是HTML代码

2. 元素：JSP页面中的java代码、JSP指令、JSP标签

### 6.1 JSP脚本

JSP的脚本就是JSP页面中的java代码，也叫做scriptlet。JSP的脚本必须使用<%%>括起来，不然会被当成是模板数据的！

JSP脚本有三种方式：

* <%%>【定义局部变量，编写语句】

* <%!%>【定义类或方法，**但是没人这样用！**】

* <%=%>（也称之为**表达式输出**）【输出各种类型的变量，int、double、String、Object等】

如果过多地使用<%%>会导致代码混乱，JSP还提供了一种scriptlet标签，使用此标签和<%%>有相同的功能，只不过它更美观了一些

```jsp
<jsp:scriptlet>
    String str = "Hello World！";
    out.println(str);
</jsp:scriptlet>
```

### 6.2 JSP注释

 ```jsp
<%--这是JSP注释--%>
<%--%>
// 这是java的当行注释
//
/*这是java的多行注释*/
/**/
 ```

### 6.3JSP指令

JSP指令用来声明JSP页面的相关属性，例如编码方式、文档类型等等

JSP指令的语法：

```jsp
<%@指令 属性名="值" %>
```

### 6.4page指令

idea生成的JSP页面就有page指令了。

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
```

page指令常见属性：

* language="java" 

* extends="package.class"

* import="{package.class | package.*}, ..." 

* session="true | false" 

* buffer="none | 8kb | sizekb" 

* autoFlush="true | false" 

* isThreadSafe="true | false" 

* info="text" 

* errorPage="relative_url"

* isErrorPage="true | false"

* contentType="mimeType ;charset=characterSet " | "text/html ; charset=ISO-8859-1"

* pageEncoding="characterSet | ISO-8859-1"

* isELIgnored="true | false"
  * 一般地，在eclipse或idea这些高级开发工具上开发，我们只需要在page指令中指定contentType="text/html;charset=UTF-8"，就不会出现中文乱码问题！

  * 当然了contentType 不仅仅可以指定以text/html的方式显示，还可以使用其他的形式显示出来。在conf/web.xml文件中可以查询出

![image-20201208132603681](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/20201208132603.png)

比如，我以doc形式显示jsp的数据

```jsp
<%@ page contentType="application/msword; charset=UTF-8" pageEncoding="UTF-8" %>
<!DOCTYPE html>
<html>
<head>
</head>
<body>
1111
</body>
</html>
```

我们上网的时候，如果我们操作不当，或者服务器出错了，页面都是会出现友好提示的！这个也能通过page指令来实现跳转到友好提示页面上！

page指令errorPage=和isErrorPage这两个属性，下面我们来看一下怎么使用！

jsp出现了错误，通过page指令的errorPage属性跳转到error.jsp页面上

```jsp
<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8" errorPage="error.jsp" %>
```

error.jsp页面要通过page指令的isErrorPage属性设置页面就是错误页面

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" isErrorPage="true"%>
```

属于是服务器跳转。以上的做法是单个页面设置的，如果我会有很多错误（JSP多的情况下，错误就会多），单个设置太麻烦了！

我们可以在web.xml文件中全局设置错误页，只要发生了404错误或者空指针异常的错误都会跳转到error.jsp页面上

```xml
<error-page>
    <error-code>404</error-code>
    <location>/error.jsp</location>
</error-page>

<error-page>
    <exception-type>java.lang.NullPointerException</exception-type>
    <location>/error.jsp</location>
</error-page>
```

### 6.5include指令

在讲解request对象的时候，我们曾经使用过request.getRequestDispatcher(String url).include(request,response)来对页头和页尾面进行包含

inclue指令也是做这样的事情，我们来试验一下吧！

这是页头

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>页头</title>
</head>
<body>
我是页头
<br>
<br>
<br>
</body>
</html>
```

这是页尾

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>页尾</title>
</head>
<body>
我是页尾
</body>
</html>
```

在index.jsp中把页头和页尾包含进来

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>包含页头和页尾进来</title>
</head>
<body>
<%@include file="head.jsp" %>
<%@include file="foot.jsp" %>
</body>
</html>
```

include指令是静态包含。静态包含的意思就是：把文件的代码内容都包含进来，再编译！

jsp还提供另一种包含文件的方式：JSP行为---动态包含。jsp行为在下面会讲到！

### 6.6 taglib指令

JSP支持标签技术，要使用标签技术就先得声明标签库和标签前缀。taglib指令就是用来指明JSP页面内使用标签库技术。

## 七、 JSP行为

JSP行为（JSP Actions）是一组JSP内置的标签，只书写少量的标记代码就能够使用JSP提供丰富的功能，JSP行为是对常用的JSP功能的抽象和封装。

为什么我不把它直接称为JSP标签呢？我把这些JSP内置的标签称之为JSP行为，能够和JSTL标签区分开来。当然了，你也可以把它称之为JSP标签，你不要搞混就行了。我个人喜欢把这些JSP内置标签称之为JSP行为。

### include行为

上面已经提及到了，include指令是静态包含，include行为是动态包含。其实include行为就是封装了request.getRequestDispatcher(String url).include(request,response)

include行为语法是这个样子的

```jsp
<jsp:include page=""/>
```

我们先来使用一下把，在index.jsp页面中也将页头和页尾包含进来。

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>包含页头和页尾进来</title>
</head>
<body>
<jsp:include page="head.jsp"/>
<jsp:include page="foot.jsp"/>
</body>
```

使用jsp行为来包含文件，jsp源文件是这样子的：

![image-20201208134055751](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/20201208134055.png)

jsp行为包含文件就是先编译被包含的页面，再将页面的结果写入到包含的页面中（index.jsp)

当然了，现在有静态包含和动态包含，使用哪一个更好呢？答案是：动态包含 

动态包含可以向被包含的页面传递参数（用处不大），并且是分别处理包含页面的（将被包含页面编译后得出的结果再写进包含页面）【如果有相同名称的参数，使用静态包含就会报错！】！

模拟一下场景吧，现在我的头页面有个名为s的字符串变量

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>页头</title>
</head>
<body>
<%
    String s = "zkunm";
%>
我是页头
<br>
<br>
<br>
</body>
</html>
```

我的页尾也有个名为s的字符串变量

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>页尾</title>
</head>
<body>
<%
    String s = "zkunm";
%>
我是页尾
</body>
</html>
```

现在我使用静态包含看看会发生什么，出现异常了。

![image-20201208134321047](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/20201208134321.png)

出现异常的原因很简单，就是同一个文件中有两个相同的变量s

![image-20201208134348350](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/20201208134348.png)

使用动态包含就可以避免这种情况

### 7.1 param行为

当使用jsp:include和jsp:forward行为引入或将请求转发给其它资源时，可以使用jsp:param行为向这个资源传递参数。

### 7.2 forward行为

在讲解request对象的时候，我们使用request.getRequestDispatcher(String url).forward(request,response)进行跳转。其实forward行为就是对其封装！

我们来看一下forward的语法：

```jsp
<jsp:forward page=""/>
```

好的，我们来使用一下吧。访问index.jsp页面就跳转到head.jsp页面中

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>访问index.jsp就跳转到head.jsp</title>
</head>
<body>
<jsp:forward page="head.jsp"/>
</body>
</html>
```

如果我要传递参数，就要在forward行为嵌套param行为

在跳转到head.jsp时传入参数username值为zkunm

```jsp
<jsp:forward page="head.jsp">
    <jsp:param name="username" value="zkunm"/>
</jsp:forward>
```

在head.jsp页面中获取到传递过来的参数

```jsp
<%
	String username = request.getParameter("username");
%>
获取到的参数是：
<%= username %>
```

### 7.3 directive行为

* directive的中文意思就是指令。该行为就是替代指令[%@%*](mailto:%@%)的语法的
  * <jsp:directive.include file=""/> 相当于<%@include file="" %>
  * <jsp:directive.page/> 相当于<%@page %>
  * <jsp:directive.taglib/> 相当于<%@taglib %>

使用该指令可以让JSP页面更加美观！使用scriptlet行为jsp:scriptlet替代<%%>是同样一个道理

### 7.4 javaBean行为

* JSP还提供了操作javaBean对象的行为，在这里就不详细说明了，后面会讲到的！现在记住JSP提供了javaBean行为来操作简单类即可！
  * <jsp:useBean id=""/>
  * <jsp:setProperty name="" property=""/>
  * <jsp:getProperty name="" property=""/>

# 二、内置对象、属性范围

## 一、什么是JSP内置对象

JSP引擎在调用JSP对应的jspServlet时，会传递或创建9个与web开发相关的对象供jspServlet使用。JSP技术的设计者为便于开发人员在编写JSP页面时获得这些web对象的引用，特意定义了9个相应的变量，开发人员在JSP页面中通过这些变量就可以快速获得这9大对象的引用

细心的朋友会发现，我们没有在JSP页面上定义过out对象，却可以直接使用！其实out对象就是JSP内置对象之一。

九个内置对象：

* **pageContext**

* page

* config

* **request**

* **response**

* **session**

* **application**

* exception

* out

## 二、out对象

out对象的API

* int getBufferSize()【得到缓存大小】

* int getRemaining()【得到未使用缓存的大小】

* boolean isAutoFlush()

* void println() 

* void flush()

* void close()

* void clearBuffer()

* void clear()

out对象用于向浏览器输出数据，与之对应的是Servlet的PrintWriter对象。然而这个out对象的类型并不是PrintWriter，是JspWriter

* 我们可以简单理解为：JspWriter就是带缓存的PrintWrieter。

* out对象的原理如下：

![img](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/20201208135601.jpg)

只有向out对象中写入了内容，且满足如下任何一个条件时，out对象才去调用ServletResponse.getWriter方法，并通过该方法返回的PrintWriter对象将out对象的缓冲区中的内容真正写入到Servlet引擎提供的缓冲区中：

* 设置page指令的buffer属性关闭了out对象的缓存功能

* out对象的缓冲区已满

* 整个JSP页面结束

一般我们在JSP页面输出都是用表达式（<%=%>)，所以out对象用得并不是很多！

## 三、request

内置对象request其实就是HttpServletRequest

## 四、response

内置对象response其实就是HttpServletResponse

## 五、config

内置对象config其实就是ServletConfig

## 六、session

内置对象session其实就是HttpSession

注意：在page指令配置如下信息，session将不可使用

  <%@page session="false" %>

## 七、application

内置对象application其实就是ServletContext对象

## 八、page

内置对象page是HttpJasPage对象，其实page对象代表的就是当前JSP页面，是当前JSP编译后的Servlet类的对象。也就是说：page对象相当于普通java类的this

## 九、exception

内置对象exception是java.lang.Exception类的对象，exception封装了JSP页面抛出的异常信息。exception经常被用来处理错误页面

前面我们已经讲过了怎么设置错误页面了，下面我们就来简单使用一下exception对象吧

1.jsp页面

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" errorPage="error.jsp" %>
<html>
<head>
    <title></title>
</head>
<body>
<%
    String sss = null;
    sss.length();
%>
</body>
</html>
```

error.jsp页面

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" isErrorPage="true" %>
<html>
<head>
    <title>错误页面</title>
</head>
<body>
<jsp:scriptlet>
    out.println("程序抛出了异常：" + exception);
</jsp:scriptlet>
</body>
</html>
```

## 十、pageContext

pageContext是内置对象中最重要的一个对象，它代表着JSP页面编译后的内容（也就是JSP页面的运行环境）！

### 10.1pageContext获取8个内置对象

既然它代表了JSP页面编译后的内容，理所当然的：它封装了对其他8大内置对象的引用！，也就是说，通过pageContext可以获取到其他的8个内置对象！

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>获取八大内置对象</title>
</head>
<body>
<jsp:scriptlet>
    System.out.println(pageContext.getSession());
    System.out.println(pageContext.getRequest());
    System.out.println(pageContext.getResponse());
    System.out.println(pageContext.getException());
    System.out.println(pageContext.getPage());
    System.out.println(pageContext.getServletConfig());
    System.out.println(pageContext.getServletContext());
    System.out.println(pageContext.getOut());
</jsp:scriptlet>
</body>
</html>
```

![](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/20201208140533.png)

### 10.2pageContext作为域对象

类似于request，session，ServletContext作为域对象而言都有以下三个方法：

* setAttribute(String name,Objcet o)

* getAttribute(String name)

* removeAttribute(String name)

当然了，pageContext也不例外，pageContext也有这三个方法！

* pageContext本质上代表的是当前JSP页面编译后的内容，作为域对象而言，它就代表着当前JSP页面（也就是page）！也就是说：pageContext域对象只在page范围内有效，超出了page范围就无效了！

首先来看看在page范围内能不能使用

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>使用page域对象</title>
</head>
<body>
<jsp:scriptlet>
    pageContext.setAttribute("name", "zkunm");
</jsp:scriptlet>
<jsp:scriptlet>
    String value = (String) pageContext.getAttribute("name");
    System.out.println(value);
</jsp:scriptlet>
</body>
</html>
```

效果如下：

![](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/20201208140749.png)

我们现在来试验一下是不是超出了page范围就无效了！

在2.jsp中request域对象设置属性

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>request域对象设置属性</title>
</head>
<body>
<jsp:scriptlet>
    request.setAttribute("name","zkunm");
</jsp:scriptlet>
<%--跳转到1.jsp中--%>
<jsp:forward page="1.jsp"/>
</body>
</html>
```

企图在1.jsp中pageContext取出request存进去的属性

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>在page域对象获取属性</title>
</head>
<body>
<jsp:scriptlet>
    //企图获取request域对象存进的属性
    String value = (String) pageContext.getAttribute("name");
    System.out.println(value);
</jsp:scriptlet>
</body>
</html>
```

效果如下：

![](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/20201208141057.png)

pageContext本质上代表着编译后JSP的内容，pageContext还可以封装了访问其他域的方法！

* 上面的pageContext默认是page范围的，但pageContext对象重载了set、get、removeAttribute这三个方法
  * getAttribute(String name,int scope)
  * setAttribute(String name,Object value,int scope)
  * removeAttribute(String name,int scope)

* 多了一个设置域范围的一个参数，如果不指定默认就是page。当然了，pageContext把request、session、application、page这几个域对象封装着了静态变量供我们使用。
  * PageContext.APPLICATION_SCOPE
  * PageContext.SESSION_SCOPE
  * PageContext.REQUEST_SCOPE
  * PageContext.PAGE_SCOPE 

刚才我们没有使用重载方法的时候，使用pageContext是无法获取到request域对象设置的属性的。现在我们使用重载后的方法看一下能不能获取得到！

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>在page域对象获取request域对象的属性</title>
</head>
<body>
<jsp:scriptlet>
    //使用重载的方法获取request域对象的属性
    String value = (String) pageContext.getAttribute("name",pageContext.REQUEST_SCOPE);
    System.out.println(value);
</jsp:scriptlet>
</body>
</html>
```

效果：

![](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/20201208141447.png)

* pageContext还有这么一个方法：
  * **findAttribute(String name)**

  该方法会查找各个域的属性，从小到大开始寻找！也就是page—>request->session->application。这个是EL表达式的原理！，EL表达式后面会讲到！我们用此方法看能不能查找出request域对象的属性吧！

  ```jsp
  <%@ page contentType="text/html;charset=UTF-8" language="java" %>
  <html>
  <head>
      <title>使用findAttribute</title>
  </head>
  <body>
  <jsp:scriptlet>
      //使用findAttribute查找2.jsp中request域对象的属性
      String value = (String) pageContext.findAttribute("name");
      System.out.println(value);
  </jsp:scriptlet>
  </body>
  </html>
  ```

  效果如下：

![](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/20201208141549.png)

### 10.3引入和跳转

PageContext类中定义了一个forward方法和两个include方法来分别简化和替代RequestDispatcher.forward方法和include方法。

* **pageContext.forward(String url)**

* **pageContext.include(String url)**

## 十一、4种属性范围

到目前为止，我们已经学了4种属性范围了。

1. page【只在一个页面中保存属性，跳转页面无效】

2. requet【只在一次请求中保存属性，服务器跳转有效，浏览器跳转无效】

3. session【在一个会话范围中保存属性，无论何种跳转均有效，关闭浏览器后无效】

4. application【在整个服务器中保存，所有用户都可以使用】

4个内置对象都支持以下的方法：

1. setAttribute(String name, Object o )

2. getAttribute(String name)

3. removeAttribute(String name)

## 十二、应用场景

1. request：如果客户向服务器发请求，产生的数据，**用户看完就没用了，**像这样的数据就存在request域,像新闻数据，属于用户看完就没用的

2. session：如果客户向服务器发请求，产生的数据，**用户用完了等一会儿还有用**，像这样的数据就存在session域中，像购物数据，用户需要看到自己购物信息，并且等一会儿，还要用这个购物数据结帐

3. servletContext：如果客户向服务器发请求，产生的数据，**用户用完了，还要给其它用户用**，像这样的数据就存在servletContext域中，像聊天数据

# 三、JavaBean

## 一、什么是javaBean

JavaBean就是一个普通的java类，也称之为简单java对象--POJO（Plain Ordinary Java Object），是Java程序设计中一种设计模式，是一种基于 Java 平台的软件组件思想

JavaBean遵循着特定的写法，通常有以下的规则：

* 有无参的构造函数

* 成员属性私有化

* 封装的属性如果需要被外所操作，必须编写public类型的setter、getter方法

上面的文字看起来好像很高大上，javaBean其实非常简单，下面的代码就是按照特定写法、规则编写的一个JavaBean对象

![image-20201208142729412](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/20201208142729.png)


## 二、为什么需要使用Javabean

使用javaBean的好处就是：封装，重用,可读！

如果把bean类与数据库联合使用，一张表使用bean类，可以使你的代码更加简洁高效，易于理解，现在大多数框架都会使用这种机制。

## 三、JSP行为--JavaBean

JSP技术提供了三个关于JavaBean组件的动作元素，即JSP行为（标签），它们分别为：

* jsp:useBean【在JSP页面中查找javaBean对象或者实例化javaBean对象】

* jsp:setProperty【设置javaBean的属性】

* jsp:getProperty【获取javaBean的属性】

### 3.1jsp:useBean 

\<jsp:useBean>标签用于在指定的域范围内查找指定名称的JavaBean对象：

* 存在则直接返回该JavaBean对象的引用。

* 不存在则实例化一个新的JavaBean对象并将它以指定的名称存储到指定的域范围中。 

语法：

<jsp:useBean id="实例化对象的名称" class="类的全名" scope="保存范围"/>

如果JSP不支持\<jsp:useBean>这个行为，我们要使用Person类是这样使用的

```jsp
<%--这里需要导入Person类--%>
<%@ page import="com.zkunm.domain.Person" %>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title></title>
</head>
<body>
<jsp:scriptlet>
    Person person = new Person();
    person.setUsername("zkunm");
    System.out.println(person.getUsername());
</jsp:scriptlet>
</body>
</html>
```

我们使用\<jsp:useBean>就显得非常简洁，不用导包，不用new出对象

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title></title>
</head>
<body>
<jsp:useBean id="person" class="com.zkunm.domain.Person" scope="page"/>
<jsp:scriptlet>
    person.setUsername("zkunm");
    System.out.println(person.getUsername());
</jsp:scriptlet>
</body>
</html>
```

有人可能会想，凭什么写一个\<jsp:useBean>这样的代码就可以创建出一个对象出来。

现在我把JavaBean中无参的构造函数改成有参的，我们看看会出现什么情况，出现异常了！

```java
public Person(int age) {
	this.age = age;
}
```

![image-20201208145302222](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/20201208145302.png)

内部在new对象的时候是没有传递参数进去的！

### 3.2 jsp:setProperty

语法：

  <jsp:setProerty name="对象名称" property="属性名" param="参数名" value="值">

在语法上可分为4种模式

* <jsp:setProperty name="对象名称" property="*"/>自动匹配

* <jsp:setProperty name="对象名称" property="属性名称"/>指定属性

* <jsp:setProperty name="对象名称" property="属性名称" param="参数名称"/>指定参数【很少用】

* <jsp:setProperty name="对象名称" property="属性名称" value="内容"/>指定内容【很少用】

当我们没有学习到jsp:setProperty时，我们获取表单的信息，然后导入到javaBean对象中是这样的一种情况：

这是表单的页面代码：

```html
<form action="/1.jsp" method="post">
    用户名：<input type="text" name="username">
    年龄：<input type="text " name="age">
    <input type="submit" value="提交">
</form>
```

这是处理表单提交过来数据的jsp的代码

```jsp
<jsp:useBean id="person" class="com.zkunm.domain.Person" scope="page"/>
<jsp:scriptlet>
    int age = Integer.parseInt(request.getParameter("age"));
    person.setAge(age);
    System.out.println(person.getAge());
</jsp:scriptlet>
```

**这是可以完成的，但是相对来说，比较麻烦！**

![](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/20201208145750.png)

我们来使用\<jsp:setProperty>了来看看：

```jsp
<jsp:useBean id="person" class="com.zkunm.domain.Person" scope="page"/>
<%--指定属性名称为age--%>
<jsp:setProperty name="person" property="age"/>
<jsp:scriptlet>
    System.out.println(person.getAge());
</jsp:scriptlet>
```

也可以完成，并且**代码更少，功能更强大**！

![image-20201208145927214](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/20201208145927.png)

代码更少可以直观看出来，为什么我说它功能更加强大呢？表单提交过来的数据都是字符串，在我们没有用\<jsp:setProperty>前，我们存储设置int类型或其他非字符串类型的数据是需要强转的！但是\<jsp:setProperty>不需要我们强转，它内部自动帮我们转换了！

我们再来**使用一下自动匹配来感受它的强大之处吧**

```jsp
<jsp:useBean id="person" class="com.zkunm.domain.Person" scope="page"/>
<%--property的值设置为*就代表自动匹配--%>
<jsp:setProperty name="person" property="*"/>
<jsp:scriptlet>
    System.out.println(person.getUsername());
    System.out.println(person.getAge());
</jsp:scriptlet>
```

我们再来看一下效果：

![](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/20201208150314.png)

看到这里，有人可能会觉得好神奇：只要设置property的值就可以将表单传递过来的数据封装到JavaBean对象中了！这究竟是这样做到的？？？

JavaBean的属性名称和表单的name属性设置的名称是一模一样的！

要想能够把表单带过来的数据成功封装到JavaBean对象上，名字要一致！也就是说：JavaBean属性名要和表单的name的名称一致

至于原理，它是通过反射来做的,调用了内省的方法！，我们看编译后的JSP就明白了。

### 3.4jsp:getProperty

**语法：**

* <jsp:getProperty name="对象名" property="属性名"/>

 ```jsp
<jsp:useBean id="person" class="com.zkunm.domain.Person" scope="page"/>
<%--property的值设置为*就代表自动匹配--%>
<jsp:setProperty name="person" property="*"/>
<%--使用<jsp:getProperty>输出--%>
<jsp:getProperty name="person" property="username"/>
<jsp:getProperty name="person" property="age"/>
 ```

# 四、EL表达式

## 一、什么是EL表达式?

表达式语言（Expression Language，EL）,EL表达式是用"${}"括起来的脚本，用来更方便的读取对象！EL表达式主要用来读取数据，进行内容的显示！

## 二、为什么要使用EL表达式？

为什么要使用EL表达式，我们先来看一下没有EL表达式是怎么样读取对象数据的吧！

在1.jsp中设置了Session属性

```jsp
<%@ page language="java" contentType="text/html" pageEncoding="UTF-8"%>
<html>
<head>
    <title>向session设置一个属性</title>
</head>
<body>
<%
    //向session设置一个属性
    session.setAttribute("name", "aaa");
    System.out.println("向session设置了一个属性");
%>
</body>
</html>
```

在2.jsp中获取Session设置的属性

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title></title>
</head>
<body>
<%
    String value = (String) session.getAttribute("name");
    out.write(value);
%>
</body>
</html>
```

上面看起来，也没有多复杂呀，那我们试试EL表达式的！

在2.jsp中读取Session设置的属性

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title></title>
</head>
<body>
${name}
</body>
</html>
```

只用了简简单单的几个字母就能输出Session设置的属性了！并且输出在浏览器上！

使用EL表达式可以方便地读取对象中的属性、提交的参数、JavaBean、甚至集合！

## 三、EL表达式的作用

首先来看一下EL表达式的语法吧：

${标识符}

EL表达式如果找不到相应的对象属性，返回的的空白字符串“”，而不是null，这是EL表达式最大的特点！

## 3.1 获取各类数据

#### 3.1.1获取域对象的数据

上面在例子中，我们已经体验到了获取Session域对象的数据是多么地方便！其实EL表达式可以让我们获取各个域范围的数据

在1.jsp中设置ServeltContext属性（也就是application）

```jsp
<%
    //向ServletContext设置一个属性
    application.setAttribute("name", "aaa");
    System.out.println("向application设置了一个属性");
%>
```

在2.jsp中获取application的属性

```jsp
${name}
```

和Session一样，也能获取得到！

之前我们来讲ServletContext对象的时候讲过一个方法findAttribute(String name),EL表达式语句在执行的时候会调用该方法，用标识符作为关键字分别从page、request、session、application四个域中查找相应的对象。这也解释了为什么EL表达式可以仅仅通过标识符就能够获取到存进域对象的数据！

findAttribute()的查找顺序：从小到大，也就是page->request->session->application

#### 3.1.2获取JavaBean的属性

以前在JSP页面获取JavaBean的数据是这样子的：

1.jsp页面Session存进一个Person对象，设置age的属性为22

```jsp
<jsp:useBean id="person" class="com.zkunm.domain.Person" scope="session"/>
<jsp:setProperty name="person" property="age" value="22"/>
```

在2.jsp中取出Session的属性

```jsp
<%
    Person person = (Person) session.getAttribute("person");
    System.out.println(person.getAge());
%>
```

效果如下

![](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/20201208153529.png)

现在我使用了EL表达式读取数据又会非常方便了

```jsp
 ${person.age}
```

上面的代码 等同于调用对象的getter方法，内部是通过反射机制完成的！

#### 3.1.3获取集合的数据

集合操作在开发中被广泛地采用，在EL表达式中也很好地支持了集合的操作！可以非常方便地读取Collection和Map集合的内容

为了更好地看出EL表达式的强大之处，我们也来对比一下使用EL表达式和不使用EL表达式的区别

下面不使用EL表达式输出集合的元素，在1.jsp页面中设置session的属性，session属性的值是List集合，List集合装载的又是Person对象

```jsp
<%
    List<Person> list = new ArrayList<>();
    Person person1 = new Person();
    person1.setUsername("zkunm");
    Person person2 = new Person();
    person2.setUsername("kunm");
    list.add(person1);
    list.add(person2);
    session.setAttribute("list",list);
%>
```

在2.jsp中获取到session的属性，并输出到页面上

```jsp
<%
    List<Person> list = (List) session.getAttribute("list");
    out.write(list.get(0).getUsername()+"<br>");
    out.write(list.get(1).getUsername());
%>
```

使用EL表达式又是怎么样的效果呢？我们来看看！

```jsp
<%--取出list集合的第1个元素（下标从0开始），获取username**属性--%>
${list[0].username}
<br>
<%--取出list集合的第2个元素，获取username属性--%>
${list[1].username}
```

我们再来使用一下Map集合

在1.jsp中session属性存储了Map集合，Map集合的关键字是字符串，值是Person对象

```jsp
<%
    Map<String, Person> map = new HashMap<>();
    Person person1 = new Person();
    person1.setUsername("zkunm");
    Person person2 = new Person();
    person2.setUsername("kunm");
    map.put("aa",person1);
    map.put("bb",person2);
    session.setAttribute("map",map);
%>
```

看起来好像取出数据的时候是会有点复杂，但是有了**EL表达式也是非常轻松的**！

```jsp
${map.aa.username}
<br>
${map.bb.username}
```

如果Map集合存储的关键字是一个数字，就不能使用"."号运算符了，对于这种情况，我们可以使用"[]"的形式读取Map集合的数据

```jsp
${map["1"].username}
<br>
${map["2"].username}
```

EL表达式配合JSTL标签可以很方便的迭代集合，后面讲到JSTL标签的时候会用到!这里就不详细说明了。

## 四、EL运算符

EL表达式支持简单的运算符：加减乘除取摸，逻辑运算符。empty运算符（判断是否为null)，三目运算符

![image-20201208154624330](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/20201208154624.png)

![](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/20201208154632.png)

empty运算符可以判断对象是否为null，用作于流程控制！

三目运算符简化了if和else语句，简化代码书写

```jsp
<%
    List<Person> list = null;
%>
${list==null?"list集合为空":"list集合不为空"}
```

## 五、EL表达式11个内置对象

EL表达式主要是来对内容的显示，为了显示的方便，EL表达式提供了11个内置对象。

1. pageContext 对应于JSP页面中的pageContext对象（注意：取的是pageContext对象）

2. pageScope 代表page域中用于保存属性的Map对象

3.     requestScope 代表request域中用于保存属性的Map对象

4.     sessionScope 代表session域中用于保存属性的Map对象

5.     applicationScope 代表application域中用于保存属性的Map对象

6.     param 表示一个保存了所有请求参数的Map对象

7. paramValues表示一个保存了所有请求参数的Map对象，它对于某个请求参数，返回的是一个string[]

8.     header 表示一个保存了所有http请求头字段的Map对象

9. headerValues同上，返回string[]数组。

10.   cookie 表示一个保存了所有cookie的Map对象

11. initParam 表示一个保存了所有web应用初始化参数的map对象

下面测试各个内置对象

```jsp
<body>
<%--pageContext内置对象--%>
<jsp:scriptlet>
    pageContext.setAttribute("pageContext1", "pageContext");
</jsp:scriptlet>
pageContext内置对象：${pageContext.getAttribute("pageContext1")}
<br>
<%--pageScope内置对象--%>
<jsp:scriptlet>
    pageContext.setAttribute("pageScope1", "pageScope");
</jsp:scriptlet>
pageScope内置对象:${pageScope.pageScope1}
<br>
<%--requestScope内置对象--%>
<jsp:scriptlet>
    request.setAttribute("request1", "reqeust");
</jsp:scriptlet>
requestScope内置对象:${requestScope.request1}
<br>
<%--sessionScope内置对象--%>
<jsp:scriptlet>
    session.setAttribute("session1", "session");
</jsp:scriptlet>
sessionScope内置对象：${sessionScope.session1}
<br>
<%--applicationScope内置对象--%>
<jsp:scriptlet>
    application.setAttribute("application1", "application");
</jsp:scriptlet>
applicationScopt内置对象：${applicationScope.application1}
<br>
<%--header内置对象--%>
header内置对象：${header.Host}
<br>
<%--headerValues内置对象,取出第一个Cookie--%>
headerValues内置对象：${headerValues.Cookie[0]}
<br>
<%--Cookie内置对象--%>
<jsp:scriptlet>
    Cookie cookie = new Cookie("Cookie1", "cookie");
</jsp:scriptlet>
Cookie内置对象：${cookie.JSESSIONID.value}
<br>
<%--initParam内置对象，需要为该Context配置参数才能看出效果【jsp配置的无效！亲测】--%>
initParam内置对象:${initParam.name}
<br>
</body>
```

效果图：

![image-20201208155316725](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/20201208155316.png)

 

注意事项：

* 测试headerValues时，如果头里面有“-” ，例Accept-Encoding，则要headerValues[“Accept-Encoding”]

* 测试cookie时，例${cookie.key}取的是cookie对象，如访问cookie的名称和值，须${cookie.key.name}或${cookie.key.value}

* 测试initParam时，初始化参数要的web.xml中的配置Context的，仅仅是jsp的参数是获取不到的

* 上面已经测过了9个内置对象了，至于param和parmaValues内置对象一般都是别的页面带数据过来的（表单、地址栏）！

​        表单页面

```html
<form action="/1.jsp" method="post">
    用户名：<input type="text" name="username"><br>
    年龄：<input type="text " name="age"><br>
    爱好：
    <input type="checkbox" name="hobbies" value="football">足球
    <input type="checkbox" name="hobbies" value="basketball">篮球
    <input type="checkbox" name="hobbies" value="table tennis">兵乓球<br>
    <input type="submit" value="提交"><br>
</form>
```

处理表单页面：

```jsp
${param.username}
<br>
${param.age}
<br>
${paramValues.hobbies[0]}
<br>
${paramValues.hobbies[1]}
<br>
${paramValues.hobbies[2]}
<br>
```

使用地址栏方式提交数据给处理页面也是用param内置对象去获取数据的

## 七、EL表达式回显数据

EL表达式最大的特点就是：如果获取到的数据为null，输出空白字符串""！这个特点可以让我们数据回显

在1.jsp中模拟场景

```jsp
<%--模拟数据回显场景--%>
<%
    User user = new User();
    user.setGender("male");
    //数据回显
    request.setAttribute("user", user);
%>
<input type="radio" name="gender" value="male" ${user.gender=='male'?'checked':'' }>男
<input type="radio" name="gender" value="female" ${user.gender=='female'?'checked':'' }>女
```

## 八、EL自定义函数

EL自定义函数用于扩展EL表达式的功能，可以让EL表达式完成普通Java程序代码所能完成的功能

* 开发HTML转义的EL函数

* 我们有时候想在JSP页面中输出JSP代码，但是JSP引擎会自动把HTML代码解析，输出给浏览器。此时我们就要对HTML代码转义。

步骤：编写一个包含静态方法的类（EL表达式只能调用静态方法），该方法很常用，Tomcat都有此方法，可在\webapps\examples\WEB-INF\classes\util中找到

```java
public static String filter(String message) {
    if (message == null) return null;
    char content[] = new char[message.length()];
    message.getChars(0, message.length(), content, 0);
    StringBuilder result = new StringBuilder(content.length + 50);
    for (char c : content) {
        switch (c) {
            case '<':
                result.append("&lt;");
                break;
            case '>':
                result.append("&gt;");
                break;
            case '&':
                result.append("&amp;");
                break;
            case '"':
                result.append("&quot;");
                break;
            default:
                result.append(c);
        }
    }
    return result.toString();
}
```

在WEB/INF下创建tld（taglib description）文件，在tld文件中描述自定义函数

```xml
<?xml version="1.0" encoding="ISO-8859-1"?>
<taglib xmlns="http://java.sun.com/xml/ns/javaee"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-jsptaglibrary_2_1.xsd"
        version="2.1">
    <tlib-version>1.0</tlib-version>
    <short-name>myshortname</short-name>
    <uri>/zkunm</uri>
    <!--函数的描述-->
    <function>
        <!--函数的名字-->
        <name>filter</name>
        <!--函数位置-->
        <function-class>com.zkunm.utils.HTMLFilter</function-class>
        <!--函数的方法声明-->
        <function-signature>java.lang.String filter(java.lang.String)</function-signature>
    </function>
</taglib>
```

在JSP页面中导入和使用自定义函数，EL自定义的函数一般前缀为"fn"，uri是"/WEB-INF/tld文件名称"

```jsp
<%@ page language="java" contentType="text/html" pageEncoding="UTF-8" %>
<%@taglib prefix="fn" uri="/WEB-INF/tld.tld" %>
<html>
<head>
    <title></title>
</head>
<body>
//完成了HTML转义的功能
${fn:filter("<a href='#'>点我</a>")}
</body>
</html>
```

## 九、EL函数库（fn方法库）

由于在JSP页面中显示数据时，经常需要对显示的字符串进行处理，SUN公司针对于一些常见处理定义了一套EL函数库供开发者使用。

其实EL函数库就是fn方法库，是JSTL标签库中的一个库，也有人称之为fn标签库，但是该库长得不像是标签，所以称之为fn方法库

既然作为JSTL标签库中的一个库，要使用fn方法库就需要导入JSTL标签！要想使用JSTL标签库就要导入jstl.jar和standard.jar包！

所以，要对fn方法库做测试，首先导入开发包（jstl.jar、standard.jar)

```xml
<dependency>
    <groupId>javax.servlet</groupId>
    <artifactId>jstl</artifactId>
    <version>1.1.2</version>
</dependency>
<dependency>
    <groupId>taglibs</groupId>
    <artifactId>standard</artifactId>
    <version>1.1.2</version>
</dependency>
```

在JSP页面中指明使用标签库

```jsp
<%@taglib prefix="fn" uri="http://java.sun.com/jsp/jstl/functions" %>
```

fn方法库全都是跟字符串有关的（可以把它想成是String的方法）

* fn:toLowerCase

* fn:toUpperCase 

* fn:trim 

* fn:length

* fn:split 

* fn:join 【接收字符数组，拼接字符串】

* fn:indexOf

* fn:contains

* fn:startsWith

* fn:replace

* fn:substring

* fn:substringAfter

* fn:endsWith

* fn:escapeXml【忽略XML标记字符】

* fn:substringBefore

​        

测试代码：

```jsp
contains:${fn:contains("zkunm",zhong )}<br>
containsIgnoreCase:${fn:containsIgnoreCase("zkunm",ZHONG )}<br>
endsWith:${fn:endsWith("zkunm","eng" )}<br>
escapeXml:${fn:escapeXml("<zkunm>你是谁呀</zkunm>")}<br>
indexOf:${fn:indexOf("zkunm","n" )}<br>
length:${fn:length("zkunm")}<br>
replace:${fn:replace("zkunm","z" ,"zhong" )}<br>
split:${fn:split("zhong,kun,ming","," )}<br>
startsWith:${fn:startsWith("zkunm","z" )}<br>
substring:${fn:substring("zkunm","2" , fn:length("zkunm"))}<br>
substringAfter:${fn:substringAfter("zkunm","u" )}<br>
substringBefore:${fn:substringBefore("zkunm","u" )}<br>
toLowerCase:${fn:toLowerCase("zkunm")}<br>
toUpperCase:${fn:toUpperCase("zkunm")}<br>
trim:${fn:trim("       zhong  kunming  ")}<br>
<%--将分割成的字符数组用"."拼接成一个字符串--%>
join:${fn:join(fn:split("zhong,kun,ming","," ),"." )}<br>
```

效果：

![image-20201208163414099](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/20201208163414.png)

# 五、JSTL

## 一、什么是JSTL

JSTL全称为 JSP Standard Tag Library 即JSP标准标签库。

JSTL作为最基本的标签库，提供了一系列的JSP标签，实现了基本的功能：集合的遍历、数据的输出、字符串的处理、数据的格式化等等！

## 二、为什么要使用JSTL

EL表达式不够完美，需要JSTL的支持！在JSP中，我们前面已经用到了EL表达式，体会到了EL表达式的强大功能：使用EL表达式可以很方便地引用一些JavaBean以及其属性，不会抛出NullPointerException之类的错误！但是，EL表达式非常有限，它不能遍历集合，做逻辑的控制。这时，就需要JSTL的支持了！

Scriptlet的可读性，维护性，重用性都十分差！JSTL与HTML代码十分类似，遵循着XML标签语法，使用JSTL让JSP页面显得整洁，可读性非常好，重用性非常高，可以完成复杂的功能！

在JSP中不推荐使用scriptlet输出，推荐使用JSP标签。

## 三、使用JSTL标签库步骤：

1. 导入jstl.jar和standard.jar开发包

2. 在JSP页面中用tablib指令引入需要用到的JSTL标签

## 四、core标签库

core标签库是JSTL的核心标签库，实现了最基本的功能：流程控制、迭代输出等操作！

core标签库的前缀一般是c

### 4.1 c:out

![img](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/20201208163640.png)

**简单使用一下**

//\<c:out/>标签支持标签体，default属性上的数据可以写在标签体中

```jsp
<%
	session.setAttribute("name", "zkunm");
%>
<c:out value="${name}" escapeXml="true">您要的数据找不着</c:out>
<c:out value="${name}" default="您要的数据找不着" escapeXml="true"/>
```

我们发现上面的代码实现的效果和EL表达式是一样的，它出色的地方就多了两个属性,default和escapeXml属性。如果我们用到这两个属性，我们就使用该标签，如果没有用到这两个属性就用EL表达式就可以了。

### 4.2c:set

![img](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/20201208164230.png)

该标签有5个属性，用起来有稍微有些复杂了！现在要记住的就是：var属性操作的是Integer、Double、Float、String等类型的数据，target属性操作的是JavaBean或Map对象的数据，scope代表的是Web域，value是值，property是对象的属性！

#### 4.2.1使用var属性

既然var属性只能操作Integer、Double、String等类型，那么存在var属性就一定没有property属性（property代表的是对象的成员属性，Integer、String这些类型哪来的成员变量呀）

下面的代码流程是这样的：创建了一个name的变量，设置的值为zhongfucheng，范围是page

```jsp
<c:set var="name" value="zkunm" scope="page"/>
${name}
```

当然了，set标签也支持标签体，value的值可以写在标签体里边

```jsp
<c:set var="name" scope="page">
    zkunm
</c:set>
```

使用var属性和scope属性实现计数器

```jsp
<%--由于下面变量需要做加法运算，所以要定义出来，不然服务器是不知道我的变量是Integer类型的--%>
<%
    Integer sessionCount = 0;
    Integer applicationCount = 0;
%>
<c:set var="sessionCount" value="${sessionCount+1}" scope="session"/>
<c:set var="applicationCount" value="${applicationCount+1}" scope="application"/>
您一共访问了该页面：${applicationCount}<br/>
该页面一共被访问了：${sessionCount}
```

效果：

![](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/20201208164724.png)

 

#### 4.2.2使用target属性

使用target属性与之配对的是property属性，target属性只能操作JavaBean或Map对象，property就是对应的成员变量或key了。

既然target属性操作的是JavaBean或Map对象，那么一定是通过EL表达式来获取到对象了。taget属性如果获取不到数据会抛出异常！使用target属性就一定没有scope属性（scope属性代表的是保存范围，target的值都是获取来的，难道你还能改变人家的范围？）

```jsp
<%--创建出JavaBean对象，设置为session范围的属性--%>
<jsp:useBean id="person" class="com.zkunm.domain.Person" scope="session"/>
<%--获取到person对象，设置age属性的值为32--%>
<c:set target="${person}" property="age" value="32"/>
${person.age}
```

### 4.3c:remove

remove标签就相当简单了，只有var和scope属性，代表的是删除域范围的属性

下面简单来测试一下吧：

```jsp
<%--创建出JavaBean对象，设置为session范围的属性--%>
<jsp:useBean id="person" class="com.zkunm.domain.Person" scope="session"/>
<%--获取到person对象，设置age属性的值为32--%>
<c:set target="${person}" property="age" value="32"/>
${person.age}
<%--删除session属性--%>
<c:remove var="person" scope="session"></c:remove>
${person.age==null?"存在session的person对象被删除了！":"我还在呢！"}
```

效果：

![](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/20201208165004.png)

 

### 4.4 c:catch

**该标签主要用来处理程序中产生的异常。**

catch标签也十分简单，只有一个var属性，var属性封装了异常的信息！

```jsp
<%--创建出JavaBean对象，设置为session范围的属性--%>
<jsp:useBean id="person" class="com.zkunm.domain.Person" scope="session"/>
<c:catch var="message">
    <%--target属性只能是EL表达式，现在我是字符串，获取不到对象，肯定会抛出异常的！--%>
    <c:set target="person" property="age" value="32"/>
</c:catch>
${message}
```

效果：

![](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/20201208165108.png)

 

### 4.5c:if

![img](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/20201208165112.png)

JSTL提供了if标签完成分支语句的实现，test属性是不可或缺的。

var和scope属性我看来好像没什么用的（保存执行结果有什么用？）

根据传递过来的参数的不同显示不同的页面！

```jsp
<%--如果带过来的名字是zkunm，那么可以登陆--%>
<c:if test="${param.name=='zkunm'}">
    用户名：<input type="text" name="username"><br>
    密码：<input type="password" name="password"><br>
    <input type="submit" value="登陆">
</c:if>

<%--如果带过来的名字是z，那么就是注册--%>
<c:if test="${param.name=='z'}">
    用户名：<input type="text" name="username"><br>
    密码：<input type="password" name="password"><br>
    <input type="submit" value="注册">
</c:if>
```

![image-20201208165253136](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/20201208165253.png)

### 4.6c:choose

if标签没有else的功能，如果需要类似于java中的if else流程就需要使用choose标签。

choose标签需要联合when和otherwise标签一起使用！

```jsp
<c:choose>
    <c:when test="${param.name=='zkunm'}">
        你好啊，zkunm
    </c:when>
    <c:when test="${param.name=='z'}">
        你好啊，z
    </c:when>
    <c:otherwise>
        你是谁啊？别随便过来！
    </c:otherwise>
</c:choose>
```

### 4.7c:forEach

![img](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/20201208165422.png)

forEach为循环标签，相当于Java中的while和for

之前我们在使用EL表达式获取到集合的数据，遍历集合都是用scriptlet代码循环，现在我们学了forEach标签就可以舍弃scriptlet代码了。

```jsp
<%
    List list = new ArrayList<>();
    list.add("z");
    list.add("k");
    list.add("m");
    session.setAttribute("list", list);
%>
<%--遍历session属性中的List集合,items：即将要迭代的集合。var：当前迭代到的元素--%>
<c:forEach var="list" items="${list}" >
    ${list}<br>
</c:forEach>
```

遍历Map对象有稍微地不一样，我们来看一下，var属性保存的不是每个迭代的对象，而是Map.Entry。

```jsp
<%
    Map map = new HashMap();
    map.put("1", "z");
    map.put("2", "k");
    map.put("3", "m");
    session.setAttribute("map",map);
%>
<c:forEach var="me" items="${map}" >
    ${me.key} ${me.value}<br>
</c:forEach>
```

begin默认从0开始、end默认为集合的最后一个元素、step默认为1

* varStatus代表着当前对象被迭代的信息，它有以下的属性。

* index【返回当前是第几个对象，从0开始计数】

* count【已经遍历多少个对象了，从1开始计数】

* first【是否是第一个】

* last【是否是最后一个】

* current【当前被迭代的对象】

* begin【开始的位置】

* end【最后的位置】

* step【步长】

### 4.9c:forTokens

该标签类似于String类的split()和for循环的一种集合

它与forEach标签非常相似，都有begin、end、step、items、var、varStatus属性，不同的是forTokens标签的items属性里面是字符串，这个字符串会被delims属性的内容分割成多个字符串！

```jsp
<c:forTokens items="z,k,m,zkm" var="name" delims="," >
    ${name}
</c:forTokens>
```

### 4.10c:import

import标签类似于JSP行为jsp:include/和JSP指令<%include>

import标签的属性：

1. url【指定要包含的路径，Internet所有的url都可以】

2. context【访问同一个web容器的其他资源，以"/"开头】

3. var【保存导入的文件的内容，以String类型存储】

4. socpe【保存的范围，默认是page】

5. charEncoding【字符编码】

6. varReader【保存导入文件的内容，以Reader类型存储】

当然了，import标签功能更加更大！强大在哪里呢？import标签可以引入Internet网页上的内容

```jsp
<c:import url="https://www.baidu.com" charEncoding="UTF-8"/>
```

打印百度的源代码：

```jsp
<c:import url="https://www.baidu.com" charEncoding="UTF-8" var="bd"/>
百度的源码是：<br/>
<c:out value="${bd}" escapeXml="true"></c:out>
```

### 4.11c:param

在JSP页面进行URL的相关操作时，经常要在URL地址后面附加一些参数。c:param标签可以嵌套在c:import、c:url或c:redirect标签内，为这些标签所使用的URL地址附加参数。

c:param标签在为一个URL地址附加参数时，将自动对参数值进行URL编码，例如，如果传递的参数值为“中国”，则将其转换为“%d6%d0%b9%fa”后再附加到URL地址后面，这也就是使用c:param标签的最大好处。

### 4.12c:url

url标签十分实用！在浏览器禁用Cookie的时候，我们之前学Servlet时解决办法是：response.encodeURL()。url标签也可以实现这样的功能，再配合param标签使用，就十分实用了！

![img](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/20201208170351.png)

配合param标签来使用一下吧！

```jsp
<c:url value="2.jsp" var="url">
    <c:param name="name" value="中国！">
    </c:param>
</c:url>
<a href="${url}">我经过了URL地址重写！</a>
```

### 4.13c:redirect

redirect标签用于实现Redirect功能，当然了，此标签也能够配合param标签使用！

![img](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/20201208170540.png)

 

简单使用一下，重定向到2.jsp，带了一个参数：

```jsp
<c:redirect url="2.jsp" >
    <c:param name="name" value="zkunm">
    </c:param>
</c:redirect>
```

# 六、传统自定义标签

## 一、为什么要使用自定义标签？

JSTL标签库只提供了简单的输出等功能，没有实现任何的HTML代码封装，并且某些复杂类型转换，或者逻辑处理的时候，JSTL标签库完成不了，需要自定义标签!

## 二、编写自定义标签的步骤：

1. 编写一个实现Tag接口的Java类【标签处理器类】

2. 在WEB-INF目录下创建tld(Tag Library Descriptor)文件，在tld文件中对标签处理类（实现Tag接口的Java类）进行描述

## 三、快速入门

目标：使用标签输出客户机的IP地址！ 

按照步骤来：首先编写一个实现Tag接口的Java类

```java
public class ShowIp implements Tag {
    @Override
    public void setPageContext(PageContext pageContext) {
    }

    @Override
    public Tag getParent() {
        return null;
    }

    @Override
    public void setParent(Tag tag) {
    }

    @Override
    public int doStartTag() throws JspException {
        return 0;
    }

    @Override
    public int doEndTag() throws JspException {
        return 0;
    }

    @Override
    public void release() {
    }
}
```

既然要获取到客户机的IP地址，那么request对象是必不可少的。现在问题来了，在Tag重写的方法好像不能直接获取到request对象啊。

经过我一番仔细的观察，发现了下面这个方法：

![image-20201208171554087](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/20201208171554.png)

既然能获取到pageContext对象，那么其他8大内置对象还不是随随便便？于是乎，我就定义一个成员变量pageContext，在setPageContext()方法中传递过来的pageContext赋值给我定义的成员变量即可！

![image-20201208171655542](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/20201208171655.png)

好的，看回我们的需求：使用标签输出客户机的IP地址。在上面剩余5个方法中，最有可能就是在doStartTag()方法中编写代码！

```java
@Override
public int doStartTag() throws JspException {
    //获取到request对象
    HttpServletRequest httpServletRequest = (HttpServletRequest) context.getRequest();
    //获取到客户机的ip地址
    String ip = httpServletRequest.getRemoteAddr();
    //获取输出到浏览器的对象
    JspWriter jspWriter = context.getOut();
    //下面的异常只能捕获，因为子类的异常不能比父类多
    try {
        jspWriter.write(ip);
    } catch (IOException e) {
        e.printStackTrace();
    }
    return 0;
}
```

接着，编写tld文件，描述实现Tag接口的Java类【标签处理类】。

```xml
<?xml version="1.0" encoding="ISO-8859-1"?>
<taglib xmlns="http://java.sun.com/xml/ns/javaee"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-jsptaglibrary_2_1.xsd"
        version="2.1">
    <tlib-version>1.0</tlib-version>
    <short-name>zkunm</short-name>
    <uri>/zkunm</uri>
    <tag>
        <name>viewIp</name>
        <tag-class>com.zkunm.tag.ShowIp</tag-class>
        <body-content>empty</body-content>
    </tag>
</taglib>
```

### 3.1标签处理类详细说明

看完上面的程序，大部分人都是懵逼的。因为还不知道它具体是怎么用的，调用顺序是什么。

首先我们来看一下Tag接口的源码！

![image-20201208172316099](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/20201208172316.png)

**上面程序的执行流程：**

* JSP引擎遇到自定义标签，首先创建标签处理器类的实例对象。

* JSP引擎实例化完标签处理器类后，调用setPageContext()方法，将pageContext对象传递给标签处理器类，使得标签处理器类可以通过pageContext对象与JSP页面进行通信！

* setPageContext()方法执行完后，调用setParent()方法，将当前标签的父标签传递给当前处理器类，如果当前标签没有父标签，则传入null

* 当WEB容器执行到自定义标签的开始标记时，调用doStartTag()方法。

* 当WEB容器执行到自定义标签的结束标记时，调用doEndTag()方法。

* 一般来说，当WEB容器执行完自定义标签后，标签处理器类会驻留在内存中，直至停止WEB应用时，WEB容器才会调用release()方法

![img](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/20201208172339.png)

我们现在已经清楚了方法的执行顺序了，可Tag接口的源码还有4个变量阿，它们是用来做什么的呢？我们在编写JSP页面时，经常需要在页面中引入一些逻辑，例如：

* 控制JSP页面某一部分（标签体）是否执行

* 控制整个JSP页面是否执行

* 控制JSP页面内容重复执行

* 修改JSP页面内容输出

* 再看回4个变量的名字，我们可以发现，这4个变量就是用来做逻辑判断的！

我们来测试一下吧，在doEndTag()方法中，返回的是SKIP_PAGE变量，看下会怎么样！

![image-20201208172517378](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/20201208172517.png)

执行完标签后，后面的代码全都没有执行！

![](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/20201208172647.png)

doStartTag()方法使用的是SKIP_BODY和EVAL_BODY_INCLUDE这两个变量，判断是否执行标签体的内容。

doEndTag()方法使用的是SKIP*PAGE和EVAL*PAGE这两个变量，判断是否执行剩下页面的内容

控制JSP页面内容重复执行和修改JSP页面内容输出后面会有！

### 3.2 tld文件详细说明

![img](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/20201208172725.png)

 

![img](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/20201208172728.png)

 

首先我们来看一下tld文件当前用到的内容吧！

```xml
<tlib-version>1.0</tlib-version>
<short-name>myshortname</short-name>
<uri>http://mycompany.com</uri>

<tag>
    <name></name>
    <tag-class></tag-class>
    <body-content></body-content>
</tag>
```

我们一个一个来看：

* shortname推荐使用prefix

* uri就是引入这个标签库使用的uri

* name为标签名

* tagclass为实现类

* bodycontent为标签体的限制，它有4个值： EMPTY【不允许有标签体】，JSP【允许有JSP代码】 ，scriptless【不允许有脚本代码（也就是<%%>），允许有EL表达式，文本，JSP行为】 ， tagdepentend【标签体内的JSP代码不会被解析，直接输出文本】

## 四、TagSupport类

大部分时候我们都不需要实现Tag接口来编写自定义标签，TagSupport是Tag的一个模板类，实现了pageContext，parent的getter、setter方法以及一些其他的功能。我们要做的就是重写doStartTag()和doEndTag()方法

下面我们就来简单使用一下吧：继承TagSupport类，重写doStartTag()方法，比直接实现Tag接口简洁很多！

```jsp
public class Tag1 extends TagSupport {
    @Override
    public int doStartTag() throws JspException {
        //获取到request对象
        HttpServletRequest httpServletRequest = (HttpServletRequest) pageContext.getRequest();
        String method = httpServletRequest.getMethod();
        JspWriter jspWriter = pageContext.getOut();
        try {
            jspWriter.write(method);
        } catch (IOException e) {
            e.printStackTrace();
        }
        return 0;
    }
}
```

在tld文件中描述一把：

```xml
<tag>
    <name>showMethod</name>
    <tag-class>tag.Demo1</tag-class>
    <body-content>empty</body-content>
</tag>
```

效果：

![](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/20201208173053.png)

 

### 4.1带属性的标签

上面我们编写的自定义标签都没有附带属性的，我们在使用core标签库的时候，标签一般都带有属性。

其实JSTL标签库的原理就是自定义标签，把自定义标签搞明白了，对JSTL标签库的使用就有更好的理解了！

想要自定义标签带有属性也非常简单，只要在标签处理器类上加一个成员变量和setter、getter()，再在tld文件中描述下该属性即可！它的原理是这样的：当标签使用到属性的时候，引擎就会调用它的setter()方法

下面我想要完成的功能是：使用标签的人，传入一个字符串格式就可以显示想要的格式日期

编写标签处理器类，增加一个成员变量以及对应的setter、getter方法

```java
public class Tag2 extends TagSupport {
    //创建成员对象，对应的setter、getter方法
    private String format = null;
    @Override
    public int doStartTag() throws JspException {
        //创建日期格式化对象
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(format);
        //格式化日期并向浏览器输出
        try {
            pageContext.getOut().write(simpleDateFormat.format(new Date()));
        } catch (IOException e) {
            e.printStackTrace();
        }
        return 0;
    }
    public String getFormat() {
        return format;
    }
    public void setFormat(String format) {
        this.format = format;
    }
}
```

在tld文件中描述标签和属性，name代表的是属性的名字，required代表的是是否为必须，rtexprvalue代表能否使用EL表达式

```xml
<tag>
    <name>formatDate</name>
    <tag-class>com.zkunm.tag.Tag2</tag-class>
    <body-content>empty</body-content>
    <attribute>
        <name>format</name>
        <required>true</required>
        <rtexprvalue>true</rtexprvalue>
    </attribute>
</tag>
```

## 五、标签的继承关系

在深入讲解之前，我们先来看一下各种Tag接口、类之间的关系，这样学习下去才不会晕！

![image-20201208174104470](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/20201208174104.png)

 

### 5.1 IterationTag说明

我们已经使用过了Tag接口和TagSupport类了。接下来我们看一下IterationTag是什么玩意。

![image-20201208174139668](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/20201208174139.png)

从关系图我们也可以看出，IterationTag接口实现了Tag接口，InterationTag接口和Tag接口最主要的区别就是多了个doAfterBody()方法和EVAL_BODY_AGAIN变量

理解起来也很简单：当doAfterBody()返回的是EVAL_BODY_AGAIN变量，那么标签体的内容就一直循环！当然了，TagSupport也实现了Iteration接口，也就是说TagSupport类也能完成Iteration接口的事情！

我们来使用一下吧：

```java
public class Tag3 extends TagSupport {
    @Override
    public int doStartTag() throws JspException {
        try {
            pageContext.getOut().write("hello");
        } catch (IOException e) {
            e.printStackTrace();
        }
        //执行标签体
        return EVAL_BODY_INCLUDE;
    }

    @Override
    public int doAfterBody() throws JspException {
        //标签体不断循环，直到doAfterBody()返回的是SKIP_BODY
        return EVAL_BODY_AGAIN;
    }
}
```

tld文件中描述，既然标签体有内容，就不能用empty了！

```xml
<tag>
    <name>foreverEval</name>
    <tag-class>com.zkunm.tag.Tag3</tag-class>
    <body-content>tagdependent</body-content>
</tag>
```

doAfterBody()中只要返回的是SKPI_BODY就退出循环，执行doEndTag()方法

```java
public class Tag3 extends TagSupport {
    //定义一个变量，规定标签体循环的次数
    int x = 0;

    @Override
    public int doStartTag() throws JspException {
        try {
            pageContext.getOut().write("hello");
        } catch (IOException e) {
            e.printStackTrace();
        }
        //执行标签体
        return EVAL_BODY_INCLUDE;
    }

    @Override
    public int doAfterBody() throws JspException {
        x++;
        if (x >= 10) {
            return SKIP_BODY;
        }
        return EVAL_BODY_AGAIN;
    }
}
```

### 5.2BodyTag说明

前面我们已经使用到了带标签体的自定义标签了，前面的都是只能直接输出而得不到标签体的内容，既然得不到标签体的内容，就更别说修改标签体了！

此时，我们就需要BodyTag接口的支持了！它专门用来处理带标签体的标签，下面我们来看一下BodyTag的源码！

![image-20201208175000628](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/20201208175000.png)

BodyTag多了EVAL_BODY_BUFFERED变量【一个已经标识过时了】，多了setBodyContent和doInitBody()两个方法

其实使用BodyTag十分简单

* 如果doStartTag()方法返回的是EVAL_BODY_BUFFERED，把标签体的内容缓存起来

* 接着调用setBodyContent()方法和doInitBody()方法，封装标签体的内容到BodyContent对象中

* 接着调用doEndTag()方法

* 对于标签体的内容，我们可以通过getBodyContenet()来获取！

* 再看回上面的关系图，BodyTag实现了IterationTag和Tag接口，如果直接实现BodyTag接口做开发，要实现的方法就太多了。一般我们使用继承BodyTag的BodyTagSupport来做开发

### 5.3 BodyTagSupport说明

![image-20201208175128372](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/20201208175128.png)

可以发现:BodyTagSupport主要扩充了以下的内容:

* 把BodyContent直接定义为成员变量，在获取标签体内容的时候就不需要通过getBodyContent()获取了

* 提供获取JspWriter的方法，不需要从pageConext中获取了

以上的两个扩充都简化了我们的代码书写！

```java
protected transient BodyContent bodyContent;
public BodyContent getBodyContent() {
	return this.bodyContent;
}
```

从BodyTag接口中，我就说到了：标签体的内容封装到了BodyContent类中，那么BodyContent类究竟是什么？我们来看一下源码：

![image-20201208180129997](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/20201208180130.png)


原来BodyContent继承着JspWriter，它与JspWriter最大的区别是：BodyContent类的任何写入的内容并不自动地向页面输出！

我们一般使用BodyContent都使用两个方法：

```java
//将数据转变成Reader对象
public abstract Reader getReader();
//将数据转变成String对象
public abstract String getString();
```

再从关系图我们可以看初，BodyTagSupport继承了TagSupport类实现了BodyTag接口，可以说：BodyTagSupport有着前面讲的接口和类的所有功能！。

下面我们来使用下BodyTagSupport将标签体的内容转成是小写的：

* 标签处理器类

```java
public class Tag4 extends BodyTagSupport {
    @Override
    public int doStartTag() throws JspException {
        //想要获取到标签体的内容，就要返回EVAL_BODY_BUFFERED变量
        return EVAL_BODY_BUFFERED;
    }
    @Override
    public int doEndTag() throws JspException {
        //获取到标签体的内容
        String value = bodyContent.getString();
        //将标签体的内容转成小写并输出
        try {
            this.getPreviousOut().write(value.toLowerCase());
        } catch (IOException e) {
            e.printStackTrace();
        }
        return super.doEndTag();
    }
}
```

tld文件：

```xml
<tag>
    <name>BodyContentToLowerCase</name>
    <tag-class>com.zkunm.tag.Tag4</tag-class>
    <body-content>tagdependent</body-content>
</tag>
```

# 七、简单自定义标签

## 一、为什么要用到简单标签？

想要开发自定义标签，大多数情况下都要重写doStartTag(),doAfterBody()和doEndTag()方法，并且还要知道SKIPBODY,EVALBODY等等的变量代表着什么，在什么方法中使用。这样实在是太麻烦了！

因此，为了简化标签开发的复杂度，在JSP 2.0中定义了一个更为简单、便于编写和调用的SimpleTag接口来实现标签的功能。。

一般来说，实现了SimpeTag接口的标签称之为简单标签

## 二、SimpleTag接口

首先我们来看一下它的源码吧：

![image-20201208180852398](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/20201208180852.png)

setParent()和getParent()方法就不多说了，我们来看一下剩下的**3个方法**：

![image-20201208180922224](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/20201208180922.png)
 ![image-20201208180934296](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/20201208180934.png)

明显地：

* doTag()就是我们要写代码处理逻辑地方

* setJspContext(JspContext var1)是将PageContext对象传递给标签处理器类(PageContext是JspContext的子类)

* setJspBody(JspFragment var1)把代表标签体的JspFragment对象传递给标签处理器对象 

## 三、快速入门

一般地，我们做开发都是继承SimpleTagSupport类（该类实现了SimpleTag）来编写自定义标签

下面我们就来个快速入门吧：

目标：传入字符串格式就可以显示想要的格式日期，对比之前传统标签的，看有什么不同之处

标签处理器类：

```java
public class Tag1 extends SimpleTagSupport {
    String format = null;

    @Override
    public void doTag() throws JspException, IOException {
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(format);
        this.getJspContext().getOut().write(simpleDateFormat.format(new Date()));
    }

    public String getFormat() {
        return format;
    }

    public void setFormat(String format) {
        this.format = format;
    }
}
```

tld文件：

```xml
<tag>
    <name>formatDate</name>
    <tag-class>com.zkunm.tag.Tag1</tag-class>
    <body-content>tagdependent</body-content>
    <attribute>
        <name>format</name>
        <required>true</required>
        <rtexprvalue>true</rtexprvalue>
    </attribute>
</tag>
```

简单标签的好处就是不用去理会doStartTag、doEndTag、SKIP_BODY以及一系列的方法和属性！

简单标签一个doTag()方法走天下！

## 四、SimpleTagSupport类的执行顺序：

* ①WEB容器调用标签处理器对象的setJspContext方法，将代表JSP页面的pageContext对象传递给标签处理器对象

* ②WEB容器调用标签处理器对象的setParent方法，将父标签处理器对象传递给这个标签处理器对象。【注意，只有在标签存在父标签的情况下，WEB容器才会调用这个方法】

* ③如果调用标签时设置了属性，容器将调用每个属性对应的setter方法把属性值传递给标签处理器对象。如果标签的属性值是EL表达式或脚本表达式，则WEB容器首先计算表达式的值，然后把值传递给标签处理器对象。

* ④如果简单标签有标签体，容器将调用setJspBody方法把代表标签体的JspFragment对象传递进来

* ⑤执行标签时：容器调用标签处理器的doTag()方法，开发人员在方法体内通过操作JspFragment对象，就可以实现是否执行、迭代、修改标签体的目的。

![img](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/20201208181333.png)

## 五、深入简单标签

在我们讲解传统标签的时候，配合着SKIP_BODY、SKIP_PAGE等变量可以实现如下的功能：

1. 控制jsp页面某一部分内容(标签体)是否执行。

2. 控制整个jsp页面是否执行。

3. 控制jsp页面内容重复执行。

4. 修改jsp页面内容输出。

简单标签可没有这些变量呀，那它怎么才能实现上面那些功能呢？

在doTag方法中可以抛出javax.servlet.jsp.SkipPageException异常，用于通知WEB容器不再执行JSP页面中位于结束标记后面的内容，这等效于在传统标签的doEndTag方法中返回Tag.SKIP_PAGE常量的情况，我们来测试一下，在上面例子的代码中添加：

```java
@Override
public void doTag() throws JspException, IOException {
    SimpleDateFormat simpleDateFormat = new SimpleDateFormat(format);
    this.getJspContext().getOut().write(simpleDateFormat.format(new Date()));
    throw new SkipPageException();
}
```

效果：

![](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/20201208181702.png)

**至于其他的功能下面会讲到**！

## 六、带标签体的简单标签

SimpleTagSupport也可以带标签体，但是处理方法和传统标签完全不同。

* 传统标签是这样子的：将标签体的内容通过setBodyContent()注入到BodyContent对象中。

* 简单标签是这样子的：通过JspFragment对象实现！

我们来看一下JspFragment对象的源码吧：

![image-20201208181833675](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/20201208181833.png)

JspFragment对象十分简单，重要的只有invoke(Writer var1)方法（获取JspContext对象并不重要，在标签描述器上就可以获取到了）

public abstract void invoke(java.io.Writer out) ：

* 用于执行JspFragment对象所代表的JSP代码片段

* 参数out用于指定将JspFragment对象的执行结果写入到哪个输出流对象中，如果传递给参数out的值为null，则将执行结果写入到JspContext.getOut()方法返回的输出流对象中。(简而言之，可以理解为写给浏览器)

下面是标签处理器类的代码：

```java
public class Tag2 extends SimpleTagSupport {
    @Override
    public void doTag() throws JspException, IOException {
        //得到代表标签体的对象
        JspFragment jspFragment = getJspBody();
        //invoke方法接收的是一个Writer，如果为null，就代表着JspWriter()，将标签体的数据写给浏览器！
        jspFragment.invoke(null);
    }
}
```

既然标签体的内容是通过JspFragment对象的invoke()方法写给浏览器的，那么那么那么，我只要控制好invoke()方法，我想干什么就干什么！也就是说：

* 不调用invoke()方法，标签体内容就不会输出到浏览器上

* 重复调用invoke()方法，标签体内容就会被重复执行

* 若想在标签处理器中修改标签体内容，只需在调用invoke方法时指定一个可取出结果数据的输出流对象（例如StringWriter），让标签体的执行结果输出到该输出流对象中，然后从该输出流对象中取出数据进行修改后再输出到目标设备，即可达到修改标签体的目的

invoke()方法指定别的输出流（StringWriter），将标签体的内容写到流对象中，再通过流对象把数据取出来，达到修改的目的。

```java
@Override
public void doTag() throws JspException, IOException {
    //得到代表标签体的对象
    JspFragment jspFragment = getJspBody();
    //创建可以存储字符串的Writer对象
    StringWriter writer = new StringWriter();
    //invoke()方法把标签体的数据都写给流对象中
    jspFragment.invoke(writer);
    //把流对象的数据取出来，流对象的数据就是标签体的内容
    String value = writer.toString();
    //将数据改成是大写的，写到浏览器中
    getJspContext().getOut().write(value.toUpperCase());
}
```

传统标签能完成的功能，简单标签都可以完成，并且更为简单！

## 七、自定义标签的应用

**既然我们学了简单标签，我们就用简单标签来做开发吧！**

### 7.1防盗链

模拟下场景：1.jsp页面是海贼王资源，2.jsp页面提示非法盗链，index.jsp是我的首页。别人想要看我的海贼王资源，就必须通过我的首页点进去看，否则就是非法盗链！

**标签处理器的代码**：

```java
@Override
public void doTag() throws JspException, IOException {
    //如果想要做成更加灵活的，就把站点设置和资源设置成标签属性传递进来！
    //等会我们要获取得到request对象，需要使用到JspContext的子类PageContext
    PageContext pageContext = (PageContext) this.getJspContext();
    //获取request对象
    HttpServletRequest httpServletRequest = (HttpServletRequest) pageContext.getRequest();
    //获取到referer
    String referer = httpServletRequest.getHeader("Referer");
    //获取到response对象，等会如果是非法盗链，就重定向别的页面上
    HttpServletResponse httpServletResponse = (HttpServletResponse) pageContext.getResponse();
    //非法盗链！
    if (referer == null || !referer.startsWith("http://localhost:8080")) {
        //2.jsp提示了非法盗链！
        httpServletResponse.sendRedirect("/2.jsp");
        //不执行页面下面的内容了，保护页面
        throw new SkipPageException();
    }
}
```

1.jsp代码：

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<%@ taglib prefix="fn" uri="/WEB-INF/tld.tld" %>
<html>
<head>
    <title></title>
</head>
<body>
<fn:Referer/>
海贼王最新资源
</body>
</html>
</body>
</html>
```

index.jsp代码：

```html
<h1>这是首页！</h1>
<a href="${pageContext.request.contextPath}/1.jsp"> 海贼王最新资源</a>
```

2.jsp代码：

```jsp
<body>
    你是非法盗链的！！！！！！
</body>
```

### 7.2 if标签

在JSTL中，我们已经使用过了c:if/标签了，现在我们学习了自定义标签，可以开发类似于JSTL的if标签了！

既然是if标签，那么就需要编写带属性和带标签体的标签（需要判断是true还是false呀！，通过判断是否为真值来决定是否执行标签体的内容）

**标签处理器代码**：

```java
public class Tag2 extends SimpleTagSupport {
    //定义一个Boolean类型的变量
    boolean test;

    @Override
    public void doTag() throws JspException, IOException {
        //获取到代表标签体内容的对象
        JspFragment jspFragment = this.getJspBody();
        //如果为真值才执行标签体的内容
        if (test == true) {
            jspFragment.invoke(null);
        }
    }

    public boolean isTest() {
        return test;
    }

    public void setTest(boolean test) {
        this.test = test;
    }
}
```

tld文件的代码：

```xml
<tag>
    <name>if</name>
    <tag-class>com.zkunm.tag.Tag2</tag-class>
    <body-content>scriptless</body-content>
    <attribute>
        <name>test</name>
        <required>true</required>
        <rtexprvalue>true</rtexprvalue>
    </attribute>
</tag>
```

### 7.3forEach标签

forEach标签最基本的功能：遍历集合、数组

首先，我先写一个可以遍历List集合的标签，可能我们会这样设计：

```java
public class Tag3 extends SimpleTagSupport {
    //遍历的是List集合，于是标签的属性就为List
    private List items;
    //遍历出来的对象就用Object存着，因为我们不知道List集合保存的是什么元素
    private Object var;
    @Override
    public void doTag() throws JspException, IOException {
        //获取到迭代器
        Iterator iterator = items.iterator();
        //遍历集合
        while (iterator.hasNext()) {
            //获取到集合的元素
            var = iterator.next();
            //.....var属性代表的就是集合的元素，现在问题来了，好像在标签体内无法获取到这个对象....
            //做到这里完成不下去了....
        }
    }

    public void setItems(List items) {
        this.items = items;
    }

    public void setVar(Object var) {
        this.var = var;
    }
}
```

上面的思路是正常的，但是做不下去！我们换一个思路呗。上面的问题主要是在标签体获取不到被遍历出来的对象！

我们这样做：把var定义成String类型的，如果遍历得到对象了，就设置PageContext的属性，var为关键字，对象为值。在标签体用EL表达式搜索以var为关键字的对象！每遍历出一个对象，就执行一次标签体！

于是就有了以下的代码！

```java
public class Tag3 extends SimpleTagSupport {
    //遍历的是List集合，定义List集合成员变量
    private List items;
    //以var为关键字存储到PageContext
    private String var;
    @Override
    public void doTag() throws JspException, IOException {
        //获取到集合的迭代器
        Iterator iterator = items.iterator();
        //获取到代表标签体内容的对象
        JspFragment jspFragment = this.getJspBody();
        //遍历集合
        while (iterator.hasNext()) {
            Object o = iterator.next();
            //把遍历出来的对象存储到page范围中，关键字为标签的属性var（在标签体中使用EL表达式${var}，就能够获取到集合的对象了！）
            this.getJspContext().setAttribute(var, o);
            //每设置了一个属性，我就执行标签体
            jspFragment.invoke(null);
        }
    }

    public void setItems(List items) {
        this.items = items;
    }

    public void setVar(String var) {
        this.var = var;
    }
}
```

tld件如下：

```xml
<tag>
    <name>forEach</name>
    <tag-class>com.zkunm.tag.Tag3</tag-class>
    <body-content>scriptless</body-content>
    <attribute>
        <name>var</name>
        <rtexprvalue>true</rtexprvalue>  
        <!--字符串即可，不需要EL表达式的支持-->
        <required>false</required>
    </attribute>
    <attribute>
        <name>items</name>
        <required>true</required>
        <rtexprvalue>true</rtexprvalue>
    </attribute>
</tag>
```

上面写的仅仅能够遍历List集合，做一个通用的forEach标签麻烦的是在：不知道传进来的是什么类型的数组、什么类型集合！，需要逐一去判断

我们的实现思路就是将所有的集合或数组都转成是Collection类型的！

我们来尝试着写一下：

```java
//如果items是Collection类型的，就强转为Colletion
if (items instanceof Collection) {
    collection = (Collection) items;
}
//如果itmes是Map类型的，那么就强转为Map，再获取到<Map.Entry<K, V>，这个是Set集合的！
if (items instanceof Map) {
    Map map = (Map) items;
    collection = (Collection) map.entrySet();
}
//对象数组
if (items instanceof Object[]) {
    Object[] objects = (Object[]) items;
    collection = Arrays.asList(objects);
}
//int[],Byte[],char[]等八大基本数据类型.....
  
```

还有int[],byte[],char[]等八大基本数据类型，这八大基本数据类型就不能用Arrays.asList()把引用传进去了。因为JDK5以后会把引用自动装箱成Interger[]、Byte[]等等，而不是获取到数组的元素数据。

**对于八大基本类型数据我们就可以这样干**：

```java
if (items instanceof int[]) {
    int[] ints = (int[]) items;
    collection = new ArrayList();
    for (int anInt : ints) {
        collection.add(anInt);
    }
}
```

JSTL的forEach标签类似就是这样干的：

![](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/20201208185343.png)

由于JDK5的新特性，我们又有另外的解决方案，Class对象能够判断是否为数组类，reflect反射包下Array类：

* 其实，无论Map集合、还是任何类型的数组、都可以使用Colletion进行遍历！。

* 如果是八大基本数据类型的数组，我们就使用反射来进行构建出Collection集合。

**标签处理器的代码**：

```java
public class Tag3 extends SimpleTagSupport {
    //遍历的是未知的集合或数组，定义成Object
    private Object items;
    //每次被遍历的对象存储关键字
    private String var;
    //Colletion
    private Collection collection;
    //在WEB容器设置标签的属性的时候，判断是什么类型的数组和集合
    public void setItems(Object items) {
        this.items = items;
        //如果items是Collection类型的，就强转为Colletion
        if (items instanceof Collection) collection = (Collection) items;
        //如果itmes是Map类型的，那么就强转为Map，再获取到<Map.Entry<K, V>，这个是Set集合的！
        if (items instanceof Map) {
            Map map = (Map) items;
            collection = (Collection) map.entrySet();
        }
        //可以这样解决，Class对象判断是否是一个数组类
        if (items.getClass().isArray()) {
            //创建Collection集合添加数组的元素！
            collection = new ArrayList();
            //再利用reflect包下的Array类获取到该数组类的长度
            int len = Array.getLength(items);
            //遍历并添加到集合中
            for (int i = 0; i < len; i++) collection.add(Array.get(items, i));
        }
    }
    public void setVar(String var) {
        this.var = var;
    }
    @Override
    public void doTag() throws JspException, IOException {
        //获取到代表标签体内容的对象
        JspFragment jspFragment = this.getJspBody();
        Iterator iterator = collection.iterator();
        //遍历集合
        while (iterator.hasNext()) {
            Object o = iterator.next();
            //把遍历出来的对象存储到page范围中（在标签体中使用EL表达式${var}，就能够获取到集合的对象了！）
            this.getJspContext().setAttribute(var, o);
            jspFragment.invoke(null);
        }
    }
}
```

### 7.4 HTML转义标签

要开发这个标签就很简单了，只要获取到标签体的内容，再通过经过方法转义下标签体内容，输出给浏览器即可！

标签处理器代码：

```java
public class Tsg4 extends SimpleTagSupport {
    @Override
    public void doTag() throws JspException, IOException {
        //获取到标签体的内容再修改
        StringWriter stringWriter = new StringWriter();
        JspFragment jspFragment = this.getJspBody();
        jspFragment.invoke(stringWriter);
        String content = stringWriter.toString();
        //经过filter()转义，该方法在Tomcat可以找到
        content = filter(content);
        //再把转义后的内容输出给浏览器
        this.getJspContext().getOut().write(content);
    }

    private String filter(String message) {
        if (message == null) return (null);
        char content[] = new char[message.length()];
        message.getChars(0, message.length(), content, 0);
        StringBuffer result = new StringBuffer(content.length + 50);
        for (int i = 0; i < content.length; i++) {
            switch (content[i]) {
                case '<':
                    result.append("&lt;");
                    break;
                case '>':
                    result.append("&gt;");
                    break;
                case '&':
                    result.append("&amp;");
                    break;
                case '"':
                    result.append("&quot;");
                    break;
                default:
                    result.append(content[i]);
            }
        }
        return (result.toString());
    }
}
```

### 7.5 if else标签

在JSTL中并没有if else的标签，JSTL给予我们的是choose，when，otherwise标签，现在我们模仿choose，when，otherwise开发标签

思路：when标签有个test属性，但otherwise怎么判断标签体是执行还是不执行呢？这时就需要choose标签的支持了！choose标签默认定义一个Boolean值为false，。当when标签体被执行了，就把Boolean值变成true，只要Boolean值为false就执行otherwise标签体的内容。

choose标签处理器

```java
public class Choose extends SimpleTagSupport {
    private boolean flag;
    @Override
    public void doTag() throws JspException, IOException {
        this.getJspBody().invoke(null);
    }
    public boolean isFlag() {
        return flag;
    }
    public void setFlag(boolean flag) {
        this.flag = flag;
    }
}
```

When标签处理器

```java
public class When extends SimpleTagSupport {
    private boolean test;
    @Override
    public void doTag() throws JspException, IOException {
        Choose choose = (Choose) this.getParent();
        //如果test为true和flag为false，那么执行该标签体
        if (test == true && choose.isFlag() == false) {
            this.getJspBody().invoke(null);
            //修改父标签的flag
            choose.setFlag(true);
        }
    }
    public void setTest(boolean test) {
        this.test = test;
    }
}
```

OtherWise标签处理器

```java
public class OtherWise extends SimpleTagSupport {
    @Override
    public void doTag() throws JspException, IOException {
        Choose choose = (Choose) this.getParent();
        //如果父标签的flag为false，就执行标签体（如果when标签没执行，flag值就不会被修改！when标签没执行，就应该执行otherwise**标签！）
        if (choose.isFlag() == false) {
            getJspBody().invoke(null);
            //改父标签的flag为false
            choose.setFlag(true);
        }
    }
}
```

## 八、DynamicAttribute接口

此接口的主要功能是用于完成动态属性的设置！前面我们讲解属性标签的时候，属性都是写多少个，用多少个的。现在如果我希望属性可以动态的增加，只需要在标签处理器类中实现DynamicAttribute接口即可！

现在我要开发一个动态加法的标签：

标签处理器：

```java
public class Demo1 extends SimpleTagSupport implements DynamicAttributes {
    //既然有动态属性和动态的值，那么我们就用一个Map集合存储（1-1对应的关系），做的加法运算，值为Double类型的。
    Map<String, Double> map = new HashMap<>();
    @Override
    public void doTag() throws JspException, IOException {
        //定义一个sum变量用于计算总值
        double sum = 0.0;
        //获取到Map集合的数据
        Iterator iterator = map.entrySet().iterator();
        while (iterator.hasNext()) {
            Map.Entry<String, Double> entry = (Map.Entry<String, Double>) iterator.next();
            sum += entry.getValue();
        }
        //向浏览器输出总和是多少
        this.getJspContext().getOut().write(String.valueOf(sum));
    }
    //对于这个要实现的方法，我们只要关注第2个参数和第3个参数即可
    //第二个参数表示的是动态属性的名称，第三个参数表示的是动态属性的值
    @Override
    public void setDynamicAttribute(String s, String localName, Object value) throws JspException {
        //将动态属性的名字和值加到Map集合中
        map.put(localName, Double.valueOf(Float.valueOf(value.toString())));
    }
}
```

tld文件，注意要把dynamic-attribute设置为true

```xml
<tag>
    <name>dynamicAttribute</name>
    <tag-class>com.zkunm.tag.Demo1</tag-class>
    <body-content>empty</body-content>
    <!--**这个必须要设置为true-->
    <dynamic-attributes>true</dynamic-attributes>
</tag>
```

测试代码：

  <zhongfucheng:dynamicAttribute num="1.1" num2="2.2" num3="1"/>

效果，double在运算的时候会丢失精度的，现在只是测验下动态属性，这里就不详细说了！

![image-20201208190433822](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/20201208190433.png)

# 八、JSP面试题

 

## 一、jsp静态包含和动态包含的区别

jsp静态包含和动态包含的区别

在讲解request对象的时候，我们曾经使用过request.getRequestDispatcher(String url).include(request,response)来对页头和页尾面进行包含

inclue指令也是做这样的事情，我们来试验一下吧！

这是页头

  <%@ page contentType="text/html;charset=UTF-8" language="java"  %>
   <html>
     <head>
       <title>页头</title>
     </head>
     <body>
     我是页头
     <br>
     <br>
     <br>
     </body>
   </html>

这是页尾

  <%@ page contentType="text/html;charset=UTF-8" language="java" %>
   <html>
   <head>
     <title>页尾</title>
   </head>
   <body>
   
   我是页尾
   
   </body>
   </html>

在1.jsp中把页头和页尾包含进来


   <%@ page contentType="text/html;charset=UTF-8" language="java" %>
   <html>
   <head>
     <title>包含页头和页尾进来</title>
   </head>
   <body>
   
   
   <%@include file="head.jsp" %>
   <%@include file="foot.jsp" %>
   </body>
   </html>

访问1.jsp

![img](C:/Users/zkunm/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg)

 

include指令是静态包含。静态包含的意思就是：把文件的代码内容都包含进来，再编译！，看一下jsp的源代码就知道了！

![img](C:/Users/zkunm/AppData/Local/Temp/msohtmlclip1/01/clip_image004.jpg)

 

上面已经提及到了，include指令是静态包含，include行为是动态包含。其实include行为就是封装了request.getRequestDispatcher(String url).include(request,response)

include行为语法是这个样子的

  <jsp:include page=""/>

我们先来使用一下把，在1.jsp页面中也将页头和页尾包含进来。

  <%@ page contentType="text/html;charset=UTF-8" language="java" %>
   <html>
   <head>
     <title>包含页头和页尾进来</title>
   </head>
   <body>
     <jsp:include page="head.jsp"/>
     <jsp:include page="foot.jsp"/>
   </body>
   </html>

访问1.jsp页面看一下效果：

![img](C:/Users/zkunm/AppData/Local/Temp/msohtmlclip1/01/clip_image006.jpg)

 

使用jsp行为来包含文件，jsp源文件是这样子的：

![img](C:/Users/zkunm/AppData/Local/Temp/msohtmlclip1/01/clip_image008.jpg)

 

jsp行为包含文件就是先编译被包含的页面，再将页面的结果写入到包含的页面中（1.jsp)

当然了，现在有静态包含和动态包含，使用哪一个更好呢？答案是：动态包含。 

动态包含可以向被包含的页面传递参数（用处不大），并且是分别处理包含页面的（将被包含页面编译后得出的结果再写进包含页面）【如果有相同名称的参数，使用静态包含就会报错！】！

模拟一下场景吧，现在我的头页面有个名为s的字符串变量

  <%@ page contentType="text/html;charset=UTF-8" language="java"  %>
   <html>
     <head>
       <title>页头</title>
     </head>
     <body>
     
     <%
       String s = "zhongfucheng";
     %>
     我是页头呀
     <br>
     <br>
     <br>
     </body>
   </html>

我的页尾也有个名为s的字符串变量

  <%@ page contentType="text/html;charset=UTF-8" language="java" %>
   <html>
   <head>
     <title>页尾</title>
   </head>
   <body>
   <%
     String s = "zhongfucheng";
   %>
   
   我是页尾呀
   
   </body>
   </html>

现在我使用静态包含看看会发生什么，出现异常了。

![img](C:/Users/zkunm/AppData/Local/Temp/msohtmlclip1/01/clip_image010.jpg)

 

出现异常的原因很简单，就是同一个文件中有两个相同的变量s

![img](C:/Users/zkunm/AppData/Local/Temp/msohtmlclip1/01/clip_image012.jpg)

 

**使用动态包含就可以避免这种情况**

![img](C:/Users/zkunm/AppData/Local/Temp/msohtmlclip1/01/clip_image014.jpg)

 

![img](C:/Users/zkunm/AppData/Local/Temp/msohtmlclip1/01/clip_image016.jpg)

 

### 1.1总结

1. <%@include file="xxx.jsp"%>为jsp中的编译指令，其文件的包含是发生在jsp向servlet转换的时期，而<jsp:include page="xxx.jsp">是jsp中的动作指令，其文件的包含是发生在编译时期，也就是将java文件编译为class文件的时期 

2. 使用静态包含只会产生一个class文件，而使用动态包含会产生多个class文件 

3. 使用静态包含，包含页面和被包含页面的request对象为同一对象，因为静态包含只是将被包含的页面的内容复制到包含的页面中去；而动态包含包含页面和被包含页面不是同一个页面，被包含的页面的request对象可以取到的参数范围要相对大些，不仅可以取到传递到包含页面的参数，同样也能取得在包含页面向下传递的参数 

## 二、jsp有哪些内置对象?作用分别是什么?

jsp有哪些内置对象?作用分别是什么? 

九个内置对象：

* pageContext

* page

* config

* request

* response

* session

* application

* exception

* out

其中，request、response、session、application、config这五个对象和Servlet的API是一样的。

在JSP中，尤其重要的是pageContext对象，它代表着JSP页面编译后的内容（也就是JSP页面的运行环境）！通过pageContext可以获取到其他的8个内置对象！

pageContext作为域对象

类似于request，session，ServletContext作为域对象而言都有以下三个方法：

* setAttribute(String name,Objcet o)

* getAttribute(String name)

* removeAttribute(String name)

pageContext本质上代表的是当前JSP页面编译后的内容，作为域对象而言，它就代表着当前JSP页面（也就是page）！也就是说：pageContext域对象只在page范围内有效，超出了page范围就无效了！

pageContext对象重载了set、get、removeAttribute这三个方法

* getAttribute(String name,int scope)

* setAttribute(String name,Object value,int scope)

* removeAttribute(String name,int scope)

多了一个设置域范围的一个参数，如果不指定默认就是page。当然了，pageContext把request、session、application、page这几个域对象封装着了静态变量供我们使用。

* PageContext.APPLICATION_SCOPE

* PageContext.SESSION_SCOPE

* PageContext.REQUEST_SCOPE

* PageContext.PAGE_SCOPE 

pageContexst还有这么一个方法：

* findAttribute(String name)

该方法会查找各个域的属性，从小到大开始寻找！也就是page—>request->session->application。

out对象：

out对象用于向浏览器输出数据，与之对应的是Servlet的PrintWriter对象。然而这个out对象的类型并不是PrintWriter，是JspWriter

我们可以简单理解为：JspWriter就是带缓存的PrintWrieter。

只有向out对象中写入了内容，且满足如下任何一个条件时，out对象才去调用ServletResponse.getWriter方法，并通过该方法返回的PrintWriter对象将out对象的缓冲区中的内容真正写入到Servlet引擎提供的缓冲区中：

* 设置page指令的buffer属性关闭了out对象的缓存功能

* out对象的缓冲区已满

* 整个JSP页面结束

一般我们在JSP页面输出都是用表达式（<%=%>)，所以out对象用得并不是很多！

page对象

内置对象page是HttpJasPage对象，其实page对象代表的就是当前JSP页面，是当前JSP编译后的Servlet类的对象。也就是说：page对象相当于普通java类的this

exception对象

内置对象exception是java.lang.Exception类的对象，exception封装了JSP页面抛出的异常信息。exception经常被用来处理错误页面

### 2.1总结

1. request 用户端请求，此请求会包含来自GET/POST请求的参数

2. response 网页传回用户端的回应

3. pageContext 网页的属性是在这里管理，代表的编译后JSP内容

4. session 与请求有关的会话期

5. application servlet 正在执行的内容

6. out 用来传送回应的输出

7. config servlet的构架部件

8. page JSP网页本身

9. exception 针对错误网页，未捕捉的例外

 

## 三、jsp和servlet的区别、共同点、各自应用的范围？

jsp和servlet的区别、共同点、各自应用的范围？

1. JSP是Servlet技术的扩展，本质上就是Servlet的简易方式。JSP编译后是“类servlet”。

2. Servlet和JSP最主要的不同点在于：Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML里分离开来。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件。

3. JSP侧重于视图，Servlet主要用于控制逻辑。

## 四、属性作用域范围

属性作用域范围

1. page【只在一个页面中保存属性，跳转页面无效】

2. requet【只在一次请求中保存属性，服务器跳转有效，浏览器跳转无效】

3. session【在一个会话范围中保存属性，无论何种跳转均有效，关闭浏览器后无效】

4. application【在整个服务器中保存，所有用户都可以使用】

应用场景：

1. request：如果客户向服务器发请求，产生的数据，用户看完就没用了，像这样的数据就存在request域,像新闻数据，属于用户看完就没用的

2. session：如果客户向服务器发请求，产生的数据，用户用完了等一会儿还有用，像这样的数据就存在session域中，像购物数据，用户需要看到自己购物信息，并且等一会儿，还要用这个购物数据结帐

3. servletContext：如果客户向服务器发请求，产生的数据，用户用完了，还要给其它用户用，像这样的数据就存在servletContext域中，像聊天数据

## 五、写出5种JSTL常用标签

写出5种JSTL常用标签

<c:if>，<c:item>，<c:foreach>，<c:out>，<c:set>

## 六、写一个自定义标签要继承什么类

写一个自定义标签要继承什么类

我们可以有两种方式来实现自定义标签：

* 传统方式，实现Tag接口(老方法)

* 简单方式，继承SimpleTagSupport类

 

SimpleTagSupport类的执行顺序(原理)：

* ①WEB容器调用标签处理器对象的setJspContext方法，将代表JSP页面的pageContext对象传递给标签处理器对象

* ②WEB容器调用标签处理器对象的setParent方法，将父标签处理器对象传递给这个标签处理器对象。【注意，只有在标签存在父标签的情况下，WEB容器才会调用这个方法】

* ③如果调用标签时设置了属性，容器将调用每个属性对应的setter方法把属性值传递给标签处理器对象。如果标签的属性值是EL表达式或脚本表达式，则WEB容器首先计算表达式的值，然后把值传递给标签处理器对象。

* ④如果简单标签有标签体，容器将调用setJspBody方法把代表标签体的JspFragment对象传递进来

* ⑤执行标签时：容器调用标签处理器的doTag()方法，开发人员在方法体内通过操作JspFragment对象，就可以实现是否执行、迭代、修改标签体的目的。

![img](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/20201208190811.png)

 

 

## 七、JSP是如何被执行的？执行效率比SERVLET低吗？

JSP是如何被执行的？执行效率比SERVLET低吗？

* 当客户端向一个jsp页面发送请求时，Web Container将jsp转化成servlet的源代码（只在第一次请求时），然后编译转化后的servlet并加载到内存中执行，执行的结果response到客户端

* jsp只在第一次执行的时候会转化成servlet，以后每次执行，web容器都是直接执行编译后的servlet，所以jsp和servlet只是在第一次执行的时候不一样，jsp慢一点，以后的执行都是相同的

## 八、如何避免jsp页面自动生成session对象？为什么要这么做？

如何避免jsp页面自动生成session对象？为什么要这么做？

**可以使用页面指令显式关掉，代码如下：**

<%@ page session="false" %>

## 九、jsp的缺点？

jsp的缺点？

* 不好调试

* 与其他脚本语言的交互(可读性差)

## 十、说出Servlet和CGI的区别？

说出Servlet和CGI的区别？

* Servlet处于服务器进程中，只会有一个servlet实例，每个请求都会产生一个新的线程，而且servlet实例一般不会销毁

* CGI：来一个请求就创建一个进程，用完就销毁，效率低于servlet

 

## 十一、简述JSP的设计模式。

简述JSP的设计模式。

在Web开发模式中，有两个主要的开发结构，称为模式一（Mode I）和模式二（Mode II）

首先我们来理清一些概念吧：

* DAO(Data Access Object)：主要对数据的操作，增加、修改、删除等原子性操作。

* Web层：界面+控制器，也就是说JSP【界面】+Servlet【控制器】

* Service业务层：将多个原子性的DAO操作进行组合，组合成一个完整的业务逻辑

* 控制层：主要使用Servlet进行控制

* 数据访问层：使用DAO、Hibernate、JDBC技术实现对数据的增删改查

* JavaBean用于封装数据，处理部分核心逻辑，每一层中都用到！

模式一指的就是在开发中将显示层、控制层、数据层的操作统一交给JSP或者JavaBean来进行处理！

模式一有两种情况：

完全使用JSP做开发:

* 优点：
  * 开发速度贼快，只要写JSP就行了，JavaBean和Servlet都不用设计！
  * 小幅度修改代码方便，直接修改JSP页面交给WEB容器就行了，不像Servlet还要编译成.class文件再交给服务器！【当然了，在ide下开发这个也不算是事】

* 缺点：
  * 程序的可读性差、复用性低、代码复杂！什么jsp代码、html代码都往上面写，这肯定很难阅读，很难重用！

使用JSP+JavaBean做开发: 

* 优点：
  * 程序的可读性较高，大部分的代码都写在JavaBean上，不会和HTML代码混合在一起，可读性还行的。
  * 可重复利用高，核心的代码都由JavaBean开发了，JavaBean的设计就是用来重用、封装，大大减少编写重复代码的工作！

* 缺点：
  * 没有流程控制，程序中的JSP页面都需要检查请求的参数是否正确，异常发生时的处理。显示操作和业务逻辑代码工作会紧密耦合在一起的！日后维护会困难 

Mode II 中所有的开发都是以Servlet为主体展开的，由Servlet接收所有的客户端请求，然后根据请求调用相对应的JavaBean，并所有的显示结果交给JSP完成！，也就是俗称的MVC设计模式！

![img](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/20201208190558.png)

MVC设计模式：

* 显示层（View）：主要负责接受Servlet传递的内容，调用JavaBean，将内容显示给用户

* 控制层（Controller）：主要负责所有用户的请求参数，判断请求参数是否合法，根据请求的类型调用JavaBean，将最终的处理结果交给显示层显示！

* 模型层（Mode）：模型层包括了业务层，DAO层。

### 11.1总结

* JSP+JavaBean设计模式。

* MVC设计模式。

