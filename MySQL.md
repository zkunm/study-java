## 1、MySQL基础知识

### 数据库常见概念

* DB: 数据库，存储数据的容器。
* DBMS：数据库管理系统，又称为数据库软件或者数据库产品，用于创建或管理DB
* SQL：结构化查询语言，用于和数据库通信的语言，不是某个数据库软件所特有的，二十几乎所有的主流数据库软件通用的语言。

### MySQL语法规范

1. 不区分大小写，但建议关键字大写，表名、列名小写
2. 每条命令最好用英文分号结尾
3. 每条命令根据需要可以进行缩进和换行
4. 注释
   * 单行注释：#注释文字   -- 注释文字
   * 多行注释：/\*注释文字\*/

### SQL语言分类

* DDL(Data Define Languge)数据定义语言: 建库建表
* DML(Data Manipulation Language)数据操作语言： 对表中的记录操作增删改
* DQL(Data Query Language)数据查询语言，对表中的查询操作
* DCL(Data Control Language)数据控制语言：对用户权限的设置

### MySQL常用命令

```mysql
mysql -u用户名 -p

# 查看数据库版本
# shell终端
mysql -v
# 数据库内
select version();

# 显示所有数据库
show databases;

# 进入指定的库
use 库名;

# 显示当前库中所有的表
show tables;

# 查看其它库中的所有的表
show tables from 库名;

# 查看表的创建语句
show create table 表名;

# 查看表结构
desc 表名;

# 查看当前所在库
select database();

# 查看当前MySQL支持的存储引擎
show engines;

# 查看系统变量及其值
show variables;
```

## 2、MySQl中的数据类型

* 整数类型：bit, bool, tinyint, smallint, mediumint, int, bigint
* 浮点数类型：float, double, decimal
* 字符串类型：char, varchar, tinyblob, blob, mediumblob, longblob, thinytext, text, mediumtext, longtext
* 日期类型：Date, DateTime, TimeStamp, Time, Year
* 其他数据类型

**数据类型选择的建议**

* 选小不选大：一般情况下选择可以正确存储数据的最小数据类型，越小的数据类型通常更快，占用磁盘、内存和CPU缓存更小
* 简单就好：简单的数据类型的操作通常需要更少的CPU周期
* 尽量避免NULL：尽量指定列为NOT NULL，除非真的需要NULL类型的值，有NULL的列值会使得索引，索引统计和值更加复杂
* 浮点数建议统一选择decimal
* 记录时间的建议使用int或者bigint类型，将时间转换为时间戳格式

## 3、DCL-管理员常用命令

MySQL权限工作原理

* MySQL是如何识别一个用户的呢？

  MySQL通过用户名+主机名来识别用户的身份

* MySQL权限验证分为两个阶段

  * 连接数据库，此时MySQL会根据你的用户名及你的来源判断是否有权限链接
  * 对MySQL服务器发起请求操作，如create table, select, delete, update, create index等操作，此时MySQL会判断你是否有权限操作这些指令

权限生效时间

* 用户及权限信息放在库名为mysql的库中，mysql启动时，这些内容被读取到内存并即时生效。如果通过直接操作这些表来修改用户及权限信息，需要重启mysql或者执行flush privileges;生效。
* 用户登录后，mysql回合当前用户之间创建一个链接，此时用户相关的权限信息都保存在这个链接中，存放在内存中，此时如果有其他地方修改了当前用户的权限，这些变更的权限会在下一次登录时生效。

### 查看mysql中所有用户

```mysql
select user,host from mysql.user;
```

### 创建用户

```mysql
create user 用户名[@主机名] [identified by '密码']
1. 主机名默认为%，表示这个用户可以从任何主机连接Mysql服务器
2. 密码可以省略，表示无密码登录
```

### 修改密码（3种方式）

```mysql
方式1：
set password for '用户名'@'主机' = password('密码');
方式2：
set password = password('密码');
方式3：
update mysql.user set authentication_string = password('密码') where user = '用户名' and host = '主机';
flush privileges;
```

### 给用户授权

```mysql
grant 权限 on 数据库.表名 to '用户名'[@'主机'] [with grant option];
```

grant命令说明：

* 权限列表，可以是all，表示所有权限
* on用来指定权限针对哪些库和表
* to指定某个用户
* with grant option表示用户可以将自己拥有的权限有权给别人

查看用户权限

```mysql
show grants [for '用户名'[@'主机']]
```

撤销用户的权限

```mysql
revoke 权限 on 数据库.表名 from '用户名'[@'主机'];
```

### 删除用户（2种方式）

```mysql
方式1：
drop user '用户名'[@'主机'];	# 下次登录生效
方式2：
delete from mysql.user where user = '用户名' and host ='主机';
flush privileges;
```

## 4、 DDL-常见操作

### 库的管理

```mysql
# 创建库
create database [if not exists] 库名;
# 删除库
drop database [if exists] 库名;
```

### 表的管理

```mysql
# 创建表
create table 表名(
	字段名1 类型[(宽度)] [约束条件] [comment '字段说明'],
)[表的一些设置];

约束说明：
	1. not null 标识字段不能为空
	2. default value 为该字段设置默认值，默认值为value
	3. primary key 标识字段为该表的主键
	4. foreign key 为表中的字段设置外键
		foreign key(当前表中的字段) references 引用的外键表（外键表中字段名称）
	5. unique key() 表示字段字段的值是唯一的
	6. auto_increment 标识字段的值自动增长
	
# 删除表
drop table [if exists] 表名；
# 修改表名
alter table 表名 rename [to] 新表名;
# 表设置备注
alter table 表名 comment '备注信息';
# 复制表
create table 表名 like 被复制的表;
# 复制表结构+数据
create table 表名 [as] select 字段,... from 被复制的表 [where 条件];
```

### 表中列的管理

```mysql
# 添加列
alter table 表名 add column 列名 类型 [列约束];
# 修改列
alter table 表名 modify column 列名 新类型 [约束];
alter table 表名 change column 列名 新列名 新类型 [约束];
# 删除列
alter table 表名 drop column 列名;
```

## 5、DML常见操作

### 插入操作

```mysql
# 单行插入的两种方式
insert into 表名 [(字段,字段)] values(值,值);
insert into 表名 set 字段 = 值, 字段 = 值;

# 批量插入的两种方式
insert into 表名 [(字段,字段)] values (值,值),(值,值),(值,值);
insert into 表名 [(字段,字段)] 数据来源select语句;
```

### 数据更新

```mysql
# 单表更新
update 表名 [[as] 别名] set [别名.]字段 = 值, [别名.]字段 = 值[where条件];

# 多表更新
update 表1 [[as] 别名1], 表2 [[as] 别名2] set [别名.]字段 = 值, [别名.]字段 = 值[where条件];
```

### 删除数据操作

```mysql
# delete
# 单表删除
delete [别名] from 表名 [[as] 别名] [where条件];
# 多表删除
delete [别名1,别名2] from 表1 [[as] 别名1], 表2[[as] 别名2] [where条件];

# truncate
truncate 表名;
```

#### drop，truncate，delete区别

* drop(删除表)，删除内容和定义，释放空间。
* truncate(清空表中的数据)，删除内容、释放空间但不删除定义
* delete(删除表中的数据)，delete语句用以删除表中的行。delete语句执行删除的过程是每次从表中删除一行，并且同时将操作作为事务记录保存在日志中，便于回滚操作。
* truncate与不带where的delete：只删除，而不删除表的结构。
* truncate table删除表中的所有行，单表结构及其列、约束、索引等保持不变。
* 对于有foreign key约束引用的表，不能使用truncate table，而应使用不带where子句的delete语句。由于truncate table记录在日志中，所以他不能激活触发器。
* delete语句是数据库操作语言，这个操作会放到rollback segement中，事务提交后才能生效，如果有对应的tigger，执行的时候将被触发。truncate、drop是数据定义语言，操作立即生效，元数据不放到rollback segement中不能回滚，操作不触发tigger。
* 如果有自增列，truncate方式删除之后，自增列的值会被初始化，delete方式要情况（重启会触发初始化，不重启则不变）

## 6、select查询

**基本语法**

```mysql
select 查询的列 from 表名;
```

```mysql
# 查询常量
select 1, 'b';

# 查询表达式
select 表达式;

# 查询函数
select 函数;

# 查询指定字段
select 字段1, 字段2, 字段3 from 表名;

# 查询所有的列
select * from 表名;

# 列别名
select 列 [as] 别名 from 表;

# 表别名
select 别名.字段, 别名.* from 表名 [as] 别名;
```

## 7、select条件查询

### 语法

```mysql
select 列名 from 表名 where 列 运算符 值;
```

### 条件查询运算符

```mysql
# 等于(=)
select 列名 from 表名 where 列 = 值;
# 不等于(<>, !=)
select 列名 from 表名 where 列 <> 值;
select 列名 from 表名 where 列 != 值;
# 大于(>)
select 列名 from 表名 where 列 > 值;
```

### 逻辑查询运算符

```mysql
# AND(并且)
select 列名 from 表名 where 条件1 and 条件2;
# OR(或者)
select 列名 from 表名 where 条件1 or 条件2;
```

### like模糊查询

```mysql
select 列名 from 表名 where 列 like pattern;
	pattern可以包含通配符：
		% 标识匹配任意一个或者多个字符
		_ 标识匹配任意一个字符
```

### between and 区间查询

```mysql
select 列名 from 表名 where 列名 between 值1 and 值2;
返回对应的值在[值1，之2]区间的记录
```

### in查询

```mysql
select 列名 from 表名 where 字段 in (值1,值2,值3,值4);
```

### not in查询

```mysql
select 列名 from 表名 where 字段 not in (值1,值2,值3,值4);
```

### is  null/is not null（null值专⽤查询）

```mysql
select 列名 from 表名 where 列 is null;
select 列名 from 表名 where 列 is not null;
```

### <=>（安全等于）

```mysql
<=>：既可以判断NULL值，又可以判断普通的数值，可读性较低，⽤得较少
```

## 8、排序和分页（order by, limit）

### 排序查询order by

```mysql
select 字段名 from 表名 order by 字段1 [asc|desc],字段2 [asc|desc];
asc 升序 默认
desc 降序
```

### 分页查询limit

```mysql
select 列 from 表 limit [offset,] count;
offset表⽰偏移量，通俗点讲就是跳过多少⾏，offset可以省略，默认为0，表⽰跳过0⾏；范围：[0,+∞)。
count跳过offset⾏之后开始取数据，取count⾏记录；范围：[0,+∞)。
limit中offset和count的值不能⽤表达式。
```

## 9、分组查询group by, having

```mysql
select 字段，聚合函数 from 表名 [where条件] group by 分组表达式 [having分组表达式];
```

**聚合函数**

| 函数名 | 作用               |
| ------ | ------------------ |
| max    | 查询指定列的最大值 |
| min    | 查询指定列的最小值 |
| count  | 查询统计结果的行数 |
| sum    | 求和               |
| avg    | 求平均值           |

### group by 和 having的区别

​	where是在分组前对记录进行筛选，而having是在分组后的结果里筛选，最后返回整个sql的查询结果。可以把having理解为两级查询，即含having的查询操作先获得不含having⼦句时的sql查询 结果表，然后在这个结果表上使⽤having条件筛选出符合的记录，最后返回这些记录，因 此，having后是可以跟聚合函数的，并且这个聚集函数不必与select后⾯的聚集函数相 同。

### where & group by & having & order by & limit一起协作

```mysql
select 列 from 表
    where 查询条件
    group by 分组表达式
    having 分组过滤条件
    order by 排序条件
    limit [offset,] count;
```

## 10、MySQL常用函数汇总

### 数值型函数

| 函数名                 | 作用                                                 |
| ---------------------- | ---------------------------------------------------- |
| abs(x)                 | 返回x的绝对值                                        |
| sqrt(x)                | 返回非负数x的二次方根                                |
| mod(x, y)              | 返回x被y整除后的余数                                 |
| ceil(x), ceiling(x)    | 返回不小于x的最小整数值                              |
| floor(x)               | 返回小于x的最大整数值                                |
| rand()                 | 返回一个0~1之间的随机数                              |
| round(x, y)            | 返回最接近参数x的整数，四舍五入，保留小数点后指定y位 |
| sign(x)                | 返回参数x的符号                                      |
| pow(x, y), power(x, y) | 返回参数x的y次方                                     |
| siin(x)                | 返回参数x的正弦值                                    |
| pi()                   | 圆周率                                               |

### 字符串函数

| 函数名                 | 作用                                                         |
| ---------------------- | ------------------------------------------------------------ |
| length(x)              | 返回字符串的**字节**长度<br/>一个汉字是3个字节，一个数字或者一个字母是一个字节 |
| concat(x1, x2, x3,...) | 合并字符串                                                   |
| insert(s1, x, len, s2) | 返回字符串s1，⼦字符串起始于x位置，并且⽤len个字符长的字符串代替s2 |
| lower(x)               | 转换小写                                                     |
| upper(x)               | 转换大写                                                     |
| left(s, n)             | 返回字符串s最左边的n个字符，s=1表⽰第⼀个字符                |
| right(s, n)            | 数返回字符串s最右边的n个字符                                 |
| trim(s)                | 删除字符串s两侧的空格                                        |
| replace(s, s1, s2)     | 使⽤字符串s2替换字符串s中所有的字符串s1                      |
| substr, substring      | substr(str, pos)<br/>substr(str from pos)<br/>substr(str, pos, len)<br/>substr(str from pos for len)<br/>没有len参数的形式是字符串str从位置pos开始返回⼀个⼦字符串<br/>带有len参数的形式是字符串str从位置pos开始返回长度为len的⼦字符串<br/>对pos使⽤负值，⼦字符串的开头是字符串末尾的pos字符 <br/>所有形式的substring()，字符串中第⼀个字符的位置被认为是1 |
| reverse(s)             | 字符串s反转                                                  |

### 日期和时间函数

| 函数名                                        | 作用                                   |
| --------------------------------------------- | -------------------------------------- |
| curdate(), current_date()                     | 返回当前系统的日期值                   |
| curtime(), current_time()                     | 获取系统当前时间                       |
| now(), sysdate()                              | 获取当前日期                           |
| unix_timestamp()                              | 获取unix时间戳                         |
| form_unixtime(时间戳，格式)                   | 时间戳转换日期                         |
| month(date)                                   | 获取指定日期的月份                     |
| monthname(date)                               | 获取指定日期月份对应的英文名           |
| dayname(date)                                 | 获取date对应的工作日名称               |
| dayofweek(date)                               | 获取日期对应的周索引                   |
| week(date, [mode])                            | 计算⽇期date是⼀年中的第⼏周           |
| dayofyear(d)                                  | 返回d是⼀年中的第⼏天                  |
| dayofmonth(d)                                 | 返回d是一个月中的第几天                |
| year()                                        | 获取年份                               |
| timetosec()                                   | 将时间转换成秒值                       |
| sectotime()                                   | 秒值转换成时间                         |
| date_add(date, interval expr type), adddate() | 向日期添加指定时间间隔                 |
| date_sub(date, interval expr type), subdate() | 向日期减去指定时间间隔                 |
| addtime(time, exprr)                          | 时间加法                               |
| subtime(time, expr)                           | 时间减法                               |
| datediff(date1, date2)                        | 起始时间date1和结束时间date2之间的天数 |
| date_format(date, format)                     | 根据format指定的格式显⽰date值         |
| weekday(date)                                 | date的星期索引                         |

### 聚合函数

见9分页查询聚合函数

### 流程控制

* if判断

  if(expr, v1, v2)当expr为真返回v1的值，否则返回v2

* ifnull判空

  ifnull(v1, v2)v1为空返回v2，否则返回v1

* case搜索语句

  * case 表达式

    ​	when 值1 then 操作

    ​	when 值2 then 操作

    ​	else 操作

    end case;

  * case 

    ​	when 条件1 then 命令

    ​	when 条件2 then 命令

    ​	else 命令

    end case

### 其他函数

```mysql
version();
database();
user();
password();
md5();
```

## 11、连接查询及原理

### 笛卡儿积

​	笛卡尔积简单点理解：有两个集合A和B，笛卡尔积表⽰A集合中的元素和B集合中的元素 任意相互关联产⽣的所有可能的结果。 

​	假如A中有m个元素，B中有n个元素，A、B笛卡尔积产⽣的结果有m*n个结果，相当于循 环遍历两个集合中的元素，任意组合。

**sql笛卡尔积语法**

```mysql
select 字段 from 表1,表2[,表N];
select 字段 from 表1 join 表2 [join 表N];
```

### 内连接

```mysql
select 字段 from 表1 inner join 表2 on 连接条件;
select 字段 from 表1 join 表2 on 连接条件;
select 字段 from 表1, 表2 [where 关联条件];

内连接相当于在笛卡尔积的基础上加上了连接的条件。
当没有连接条件的时候，内连接上升为笛卡尔积。
过程⽤java伪代码如下：
for(Object a : A) {
    for(Object b : B) {
        if(连接条件是否为true) {
            System.out.print(a + ", " + b );
        }
    }
}
```

### 外连接

​	外连接涉及到2个表，分为：主表和从表，要查询的信息主要来⾃于哪个表，谁就是主表。 

​	外连接查询结果为主表中所有记录。如果从表中有和它匹配的，则显⽰匹配的值，这部分相当于内连接查询出来的结果；如果从表中没有和它匹配的，则显⽰null。 最终：外连接查询结果=内连接的结果+主表中有的⽽内连接结果中没有的记录。 

外连接分为2种： 

* 左外链接：使⽤left join关键字，left join左边的是主表。 
* 右外连接：使⽤right join关键字，right join右边的是主表。

**左连接**

```mysql
select 列 from 主表 left join 从表 on 连接条件;
```

**右连接**

```mysql
select 列 from 从表 right join 主表 on 连接条件;
```

## 12、子查询

出现在select语句中的select语句，称为⼦查询或内查询。

 外部的select查询语句，称为主查询或外查询。

**子查询分类**

* 按照结果集的行列数
  * 标量子查询（结果集只有一行一列）
  * 列子查询（结果集只有一列多行）
  * 行子查询（结果集有一行多列）
  * 表子查询（结果集为多行多列）
* 按子查询出现在主查询中的不同位置分
  * select后面 仅仅支持标量子查询
  * from 后面 支持表子查询
  * where或having后面，支持标量子查询、列子查询、行子查询
  * exists后面 表子查询

## 13、NULL导致的神坑

### 比较运算符中使用NULL

任何值和NULL使用运算符或者（in, not in, any/some, all）比较时，返回值都为null，null作为布尔值的时候，不为1也不为0

### IN、NOT IN、NULL比较

* 当in和null比较时，无法查询出Null的记录
* 当NOT IN后⾯有NULL值时，不论什么情况下，整个sql的查询结果都为空

### EXISTS、NOT EXISTS和NULL⽐较

* 使⽤exists、not exists对⽐，因为=不能⽐较NULL，结果和预期⼀致。

### 判断NULL只能⽤IS NULL、IS NOT NULL

* count(字段)⽆法统计字段为NULL的值，count(*)可以统计值为null的⾏。

## 14、事务

​	数据库中的事务是指对数据库执⾏⼀批操作，这些操作最终要么全部执⾏成功，要么全部失败，不会存在部分成功的情况。

### 事务的四个特征（ACID）

* 原子性(Atomicity)：事务的整个过程如原子操作一样，最终要么全部成功，或者全部失败，这个原子性是从最终结果来看的，从最终结果来看这个过程是不可分割的。
* 一致性(Consistency)：事务开始之前、执行中、执行完毕，这些时间点，多个人去观察事务操作的数据的时候，看到的数据都是一致的，比如在事务操作过程中，A连接看到的是100，那么B此时也去看的时候也是100，不会说AB看到的数据不一样，他们在某个时间点看到的数据是一致的。
* 隔离性(Isolation)：一个事物的执行不能被其他事务干扰。即一个事务内务的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。
* 持久性(Durability)：一个事务一旦提交，他对数据库中的数据的改变是永久性的。当事务提交之后，数据会持久化到硬盘上，修改是永久性的。

### Mysql中事务操作

mysql中默认是隐式事务，执行insert, update, delete操作的时候，数据库自动开启事务、提交和回滚事务。

是否开启隐式事务是由变量autocomit控制的。

#### 隐式事务

​	事务⾃动开启、提交或回滚，⽐如insert、update、delete语句，事务的开启、提交或回滚由mysql内部⾃动控制的。

```mysql
show variables like 'autocommit';
```

#### 显式事务

​	事务需要⼿动开启、提交或回滚，由开发者⾃⼰控制。

```mysql
# 方式1
set autocommit = 0;
commit;
rollback;

# 方式2
start transaction;
commit;
rollback;
```

#### savepoint关键字

​	savepoint需要结合rollback to⼀起使⽤，可以将保存点到rollback to之间的操作回滚掉。

#### 只读事务

​	表⽰在事务中执⾏的是⼀些只读操作，如查询，但是不会做insert、update、delete操作，数据库内部对只读事务可能会有⼀些性能上的优化。

```mysql
start transaction read only;
```

### 事务中的一些问题

* 脏读：一个事务在执行过程中读取到了其他事务还没有提交的数据。
* 读已提交：一个事务操作过程中可以读取到其他事务已经提交到的数据。
* 可重复读：一个事务操作中对于一个读取操作不管多少次，读取到的结果都是一样的。
* 幻读：幻读在可重复读的模式下才会出现。事务中后⾯的操作（插⼊号码X）需要上⾯的读取操作（查询号码X 的记录）提供⽀持，但读取操作却不能⽀持下⾯的操作时产⽣的错误，就像发⽣了幻觉⼀ 样。

### 事务隔离级别

* 读未提交：**Read uncommitted**
* 读已提交：**Read Committed**
* 可重复读：**Repeated Read**
* 序列化：**Serializable**

**查看隔离级别**

```mysql
show variables like 'transaction_isolation';
```

**隔离级别的设置**

修改mysql中的my.init文件

```mysql
transaction-isolation=READ-UNCOMMITTED
```

#### 各种隔离级别中会出现的问题

| 隔离级别         | 脏读 | 不可重复读 | 幻读 |
| ---------------- | ---- | ---------- | ---- |
| READ-UNCOMMITTED | √    | √          |      |
| READ-COMMITTED   |      | √          |      |
| REPEATABLE-READ  |      |            | √    |
| SERIALIZABLE     |      |            |      |

#### 隔离级别的选择

1. 需要对各种隔离级别产生的现象非常了解，然后选择的时候才能游刃有余
2. 隔离级别越高，并发性也低，比如最高级别`SERIALIZABLE`会让事物串行执行，并发操作变成串行了，会导致系统性能直接降低。
3. 具体选择哪种需要结合具体的业务来选择。
4. 读已提交（READ-COMMITTED）通常用的比较多。

## 15、视图

​	视图是在mysql5之后出现的，是⼀种虚拟表，⾏和列的数据来⾃于定义视图时使⽤的⼀ 些表中，视图的数据是在使⽤视图的时候动态⽣成的，视图只保存了sql的逻辑，不保存查询的结果。

​	多个地方使用到同样的查询结果，并且该查询结果比较复杂的时候，我们可以使用视图来隐藏复杂的实现细节。

**视图和表的区别**

|      | 语法         | 实际中是否占用物理空间 | 使用     |
| ---- | ------------ | ---------------------- | -------- |
| 视图 | create view  | 只是保存了sql的逻辑    | 增删改查 |
| 表   | create table | 保存了数据             | 增删改查 |

**视图的好处**

* 简化复杂的sql操作，不用知道他的实现细节
* 隔离了原始表，可以不让使用表的人接触原生的表，从而保护原始数据，提高了安全性

```mysql
# 创建视图
create view 视图名 as 查询语句;

# 修改视图1
create or replace view 视图名 as 查询语句;
# 修改视图2
alter view 试图名 as 查询语句;

 # 删除视图
 drop view 视图名：
 
 # 查看视图结构
 desc 视图名;
 show create view 视图名;
```

## 16、变量

变量分类

* 系统变量
* 自定义变量

### 系统变量

​	系统变量由系统定义的，不是⽤户定义的，属于mysql服务器层⾯的。

**系统变量分类**

* 全局变量
* 会话变量

```mysql
# 查看全局变量
show global variables;
# 查看会话变量
show session variables;
show variables;
# 查看满⾜条件的系统变量
show [global|session] like '%变量名%';
# 查看指定的系统变量的值
select @@[global.|session.]系统变量名称;
# 赋值
set [global|session] 系统变量名 = 值;
set @@[global.|session.]系统变量名 = 值;
```

### 自定义变量

**分类**

* 用户变量
* 局部变量

**用户变量**

```mysql
set @变量名=值;
set @变量名:=值;
select @变量名:=值;
```

**局部变量**

```mysql
# 声明
declare 变量名 变量类型;
declare 变量名 变量类型 [default 默认值];
# 赋值
set 局部变量名=值;
set 局部变量名:=值;
select 局部变量名:=值;
# 使⽤（查看变量的值）
select 局部变量名;
```

### delimiter关键字

​	通过delimiter关键字来⾃定义结束符

```mysql
delimiter 分隔符
```

## 17、存储过程和自定义函数理解

### 存储过程

​	⼀组预编译好的sql语句集合，理解成批处理语句。

**好处：**

* 提高代码的重用性
* 简化操作
* 减少编译次数并减少和数据库服务器连接的次数

```mysql
# 创建存储过程
create procedure 存储过程名([参数模式] 参数名 参数类型)
begin
	存储过程体
end
	参数模式有3种：
		in: 该参数可以作为输入，也就是该参数需要调用方法传入值
		out: 该参数可以作为输出，也就是说该参数可以作为返回值
		inout: 该参数可以作为输入也可以作为输出，也就是该参数需要在调用的时候传入值，又可以作为返回值。
	参数模式默认为IN
	
# 调用存储过程
call 存储过程名;

# 删除存储过程
drop procedure [if exists] 存储过程名;

# 修改存储过程
不能修改，删除、新建

# 查看存储过程
show create procedure 存储过程名;
```

### 函数

​	⼀组预编译好的sql语句集合，理解成批处理语句。类似于java中的⽅法，但是必须有返回值。

```mysql
# 创建函数
create function 函数名(参数名称 参数类型)
returns 返回值类型
begin
	函数体
end

# 调用函数
select 函数名(实参列表);

# 删除函数
drop function [if exists] 函数名;

# 查看函数详细
drop create function 函数名;
```

### 存储过程和函数的区别

* 存储过程的关键字为**procedure**，返回值可以有多个，调用时用**call**，**一般用于执行比较复杂的的过程体、更新、创建等语句**。

* 函数的关键字为**function**，**返回值必须有一个**，调用用**select**，一般用于查询单个值并返回。

## 18、控制语句介绍

### if函数

```mysql
if(条件表达式, 值1, 值2);
    if函数有3个参数。
    当条件表达式为true的时候，返回值1，否则返回值2。
```

### CASE结构

```mysql
case 表达式
    when 值1 then 结果1或者语句1（如果是语句需要加分号）
    when 值2 then 结果2或者语句2
    ...
    else 结果n或者语句n
end [case] （如果是放在begin end之间需要加case，如果在select后则不需要）


case
    when 条件1 then 结果1或者语句1（如果是语句需要加分号）
    when 条件2 then 结果2或者语句2
    ...
    else 结果n或者语句n
end [case] （如果是放在begin end之间需要加case，如果是在select后⾯case可以省略）
```

### if结构

```mysql
if 条件语句1 then 语句1;
    elseif 条件语句2 then 语句2;
    ...
    else 语句n;
end if;
    只能使⽤在begin	end之间。
```

### 循环

* while  类似于java中的while循环
* repeat  类似于java中的do	while循环
* loop  类似于java中的while(true)死循环，需要在内部进⾏控制。

 **结束本次循环** 

​	类似于java中的continue 

​	iterate 循环标签 

**退出循环** 

​	类似于java中的break 

​	leave 循环标签

**while循环**

```mysql
[标签:]while 循环条件 do
    循环体
end while [标签];
    标签：是给while取个名字，标签和iterate、leave结合⽤于在循环内部对循环进⾏控制：如：跳出循环、结束本次循环。
    注意：这个循环先判断条件，条件成⽴之后，才会执⾏循环体，每次执⾏都会先进⾏判断。
```

### repeat循环

```mysql
[标签:]repeat
    循环体;
until 结束循环的条件 end repeat [标签];
	repeat循环类似于java中的do...while循环，不管如何，循环都会先执⾏⼀次，然后再判断结束循环的条件，不满⾜结束条件，循环体继续执⾏。这块和while不同，while是先判断条件是否成⽴再执⾏循环体。
```

### loop循环

```mysql
[标签:]loop
    循环体;
end loop [标签];
	loop相当于⼀个死循环，需要在循环体中使⽤iterate或者leave来控制循环的执⾏。
```

## 19、游标

​	游标（Cursor）是处理数据的⼀种⽅法，为了查看或者处理结果集中的数据，游标提供了 在结果集中⼀次⼀⾏遍历数据的能⼒。 

​	游标只能在存储过程和函数中使⽤。

```mysql
# 声明游标
DECLARE 游标名称 CURSOR FOR 查询语句;
    ⼀个begin	end中只能声明⼀个游标。
# 打开游标
open 游标名称;
# 遍历游标
fetch 游标名称 into 变量列表;
	取出当前⾏的结果，将结果放在对应的变量中，并将游标指针指向下⼀⾏的数据。
	当调⽤fetch的时候，会获取当前⾏的数据，如果当前⾏⽆数据，会引发mysql内部的NOT FOUND错误。
# 关闭游标
close 游标名称;
	游标使⽤完毕之后⼀定要关闭。
```

## 20、异常捕获以及处理

**异常分类**

* MySQL内部异常：当我们执⾏⼀些sql的时候，可能违反了mysql的⼀些约束，导致mysql内部报错，如插⼊数据违反唯⼀约束，更新数据超时等，此时异常是由mysql内部抛出的，我们将这些由mysql抛出的异常统称为内部异常。
* 外部异常：当我们执⾏⼀个update的时候，可能我们期望影响1⾏，但是实际上影响的不是1⾏数据，这种情况：sql的执⾏结果和期望的结果不⼀致，这种情况也我们也把他作为外部异 常处理，我们将sql执⾏结果和期望结果不⼀致的情况统称为外部异常。

### MySQL内部异常

HANDLER FOR 异常名处理异常

### 外部异常

​	外部异常不是由mysql内部抛出的错误，⽽是由于sql的执⾏结果和我们期望的结果不⼀致 的时候，我们需要对这种情况做⼀些处理，如回滚操作。

​	可以使用乐观锁，⽤期望的值和⽬标值进⾏⽐较，如果相同，则更新⽬标值，否则 什么也不做。

​	ROW_COUNT()可以获取更新或插⼊后获取受影响⾏数。

## 21、索引

​	索引是依靠某些数据结构和算法来组织数据，最终引导⽤户快速检索出所需要的数据。 

索引有2个特点： 

1. 通过数据结构和算法来对原始的数据进⾏⼀些有效的组织 

2. 通过这些有效的组织，可以引导使⽤者对原始数据进⾏快速检索mysql为了快速检索数据，也⽤到了⼀些好的数据结构和算法，来组织表中的数据，加快检索效率。

## 22、MySQL索引原理详解

​	索引的本质：通过不断地缩⼩想要获取数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，有了这种索引机制，我们可以总是⽤同⼀种查找⽅式来锁定数据。

**MySQL中的⻚**

​	MySQL中和磁盘交互的最⼩单位称为页，页是MySQL内部定义的⼀种数据结构，默认为16kb，相当于4个磁盘块，也就是说MySQL每次从磁盘中读取⼀次数据是16KB，要么不读取，要读取就是16KB，此值可以修改的。

**数据检索过程**

​	我们对数据存储⽅式不做任何优化，直接将数据库中表的记录存储在磁盘中，假如某个表只有⼀个字段，为int类型，int占⽤4个byte，每个磁盘块可以存储1000条记录，100万的 记录需要1000个磁盘块，如果我们需要从这100万记录中检索所需要的记录，需要读取1000个磁盘块的数据（需要1000次io），每次io需要9ms，那么1000次需要 9000ms=9s，100条数据随便⼀个查询就是9秒，这种情况我们是⽆法接受的，显然是不行的。

1. 需要⼀种数据存储结构：当从磁盘中检索数据的时候能，够减少磁盘的io次数，最好能够降低到⼀个稳定的常量值 
2. 需要⼀种检索算法：当从磁盘中读取磁盘块的数据之后，这些块中可能包含多条记录，这些记录被加载到内存中，那么需要⼀种算法能够快速从内存多条记录中快速检索出⽬标数据

### 循环遍历查找

​	从⼀组⽆序的数据中查找⽬标数据，常见的⽅法是遍历查询，n条数据，时间复杂度为 O(n)，最快需要1次，最坏的情况需要n次，查询效率不稳定。

### **⼆分法查找**

​	⼆分法查找也称为折半查找，⽤于在⼀个有序数组中快速定义某⼀个需要查找的数据。 

​	原理是： 先将⼀组⽆序的数据排序（升序或者降序）之后放在数组中，此处⽤升序来举例说明：⽤ 数组中间位置的数据A和需要查找的数据F对⽐，如果A=F，则结束查找；如果AF，则将查找范围缩⼩⾄数组中A数据 左边的部分，继续按照上⾯的⽅法直到找到F为⽌。

​	查找速度相当快，每次查找都会使范围减半，耗时时间⽐较稳定。 

​	⼆分法查找时间复杂度是:O(logN)(N为数据量)，100万数据查找最多只需要20次（ =1048576） 

​	⼆分法查找数据的优点：定位数据⾮常快，前提是：⽬标数组是有序的

### **有序数组**

​	如果我们将mysql中表的数据以有序数组的⽅式存储在磁盘中，那么我们定位数据步骤是：

1. 取出⽬标表的所有数据，存放在⼀个有序数组中 
2. 如果⽬标表的数据量⾮常⼤，从磁盘中加载到内存中需要的内存也⾮常⼤

  步骤1取出所有数据耗费的io次数太多，步骤2耗费的内存空间太⼤，还有新增数据的时候，为了保证数组有序，插⼊数据会涉及到数组内部数据的移动，也是⽐较耗时的，显然⽤这种⽅式存储数据是不可取的。

### 链表

​	链表相当于在每个节点上增加⼀些指针，可以和前⾯或者后⾯的节点连接起来，就像⼀列⽕车⼀样，每节车厢相当于⼀个节点，车厢内部可以存储数据，每个车厢和下⼀节车厢相连。

​	链表分为单链表和双向链表。

链表的优点： 

1. 可以快速定位到上⼀个或者下⼀个节点 
2. 可以快速删除数据，只需改变指针的指向即可，这点⽐数组好 

链表的缺点： 

1. ⽆法向数组那样，通过下标随机访问数据 
2. 查找数据需从第⼀个节点开始遍历，不利于数据的查找，查找时间和⽆需数据类似， 需要全遍历，最差时间是O(N)

### ⼆叉查找树

​	⼆叉树是每个结点最多有两个⼦树的树结构，通常⼦树被称作“左⼦树”（left subtree）和 “右⼦树”（right subtree）。⼆叉树常被⽤于实现⼆叉查找树和⼆叉堆。

⼆叉树有如下特性： 

1. 每个结点都包含⼀个元素以及n个⼦树，这⾥0≤n≤2

2. 左⼦树和右⼦树有顺序，次序不能任意颠倒，左⼦树的值要⼩于⽗结点，右⼦树的值要⼤于⽗结点。

⼆叉树的优缺点： 

1. 查询数据的效率不稳定，若树左右⽐较平衡的时，最差情况为O(logN)，如果插⼊数据是有序的，退化为了链表，查询时间变成了O(N)
2. 数据量⼤的情况下，会导致树的⾼度变⾼，如果每个节点对应磁盘的⼀个块来存储⼀ 条数据，需io次数⼤幅增加，显然⽤此结构来存储数据是不可取的

数组[20,10,5,15,30,25,35]使⽤⼆叉查找树存储如下：

![image-20201204150211988](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/image-20201204150211988.png)

但是如果我们插⼊数据是有序的，如[5,10,15,20,30,25,35]，那么结构就变成下⾯这样：

![image-20201204150236493](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/image-20201204150236493.png)

### 平衡⼆叉树（AVL树）

​	平衡⼆叉树是⼀种特殊的⼆叉树，所以他也满⾜⼆叉查找树的两个特性，同时还有⼀个特性： 它的左右两个⼦树的⾼度差的绝对值不超过1，并且左右两个⼦树都是⼀棵平衡⼆叉树。

​	平衡⼆叉树相对于⼆叉树来说，树的左右⽐较平衡，不会出现⼆叉树那样退化成链表的情况，不管怎么插⼊数据，最终通过⼀些调整，都能够保证树左右⾼度相差不⼤于1。

​	这样可以让查询速度⽐较稳定，查询中遍历节点控制在O(logN)范围内

​	如果数据都存储在内存中，采⽤AVL树来存储，还是可以的，查询效率⾮常⾼。不过我们的数据是存在磁盘中，⽤过采⽤这种结构，每个节点对应⼀个磁盘块，数据量⼤的时候， 也会和⼆叉树⼀样，会导致树的⾼度变⾼，增加了io次数，显然⽤这种结构存储数据也是不可取的。

### B-树

​	B-树在是平衡⼆叉树上进化来的，前⾯介绍的⼏种树，每个节点上⾯只有⼀个元素，⽽B-树节点中可以放多个元素，主要是为了降低树的⾼度。

⼀棵m阶的B-Tree有如下特性： 

1. 每个节点最多有m个孩⼦，m称为b树的阶 
2. 除了根节点和叶⼦节点外，其它每个节点⾄少有Ceil(m/2)个孩⼦ 
3. 若根节点不是叶⼦节点，则⾄少有2个孩⼦ 
4. 所有叶⼦节点都在同⼀层，且不包含其它关键字信息
5. 每个⾮终端节点包含n个关键字（健值）信息 
6. 关键字的个数n满⾜：ceil(m/2)-1	<=	n	<=	m-1
7.  ki(i=1,…n)为关键字，且关键字升序排序 
8. Pi(i=1,…n)为指向⼦树根节点的指针。P(i-1)指向的⼦树的所有节点关键字均⼩ 于ki，但都⼤于k(i-1)	

   B-Tree结构的数据可以让系统⾼效的找到数据所在的磁盘块。为了描述B-Tree，⾸先定义⼀条记录为⼀个⼆元组[key, data]，key为记录的键值，对应表中的主键值，data为⼀⾏记 录中除主键外的数据。对于不同的记录，key值互不相同。 

​	B-Tree中的每个节点根据实际情况可以包含⼤量的关键字信息和分⽀，如下图所⽰为⼀个 3阶的B-Tree：

![image-20201204150626618](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/image-20201204150626618.png)

​	每个节点占⽤⼀个盘块的磁盘空间，⼀个节点上有两个升序排序的关键字和三个指向⼦树 根节点的指针，指针存储的是⼦节点所在磁盘块的地址。两个键将数据划分成的三个范围 域，对应三个指针指向的⼦树的数据的范围域。以根节点为例，关键字为17和35，P1指 针指向的⼦树的数据范围为⼩于17，P2指针指向的⼦树的数据范围为17~35，P3指针指 向的⼦树的数据范围为⼤于35。 

​	模拟查找关键字29的过程： 

1. 根据根节点找到磁盘块1，读⼊内存。【磁盘I/O操作第1次】
2. ⽐较关键字29在区间（17,35），找到磁盘块1的指针P2
3. 根据P2指针找到磁盘块3，读⼊内存。【磁盘I/O操作第2次】
4. ⽐较关键字29在区间（26,30），找到磁盘块3的指针P2
5.  根据P2指针找到磁盘块8，读⼊内存。【磁盘I/O操作第3次】
6. 在磁盘块8中的关键字列表中找到关键字29	 

  分析上⾯过程，发现需要3次磁盘I/O操作，和3次内存查找操作，由于内存中的关键字是 ⼀个有序表结构，可以利⽤⼆分法快速定位到⽬标数据，⽽3次磁盘I/O操作是影响整个BTree查找效率的决定因素。

​	B-树相对于avl树，通过在节点中增加节点内部数据的个数来减少磁盘的io操作。 

​	上⾯说过mysql是采⽤页⽅式来读写数据，每页是16KB，⽤B-树来存储mysql的 记录，每个节点对应mysql中的⼀页（16KB），假如每⾏记录加上树节点中的1个指针占 160Byte，那么每个节点可以存储1000（16KB/160byte）条数据，树的⾼度为3的节点⼤概可以存储（第⼀层1000+第⼆层 +第三层 ）10亿条记录，⼀个⾼度为3个B-树⼤概可以存储10亿条记录，从10亿记录中查找数据只需要3 次io操作可以定位到⽬标数据所在的页，⽽页内部的数据又是有序的，然后将其加载到内存中⽤⼆分法查找，是⾮常快的。 

​	可以看出使⽤B-树定位某个值还是很快的(10亿数据中3次io操作+内存中⼆分法)，但是也是有缺点的：B-不利于范围查找，⽐如上图中我们需要查找[15,36]区间的数据，需要访问7个磁盘块（1/2/7/3/8/4/9），io次数又上去了，范围查找也是我们经常⽤到的，所 以b-树也不太适合在磁盘中存储需要检索的数据。

### b+树

![image-20201204151152185](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/image-20201204151152185.png)

**b+树的特征**

1. 每个结点⾄多有m个⼦⼥
2. 除根结点外,每个结点⾄少有[m/2]个⼦⼥，根结点⾄少有两个⼦⼥
3. 有k个⼦⼥的结点必有k个关键字
4. ⽗节点中持有访问⼦节点的指针
5. ⽗节点的关键字在⼦节点中都存在（如上⾯的1/20/35在每层都存在），要么是最⼩值，要么是最⼤值，如果节点中关键字是升序的⽅式，⽗节点的关键字是⼦节点的最⼩值 
6. 最底层的节点是叶⼦节点
7. 除叶⼦节点之外，其他节点不保存数据，只保存关键字和指针
8. 叶⼦节点包含了所有数据的关键字以及data，叶⼦节点之间⽤链表连接起来，可以⾮常⽅便的⽀持范围查找

####  b+树与b-树的⼏点不同 

1. b+树中⼀个节点如果有k个关键字，最多可以包含k个⼦节点（k个关键字对应k个指 针）；⽽b-树对应k+1个⼦节点（多了⼀个指向⼦节点的指针）
2. b+树除叶⼦节点之外其他节点值存储关键字和指向⼦节点的指针，⽽b-树还存储了数 据，这样同样⼤⼩情况下，b+树可以存储更多的关键字
3.  b+树叶⼦节点中存储了所有关键字及data，并且多个节点⽤链表连接，从上图中看⼦ 节点中数据从左向右是有序的，这样快速可以⽀撑范围查找（先定位范围的最⼤值和 最⼩值，然后⼦节点中依靠链表遍历范围数据）

####  B-Tree和B+Tree该如何选择？ 

1. B-Tree因为⾮叶⼦结点也保存具体数据，所以在查找某个关键字的时候找到即可返回。⽽B+Tree所有的数据都在叶⼦结点，每次查找都得到叶⼦结点。所以在同样⾼ 度的B-Tree和B+Tree中，B-Tree查找某个关键字的效率更⾼。
2. 由于B+Tree所有的数据都在叶⼦结点，并且结点之间有指针连接，在找⼤于某个关键字或者⼩于某个关键字的数据的时候，B+Tree只需要找到该关键字然后沿着链表 遍历就可以了，⽽B-Tree还需要遍历该关键字结点的根结点去搜索
3. 由于B-Tree的每个结点（这⾥的结点可以理解为⼀个数据页）都存储主键+实际数据，⽽B+Tree⾮叶⼦结点只存储关键字信息，⽽每个页的⼤⼩有限是有限的，所以 同⼀页能存储的B-Tree的数据会⽐B+Tree存储的更少。这样同样总量的数据，B-Tree 的深度会更⼤，增⼤查询时的磁盘I/O次数，进⽽影响查询效率。

### Mysql的存储引擎和索引

mysql内部索引是由不同的引擎实现的，主要说⼀下InnoDB和MyISAM这两种引擎中的索引，这两种引擎中的索引都是使⽤b+树的结构来存储的。

#### InnoDB中的索引

 Innodb中有2种索引：**主键索引（聚集索引）**、**辅助索引（⾮聚集索引）**。 

* 主键索引：每个表只有⼀个主键索引，b+树结构，叶⼦节点同时保存了主键的值也数据 记录，其他节点只存储主键的值。 
* 辅助索引：每个表可以有多个，b+树结构，叶⼦节点保存了索引字段的值以及主键的 值，其他节点只存储索引指端的值。

#### MyISAM引擎中的索引

​	B+树结构，MyISM使⽤的是⾮聚簇索引，⾮聚簇索引的两棵B+树看上去没什么不同，节点的结构完全⼀致只是存储的内容不同⽽已，主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。表数据存储在独⽴的地⽅，这两颗B+树的叶⼦节点都使⽤⼀个 地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于索引树是独立的，通过辅助键检索⽆需访问主键的索引树。 

如下图：为了更形象说明这两种索引的区别，我们假想⼀个表存储了4⾏数据。其中Id作为主索引，Name作为辅助索引，图中清晰的显⽰了聚簇索引和⾮聚簇索引的差异。

![image-20201204151601403](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/image-20201204151601403.png)

#### InnoDB数据检索过程

​	如果需要查询id=14的数据，只需要在左边的主键索引中检索就可以了.

​	如果需要搜索name='Ellison'的数据，需要2步：

1. 先在辅助索引中检索到name='Ellison'的数据，获取id为14
2. 再到主键索引中检索id为14的记录

  辅助索引这个查询过程在mysql中叫做回表。

#### MyISAM数据检索过程

1. 在索引中找到对应的关键字，获取关键字对应的记录的地址
2. 通过记录的地址查找到对应的数据记录

  我们⽤的最多的是innodb存储引擎，所以此处主要说⼀下innodb索引的情况，innodb中最好是采⽤主键查询，这样只需要⼀次索引，如果使⽤辅助索引检索，涉及到回表操作， ⽐主键查询要耗时⼀些。

**innodb中辅助索引为什么不像myisam那样存储记录的地址？** 

​	表中的数据发⽣变更的时候，会影响其他记录地址的变化，如果辅助索引中记录数据的地址，此时会受影响，⽽主键的值⼀般是很少更新的，当页中的记录发⽣地址变更的时候， 对辅助索引是没有影响的。 

我们来看⼀下mysql中页的结构，页是真正存储记录的地⽅，对应B+树中的⼀个节点，也 是mysql中读写数据的最⼩单位，页的结构设计也是相当有⽔平的，能够加快数据的查询。

**⻚结构** 

​	mysql中页是innodb中存储数据的基本单位，也是mysql中管理数据的最⼩单位，和磁盘 交互的时候都是以页来进⾏的，默认是16kb，mysql中采⽤b+树存储数据，页相当于b+树 中的⼀个节点。 

页的结构如下图：

![image-20201204151627724](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/image-20201204151627724.png)

每个Page都有通⽤的头和尾，但是中部的内容根据Page的类型不同⽽发⽣变化。Page的 头部⾥有我们关⼼的⼀些数据，下图把Page的头部详细信息显⽰出来：

![image-20201204151702329](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/image-20201204151702329.png)

我们重点关注和数据组织结构相关的字段：Page的头部保存了两个指针，分别指向前⼀ 个Page和后⼀个Page，根据这两个指针我们很容易想象出Page链接起来就是⼀个双向链 表的结构，如下图：

![image-20201204151717335](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/image-20201204151717335.png)

再看看Page的主体内容，我们主要关注⾏数据和索引的存储，他们都位于Page的User  Records部分，User Records占据Page的⼤部分空间，User Records由⼀条⼀条的Record组 成。在⼀个Page内部，单链表的头尾由固定内容的两条记录来表⽰，字符串形式 的"Infimum"代表开头，"Supremum"代表结尾，这两个⽤来代表开头结尾的Record存储在 System Records的，In[inum、Supremum和User Records组成了⼀个单向链表结构。最初 数据是按照插⼊的先后顺序排列的，但是随着新数据的插⼊和旧数据的删除，数据物理顺 序会变得混乱，但他们依然通过链表的⽅式保持着逻辑上的先后顺序，如下图：

![image-20201204151740967](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/image-20201204151740967.png)

把User	Record的组织形式和若⼲Page组合起来，就看到了稍微完整的形式。

![image-20201204151814138](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/image-20201204151814138.png)

![image-20201204151836094](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/image-20201204151836094.png)

innodb为了快速查找记录，在页中定义了⼀个称之为page directory的⽬录槽（slots）,每个槽位占⽤两个字节（⽤于保存指向记录的地址），page directory中的多个slot组成了⼀个有序数组（可⽤于⼆分法快速定位记录，向下看），⾏记录被Page Directory逻辑的分成了多个块，块与块之间是有序的，能够加速记录的查找，如下图：

![image-20201204151902248](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/image-20201204151902248.png)

看上图，每个⾏记录的都有⼀个nowned的区域（图中粉⾊区域），nowned标识所属的 slot这个这个块有多少条数据，伪记录In[imum的nowned值总是1，记录Supremum的 nowned的取值范围为[1,8]，其他⽤户记录nowned的取值范围[4,8]，并且只有每个块中最 ⼤的那条记录的nowned才会有值，其他的⽤户记录的n_owned为0。

**数据检索过程** 

​	在page中查询数据的时候，先通过b+树中查询⽅法定位到数据所在的页，然后将页内整 体加载到内存中，通过⼆分法在page directory中检索数据，缩⼩范围，⽐如需要检索7， 通过⼆分法查找到7位于slot2和slot3所指向的记录中间，然后从slot3指向的记录5开始向 后向后⼀个个找，可以找到记录7，如果⾥⾯没有7，⾛到slot2向的记录8结束。

​	n_owned范围控制在[4,8]内，能保证每个slot管辖的范围内数据量控制在[4,8]个，能够加 速⽬标数据的查找，当有数据插⼊的时候，page directory为了控制每个slot对应块中记录 的个数（[4,8]），此时page directory中会对slot的数量进⾏调整。

**对page的结构总结⼀下** 

1. b+树中叶⼦页之间⽤双向链表连接的，能够实现范围查找
2. 页内部的记录之间是采⽤单向链表连接的，⽅便访问下⼀条记录
3. 为了加快页内部记录的查询，对页内记录上加了个有序的稀疏索引，叫页⽬录 （page directory） 整体上来说mysql中的索引⽤到了b+树，链表，⼆分法查找，做到了快速定位⽬标数据， 快速范围查找。

## 23、索引管理

### 索引分类

* 聚集索引
* 非聚集索引

#### 聚集索引

每个表有且⼀定会有⼀个聚集索引，整个表的数据存储在聚集索引中，mysql索引是采⽤B+树结构保存在⽂件中，叶⼦节点存储主键的值以及对应记录的数据，⾮叶⼦节点不存储记录的数据，只存储主键的值。当表中未指定主键时，mysql内部会⾃动给每条记录添 加⼀个隐藏的rowid字段（默认4个字节）作为主键，⽤rowid构建聚集索引。

聚集索引在mysql中又叫主键索引。

#### ⾮聚集索引（辅助索引）

也是b+树结构，不过有⼀点和聚集索引不同，⾮聚集索引叶⼦节点存储字段（索引字 段）的值以及对应记录主键的值，其他节点只存储字段的值（索引字段）。

 每个表可以有多个⾮聚集索引。

mysql中⾮聚集索引分为

* 单列索引 即⼀个索引只包含⼀个列
* 多列索引（⼜称复合索引） 即⼀个索引包含多个列
* 唯⼀索引 索引列的值必须唯⼀，允许有⼀个空值

#### 数据检索的过程

![image-20201204153040678](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/image-20201204153040678.png)

上⾯的表中有2个索引：id作为主键索引，name作为辅助索引。

innodb我们⽤的最多，我们只看图中左边的innodb中数据检索过程：

 如果需要查询id=14的数据，只需要在左边的主键索引中检索就可以了。 

如果需要搜索name='Ellison'的数据，需要2步： 

1. 先在辅助索引中检索到name='Ellison'的数据，获取id为14

2. 再到主键索引中检索id为14的记录

   辅助索引相对于主键索引多了第⼆步。

### 索引管理

```mysql
# 创建索引
create [unique] index 索引名称 on 表名(列名[(length)]);
alter 表名 add [unique] index 索引名称 on(列名[(length)]);
	如果字段是char、varchar类型，length可以⼩于字段实际长度，如果是blog、text等长⽂本类型，必须指定length。
	[unique]：中括号代表可以省略，如果加上了unique，表⽰创建唯⼀索引。如果table后⾯只写⼀个字段，就是单列索引，如果写多个字段，就是复合索引，多个字段之间⽤逗号隔开。

# 删除索引
drop index 索引名称 on 表名;

# 查看索引
show index from 表名;

# 索引修改
# 可以先删除索引，再重建索引。
```

## 24、正确使用索引

### b+树中数据检索过程

#### 唯一记录检索

![image-20201204160617813](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/image-20201204160617813.png)

如上图，所有的数据都是唯一的，查询105的记录，过程如下：

1. 将P1页加载到内存
2. 在内存中采用二分法查找，可以确定105位于[100,150)中间，所以我们需要去加载100关联P4页
3. 将P4加载到内存中，采用二分法找到105的记录后退出

#### 查询某个值的所有记录

![image-20201204160648527](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/image-20201204160648527.png)

如上图，查询105的所有记录，过程如下：

1. 将P1页加载到内存
2. 在内存中采用二分法查找，可以确定105位于[100,150)中间，100关联P4页
3. 将P4加载到内存中，采用二分法找到最有一个小于105的记录，即100，然后通过链表从100开始向后访问，找到所有的105记录，直到遇到第一个大于100的值为止

#### 范围查找

![image-20201204160721651](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/image-20201204160721651.png)

数据如上图，查询[55,150]所有记录，由于页和页之间是双向链表升序结构，页内部的数据是单项升序链表结构，所以只用找到范围的起始值所在的位置，然后通过依靠链表访问两个位置之间所有的数据即可，过程如下：

1. 将P1页加载到内存
2. 内存中采用二分法找到55位于50关联的P3页中，150位于P5页中
3. 将P3加载到内存中，采用二分法找到第一个55的记录，然后通过链表结构继续向后访问P3中的60、67，当P3访问完毕之后，通过P3的nextpage指针访问下一页P4中所有记录，继续遍历P4中的所有记录，直到访问到P5中的150为止。

#### 模糊匹配

![image-20201204160825112](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/image-20201204160825112.png)

数据如上图。

**查询以`f`开头的所有记录**

过程如下：

1. 将P1数据加载到内存中
2. 在P1页的记录中采用二分法找到最后一个小于等于f的值，这个值是f，以及第一个大于f的，这个值是z，f指向叶节点P3，z指向叶节点P6，此时可以断定以f开头的记录可能存在于[P3,P6)这个范围的页内，即P3、P4、P5这三个页中
3. 加载P3这个页，在内部以二分法找到第一条f开头的记录，然后以链表方式继续向后访问P4、P5中的记录，即可以找到所有已f开头的数据

**查询包含`f`的记录**

包含的查询在sql中的写法是`%f%`，通过索引我们还可以快速定位所在的页么？

可以看一下上面的数据，f在每个页中都存在，我们通过P1页中的记录是无法判断包含f的记录在那些页的，只能通过io的方式加载所有叶子节点，并且遍历所有记录进行过滤，才可以找到包含f的记录。

**所以如果使用了`%值%`这种方式，索引对查询是无效的。**

#### 最左匹配原则

> 当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+树是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。

来一些示例我们体验一下。

下图中是3个字段(a,b,c)的联合索引，索引中数据的顺序是以`a asc,b asc,c asc`这种排序方式存储在节点中的，索引先以a字段升序，如果a相同的时候，以b字段升序，b相同的时候，以c字段升序，节点中每个数据认真看一下。

![image-20201204160920139](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/image-20201204160920139.png)

**查询a=1的记录**

由于页中的记录是以`a asc,b asc,c asc`这种排序方式存储的，所以a字段是有序的，可以通过二分法快速检索到，过程如下：

1. 将P1加载到内存中
2. 在内存中对P1中的记录采用二分法找，可以确定a=1的记录位于{1,1,1}和{1,5,1}关联的范围内，这两个值子节点分别是P2、P4
3. 加载叶子节点P2，在P2中采用二分法快速找到第一条a=1的记录，然后通过链表向下一条及下一页开始检索，直到在P4中找到第一个不满足a=1的记录为止

**查询a=1 and b=5的记录**

方法和上面的一样，可以确定a=1 and b=5的记录位于{1,1,1}和{1,5,1}关联的范围内，查找过程和a=1查找步骤类似。

**查询b=1的记录**

这种情况通过P1页中的记录，是无法判断b=1的记录在那些页中的，只能加锁索引树所有叶子节点，对所有记录进行遍历，然后进行过滤，**此时索引是无效的**。

**按照c的值查询**

这种情况和查询b=1也一样，也只能扫描所有叶子节点，**此时索引也无效**了。

**按照b和c一起查**

这种也是无法利用索引的，也只能对所有数据进行扫描，一条条判断了，**此时索引无效**。

**按照[a,c]两个字段查询**

这种只能利用到索引中的a字段了，通过a确定索引范围，然后加载a关联的所有记录，再对c的值进行过滤。

**查询a=1 and b>=0 and c=1的记录**

这种情况只能先确定a=1 and b>=0所在页的范围，然后对这个范围的所有页进行遍历，c字段在这个查询的过程中，是无法确定c的数据在哪些页的，此时我们称c是不走索引的，只有a、b能够有效的确定索引页的范围。

**类似这种的还有>、<、between and，多字段索引的情况下，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配。**

上面说的各种情况，大家都多看一下图中数据，认真分析一下查询的过程，基本上都可以理解了。

**上面这种查询叫做最左匹配原则。**

### 索引区分度

我们看2个有序数组

[1,2,3,4,5,6,7,8,8,9,10]

[1,1,1,1,1,8,8,8,8,8]

上面2个数组是有序的，都是10条记录，如果需要检索值为8的所有记录，那个更快一些？

使用二分法查找包含8的所有记录过程如下：先使用二分法找到最后一个小于8的记录，然后沿着这条记录向后获取下一个记录，和8对比，知道遇到第一个大于8的数字结束，或者到达数组末尾结束。

采用上面这种方法找到8的记录，第一个数组中更快的一些。因为第二个数组中含有8的比例更多的，需要访问以及匹配的次数更多一些。

这里就涉及到数据的区分度问题：

**索引区分度 = count(distint 记录) / count(记录)**。

当索引区分度高的时候，检索数据更快一些，索引区分度太低，说明重复的数据比较多，检索的时候需要访问更多的记录才能够找到所有目标数据。

当索引区分度非常小的时候，基本上接近于全索引数据的扫描了，此时查询速度是比较慢的。

第一个数组索引区分度为1，第二个区分度为0.2，所以第一个检索更快的一些。

**所以创建索引的时候，尽量选择区分度高的列作为索引。**

### 正确使用索引

```mysql
# 准备数据
DROP TABLE IF EXISTS test;
CREATE TABLE test
(
    id    INT         NOT NULL COMMENT '编号',
    name  VARCHAR(20) NOT NULL COMMENT '姓名',
    sex   TINYINT     NOT NULL COMMENT '性别,1：男，2：女',
    email VARCHAR(50)
);
DROP PROCEDURE IF EXISTS proc1;
DELIMITER $
CREATE PROCEDURE proc1()
BEGIN
    DECLARE i INT DEFAULT 1;
    START TRANSACTION;
    WHILE i <= 4000000
        DO
            INSERT INTO test (id, name, sex, email)
            VALUES (i, concat('sql', i), if(mod(i, 2), 1, 2), concat('sql', i, '@163.com'));
            SET i = i + 1;
            if i % 10000 = 0 THEN
                COMMIT;
                START TRANSACTION;
            END IF;
        END WHILE;
    COMMIT;
END $

DELIMITER ;
CALL proc1();
```

#### 无索引检索效果

![image-20201204180047586](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/image-20201204180047586.png)

由于id列无索引，只能对400万数据进行全表扫描。

#### 主键检索

![image-20201204180220465](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/image-20201204180220465.png)

id被置为主键之后，会在id上建立聚集索引

#### between and范围检索

![image-20201204180320910](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/image-20201204180320910.png)

id上有主键索引，但是如果范围太大，跨度的page也太多，速度也会比较慢

> 使用between and的时候，区间跨度不要太大

#### in的检索

相当于多个分解为多个**唯一记录检索**，然后将记录合并

#### 多个索引时查询如何走？

> 在name、sex两个字段上分别建个索引

![image-20201204180734243](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/image-20201204180734243.png)

使用explain来看一下

![image-20201204180908753](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/image-20201204180908753.png)

**当多个条件中有索引的时候，并且关系是and的时候，会走索引区分度高的**，显然name字段重复度很低，走name查询会更快一些。

#### 模糊查询

![image-20201204181055655](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/image-20201204181055655.png)

上面第一个查询可以利用到name字段上面的索引，下面的查询是无法确定需要查找的值所在的范围的，只能全表扫描，无法利用索引，所以速度比较慢。

#### 回表

> 当需要查询的数据在索引树中不存在的时候，需要再次到聚集索引中去获取，这个过程叫做回表

![image-20201204181219812](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/image-20201204181219812.png)

上面查询是`*`，由于name列所在的索引中只有`name、id`两个列的值，不包含`sex、email`，所以上面过程如下：

1. 走name索引检索`sql500000`对应的记录，取出id为`3500000`
2. 在主键索引中检索出`id=3500000`的记录，获取所有字段的值

#### 索引覆盖

> 查询中采用的索引树中包含了查询所需要的所有字段的值，不需要再去聚集索引检索数据，这种叫索引覆盖。

```mysql
select id,name from test where name='sql3500000';
```

> name对应idx1索引，id为主键，所以idx1索引树叶子节点中包含了name、id的值，这个查询只用走idx1这一个索引就可以了，如果select后面使用`*`，还需要一次回表获取sex、email的值。

> 所以写sql的时候，尽量避免使用`*`，`*`可能会多一次回表操作，需要看一下是否可以使用索引覆盖来实现，效率更高一些。

#### 索引下推

> 简称ICP，Index Condition Pushdown(ICP)是MySQL 5.6中新特性，是一种在存储引擎层使用索引过滤数据的一种优化方式，ICP可以减少存储引擎访问基表的次数以及MySQL服务器访问存储引擎的次数。

```mysql
select count(id) from test a where name like 'sql35%' and sex = 1;
```

> 1. 走name索引检索出以javacode35的第一条记录，得到记录的id
>
> 2. 利用id去主键索引中查询出这条记录R1
>
> 3. 判断R1中的sex是否为1，然后重复上面的操作，直到找到所有记录为止。
>
>   
>
> 上面的过程中需要走name索引以及需要回表操作。

如果采用ICP的方式，我们可以这么做，创建一个(name,sex)的组合索引，查询过程如下：

> 1. 走(name,sex)索引检索出以javacode35的第一条记录，可以得到(name,sex,id)，记做R1
> 2. 判断R1.sex是否为1，然后重复上面的操作，知道找到所有记录为止
>
> 这个过程中不需要回表操作了，通过索引的数据就可以完成整个条件的过滤，速度比上面的更快一些。

#### 数字使字符串类索引失效

![image-20201204182053029](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/image-20201204182053029.png)

> 上面3条sql，我们插入了一条记录。
>
> 第二条查询很快，第三条用name和1比较，name上有索引，name是字符串类型，字符串和数字比较的时候，会将字符串强制转换为数字，然后进行比较，所以第二个查询变成了全表扫描，只能取出每条数据，将name转换为数字和1进行比较。

数字字段和字符串比较什么效果呢？如下：

![image-20201204182159341](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/image-20201204182159341.png)

> id上面有主键索引，id是int类型的，可以看到，上面两个查询都非常快，都可以正常利用索引快速检索，所以如果字段是数组类型的，查询的值是字符串还是数组都会走索引。

#### 函数使索引无效

![image-20201204182449841](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/image-20201204182449841.png)

> name上有索引，上面查询，第一个走索引，第二个不走索引，第二个使用了函数之后，name所在的索引树是无法快速定位需要查找的数据所在的页的，只能将所有页的记录加载到内存中，然后对每条数据使用函数进行计算之后再进行条件判断，此时索引无效了，变成了全表数据扫描。
>
> **索引字段使用函数查询使索引无效**

#### 运算符使索引无效

![image-20201204182633934](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/image-20201204182633934.png)

> id上有主键索引，上面查询，第一个走索引，第二个不走索引，第二个使用运算符，id所在的索引树是无法快速定位需要查找的数据所在的页的，只能将所有页的记录加载到内存中，然后对每条数据的id进行计算之后再判断是否等于1，此时索引无效了，变成了全表数据扫描。
>
> **索引字段使用了运算符将使索引无效**

#### 使用索引优化排序

我们有个订单表t_order(id,user_id,addtime,price)，经常会查询某个用户的订单，并且按照addtime升序排序，应该怎么创建索引呢？我们来分析一下。

在user_id上创建索引，我们分析一下这种情况，数据检索的过程：

1. 走user_id索引，找到记录的的id
2. 通过id在主键索引中回表检索出整条数据
3. 重复上面的操作，获取所有目标记录
4. 在内存中对目标记录按照addtime进行排序

我们要知道当数据量非常大的时候，排序还是比较慢的，可能会用到磁盘中的文件，有没有一种方式，查询出来的数据刚好是排好序的。

我们再回顾一下mysql中b+树数据的结构，记录是按照索引的值排序组成的链表，如果将user_id和addtime放在一起组成联合索引(user_id,addtime)，这样通过user_id检索出来的数据自然就是按照addtime排好序的，这样直接少了一步排序操作，效率更好，如果需addtime降序，只需要将结果翻转一下就可以了。

### 总结一下使用索引的一些建议

1. 在区分度高的字段上面建立索引可以有效的使用索引，区分度太低，无法有效的利用索引，可能需要扫描所有数据页，此时和不使用索引差不多
2. 联合索引注意最左匹配原则：必须按照从左到右的顺序匹配，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整
3. 查询记录的时候，少使用*，尽量去利用索引覆盖，可以减少回表操作，提升效率
4. 有些查询可以采用联合索引，进而使用到索引下推（IPC），也可以减少回表操作，提升效率
5. 禁止对索引字段使用函数、运算符操作，会使索引失效
6. 字符串字段和数字比较的时候会使索引无效
7. 模糊查询'%值%'会使索引无效，变为全表扫描，但是'值%'这种可以有效利用索引
8. 排序中尽量使用到索引字段，这样可以减少排序，提升查询效率

## 25、sql中的where条件在数据库中提取与应⽤浅析

### 关系型数据库中的数据组织

关系型数据库中，数据组织涉及到两个最基本的结构：表与索引。表中存储的是完整记录，一般有两种组织形式：堆表(所有的记录无序存储)，或者是聚簇索引表(所有的记录，按照记录主键进行排序存储)。索引中存储的是完整记录的一个子集，用于加速记录的查询速度，索引的组织形式，一般均为B+树结构。

有了这些基本知识之后，接下来让我们创建一张测试表，为表新增几个索引，然后插入几条记录，最后看看表的完整数据组织、存储结构式怎么样的。(注意：下面的实例，使用的表的结构为堆表形式，这也是Oracle/DB2/PostgreSQL等数据库采用的表组织形式，而不是InnoDB引擎所采用的聚簇索引表。其实，表结构采用何种形式并不重要，最重要的是理解下面章节的核心，在任何表结构中均适用)

```mysql
create table t1
(
    a int primary key,
    b int,
    c int,
    d int,
    e varchar(20)
);
create index idx_t1_bcd on t1 (b, c, d);

insert into t1 values (4, 3, 1, 1, ’d’);
insert into t1 values (1, 1, 1, 1, ’a’);
insert into t1 values (8, 8, 8, 8, ’h’) :
insert into t1 values (2, 2, 2, 2, ’b’);
insert into t1 values (5, 2, 3, 5, ’e’);
insert into t1 values (3, 3, 2, 2, ’c’);
insert into t1 values (7, 4, 5, 5, ’g’);
insert into t1 values (6, 6, 4, 4, ’f’);
```

t1表的存储结构如下图所示(只画出了idx_t1_bcd索引与t1表结构，没有包括t1表的主键索引)：

![image-20201204183527957](https://zkunm-markdown-images.oss-cn-shanghai.aliyuncs.com/img/image-20201204183527957.png)

简单分析一下上图，idx_t1_bcd索引上有[b,c,d]三个字段(注意：若是InnoDB类的聚簇索引表，idx_t1_bcd上还会包括主键a字段)，不包括[a,e]字段。idx_t1_bcd索引，首先按照b字段排序，b字段相同，则按照c字段排序，以此类推。记录在索引中按照[b,c,d]排序，但是在堆表上是乱序的，不按照任何字段排序。

### SQL的where条件提取

在有了以上的t1表之后，接下来就可以在此表上进行SQL查询了，获取自己想要的数据。例如，考虑以下的一条SQL：

```mysql
select * from t1 where b >= 2 and b < 8 and c > 1 and d != 4 and e != 'a';
```

一条比较简单的SQL，一目了然就可以发现where条件使用到了[b,c,d,e]四个字段，而t1表的idx_t1_bcd索引，恰好使用了[b,c,d]这三个字段，那么走idx_t1_bcd索引进行条件过滤，应该是一个不错的选择。接下来，让我们抛弃数据库的思想，直接思考这条SQL的几个关键性问题：

**此SQL，覆盖索引idx_t1_bcd上的哪个范围？**

起始范围：记录[2,2,2]是第一个需要检查的索引项。索引起始查找范围由b >= 2，c > 1决定。

终止范围：记录[8,8,8]是第一个不需要检查的记录，而之前的记录均需要判断。索引的终止查找范围由b < 8决定；

**在确定了查询的起始、终止范围之后，SQL中还有哪些条件可以使用索引idx_t1_bcd过滤？**

根据SQL，固定了索引的查询范围[(2,2,2),(8,8,8))之后，此索引范围中并不是每条记录都是满足where查询条件的。例如：(3,1,1)不满足c > 1的约束；(6,4,4)不满足d != 4的约束。而c，d列，均可在索引idx_t1_bcd中过滤掉不满足条件的索引记录的。

因此，SQL中还可以使用c > 1 and d != 4条件进行索引记录的过滤。

**在确定了索引中最终能够过滤掉的条件之后，还有哪些条件是索引无法过滤的？**

此问题的答案显而易见，e != ‘a’这个查询条件，无法在索引idx_t1_bcd上进行过滤，因为索引并未包含e列。e列只在堆表上存在，为了过滤此查询条件，必须将已经满足索引查询条件的记录回表，取出表中的e列，然后使用e列的查询条件e != ‘a’进行最终的过滤。

在理解以上的问题解答的基础上，做一个抽象，可总结出一套放置于所有SQL语句而皆准的where查询条件的提取规则：

### 所有SQL的where条件，均可归纳为3大类

- Index Key (First Key & Last Key)
- Index Filter
- Table Filter

接下来，让我们来详细分析这3大类分别是如何定义，以及如何提取的。

#### 1.Index Key

用于确定SQL查询在索引中的连续范围(起始范围+结束范围)的查询条件，被称之为Index Key。由于一个范围，至少包含一个起始与一个终止，因此Index Key也被拆分为Index First Key和Index Last Key，分别用于定位索引查找的起始，以及索引查询的终止条件。

##### Index First Key

用于确定索引查询的起始范围。提取规则：从索引的第一个键值开始，检查其在where条件中是否存在，若存在并且条件是=、>=，则将对应的条件加入Index First Key之中，继续读取索引的下一个键值，使用同样的提取规则；若存在并且条件是>，则将对应的条件加入Index First Key中，同时终止Index First Key的提取；若不存在，同样终止Index First Key的提取。

针对上面的SQL，应用这个提取规则，提取出来的Index First Key为(b >= 2, c > 1)。由于c的条件为 >，提取结束，不包括d。

##### Index Last Key

Index Last Key的功能与Index First Key正好相反，用于确定索引查询的终止范围。提取规则：从索引的第一个键值开始，检查其在where条件中是否存在，若存在并且条件是=、<=，则将对应条件加入到Index Last Key中，继续提取索引的下一个键值，使用同样的提取规则；若存在并且条件是 < ，则将条件加入到Index Last Key中，同时终止提取；若不存在，同样终止Index Last Key的提取。

针对上面的SQL，应用这个提取规则，提取出来的Index Last Key为(b < 8)，由于是 < 符号，因此提取b之后结束。

#### 2.Index Filter

在完成Index Key的提取之后，我们根据where条件固定了索引的查询范围，但是此范围中的项，并不都是满足查询条件的项。在上面的SQL用例中，(3,1,1)，(6,4,4)均属于范围中，但是又均不满足SQL的查询条件。

Index Filter的提取规则：同样从索引列的第一列开始，检查其在where条件中是否存在：若存在并且where条件仅为 =，则跳过第一列继续检查索引下一列，下一索引列采取与索引第一列同样的提取规则；若where条件为 >=、>、<、<= 其中的几种，则跳过索引第一列，将其余where条件中索引相关列全部加入到Index Filter之中；若索引第一列的where条件包含 =、>=、>、<、<= 之外的条件，则将此条件以及其余where条件中索引相关列全部加入到Index Filter之中；若第一列不包含查询条件，则将所有索引相关条件均加入到Index Filter之中。

针对上面的用例SQL，索引第一列只包含 >=、< 两个条件，因此第一列可跳过，将余下的c、d两列加入到Index Filter中。因此获得的Index Filter为 c > 1 and d != 4 。

#### 3.Table Filter

Table Filter是最简单，最易懂，也是提取最为方便的。提取规则：所有不属于索引列的查询条件，均归为Table Filter之中。

同样，针对上面的用例SQL，Table Filter就为 e != ‘a’。

#### Index Key/Index Filter/Table Filter小结

SQL语句中的where条件，使用以上的提取规则，最终都会被提取到Index Key (First Key & Last Key)，Index Filter与Table Filter之中。

Index First Key，只是用来定位索引的起始范围，因此只在索引第一次Search Path(沿着索引B+树的根节点一直遍历，到索引正确的叶节点位置)时使用，一次判断即可；

Index Last Key，用来定位索引的终止范围，因此对于起始范围之后读到的每一条索引记录，均需要判断是否已经超过了Index Last Key的范围，若超过，则当前查询结束；

Index Filter，用于过滤索引查询范围中不满足查询条件的记录，因此对于索引范围中的每一条记录，均需要与Index Filter进行对比，若不满足Index Filter则直接丢弃，继续读取索引下一条记录；

Table Filter，则是最后一道where条件的防线，用于过滤通过前面索引的层层考验的记录，此时的记录已经满足了Index First Key与Index Last Key构成的范围，并且满足Index Filter的条件，回表读取了完整的记录，判断完整记录是否满足Table Filter中的查询条件，同样的，若不满足，跳过当前记录，继续读取索引的下一条记录，若满足，则返回记录，此记录满足了where的所有条件，可以返回给前端用户。

## 26、如何使⽤MySQL实现分布式锁

### 分布式锁的功能

1. 分布式锁使用者位于不同的机器中，锁获取成功之后，才可以对共享资源进行操作
2. 锁具有重入的功能：即一个使用者可以多次获取某个锁
3. 获取锁有超时的功能：即在指定的时间内去尝试获取锁，超过了超时时间，如果还未获取成功，则返回获取失败
4. 能够自动容错，比如：A机器获取锁lock1之后，在释放锁lock1之前，A机器挂了，导致锁lock1未释放，结果会lock1一直被A机器占有着，遇到这种情况时，分布式锁要能够自动解决，可以这么做：持有锁的时候可以加个持有超时时间，超过了这个时间还未释放的，其他机器将有机会获取锁

### 预备技能：乐观锁

通常我们修改表中一条数据过程如下：

```java
t1：select获取记录R1
t2：对R1进行编辑
t3：update R1
```

我们来看一下上面的过程存在的问题：

如果A、B两个线程同时执行到t1，他们俩看到的R1的数据一样，然后都对R1进行编辑，然后去执行t3，最终2个线程都会更新成功，后面一个线程会把前面一个线程update的结果给覆盖掉，这就是并发修改数据存在的问题。

我们可以在表中新增一个版本号，每次更新数据时候将版本号作为条件，并且每次更新时候版本号+1，过程优化一下，如下：

```java
t1：打开事务start transaction
t2：select获取记录R1,声明变量v=R1.version
t3：对R1进行编辑
t4：执行更新操作
    update R1 set version = version + 1 where user_id=#user_id# and version = #v#;
t5：t4中的update会返回影响的行数，我们将其记录在count中，然后根据count来判断提交还是回滚
    if(count==1){
        //提交事务
        commit;
    }else{
        //回滚事务
        rollback;
    }
```

上面重点在于步骤t4，当多个线程同时执行到t1，他们看到的R1是一样的，但是当他们执行到t4的时候，数据库会对update的这行记录加锁，确保并发情况下排队执行，所以只有第一个的update会返回1，其他的update结果会返回0，然后后面会判断count是否为1，进而对事务进行提交或者回滚。可以通过count的值知道修改数据是否成功了。

上面这种方式就乐观锁。**我们可以通过乐观锁的方式确保数据并发修改过程中的正确性。**

### 锁工具

```java
package com.util;

import lombok.Builder;
import lombok.Getter;
import lombok.Setter;

import java.sql.*;
import java.util.Objects;
import java.util.UUID;
import java.util.concurrent.TimeUnit;

/**
 * @Description
 * @author: zkunm
 * @create: 2020-12-04 18:42
 */
public class LockUtils {

    //将request-id保存在该变量中
    static ThreadLocal<String> requestIdTL = new ThreadLocal<>();

    /**
     * 获取当前线程requestid
     *
     * @return
     */
    public static String getRequestId() {
        String requestId = requestIdTL.get();
        if (requestId == null || "".equals(requestId)) {
            requestId = UUID.randomUUID().toString();
            requestIdTL.set(requestId);
        }
        return requestId;
    }

    /**
     * 获取锁
     *
     * @param lock_key        锁key
     * @param locktimeout(毫秒) 持有锁的有效时间，防止死锁
     * @param gettimeout(毫秒)  获取锁的超时时间，这个时间内获取不到将重试
     * @return
     */
    public static boolean lock(String lock_key, long locktimeout, int gettimeout) throws Exception {
        boolean lockResult = false;
        String request_id = getRequestId();
        long starttime = System.currentTimeMillis();
        while (true) {
            LockModel lockModel = LockUtils.get(lock_key);
            if (Objects.isNull(lockModel)) {
                //插入一条记录,重新尝试获取锁
                LockUtils.insert(LockModel.builder().lock_key(lock_key).request_id("").lock_count(0).timeout(0L).version(0).build());
            } else {
                String reqid = lockModel.getRequest_id();
                //如果reqid为空字符，表示锁未被占用
                if ("".equals(reqid)) {
                    lockModel.setRequest_id(request_id);
                    lockModel.setLock_count(1);
                    lockModel.setTimeout(System.currentTimeMillis() + locktimeout);
                    if (LockUtils.update(lockModel) == 1) {
                        lockResult = true;
                        break;
                    }
                } else if (request_id.equals(reqid)) {
                    //如果request_id和表中request_id一样表示锁被当前线程持有者，此时需要加重入锁
                    lockModel.setTimeout(System.currentTimeMillis() + locktimeout);
                    lockModel.setLock_count(lockModel.getLock_count() + 1);
                    if (LockUtils.update(lockModel) == 1) {
                        lockResult = true;
                        break;
                    }
                } else {
                    //锁不是自己的，并且已经超时了，则重置锁，继续重试
                    if (lockModel.getTimeout() < System.currentTimeMillis()) {
                        LockUtils.resetLock(lockModel);
                    } else {
                        //如果未超时，休眠100毫秒，继续重试
                        if (starttime + gettimeout > System.currentTimeMillis()) {
                            TimeUnit.MILLISECONDS.sleep(100);
                        } else {
                            break;
                        }
                    }
                }
            }
        }
        return lockResult;
    }

    /**
     * 释放锁
     *
     * @param lock_key
     * @throws Exception
     */
    public static void unlock(String lock_key) throws Exception {
        //获取当前线程requestId
        String requestId = getRequestId();
        LockModel lockModel = LockUtils.get(lock_key);
        //当前线程requestId和库中request_id一致 && lock_count>0，表示可以释放锁
        if (Objects.nonNull(lockModel) && requestId.equals(lockModel.getRequest_id()) && lockModel.getLock_count() > 0) {
            if (lockModel.getLock_count() == 1) {
                //重置锁
                resetLock(lockModel);
            } else {
                lockModel.setLock_count(lockModel.getLock_count() - 1);
                LockUtils.update(lockModel);
            }
        }
    }

    /**
     * 重置锁
     *
     * @param lockModel
     * @return
     * @throws Exception
     */
    public static int resetLock(LockModel lockModel) throws Exception {
        lockModel.setRequest_id("");
        lockModel.setLock_count(0);
        lockModel.setTimeout(0L);
        return LockUtils.update(lockModel);
    }

    /**
     * 更新lockModel信息，内部采用乐观锁来更新
     *
     * @param lockModel
     * @return
     * @throws Exception
     */
    public static int update(LockModel lockModel) throws Exception {
        return exec(conn -> {
            String sql = "UPDATE t_lock SET request_id = ?,lock_count = ?,timeout = ?,version = version + 1 WHERE lock_key = ? AND  version = ?";
            PreparedStatement ps = conn.prepareStatement(sql);
            int colIndex = 1;
            ps.setString(colIndex++, lockModel.getRequest_id());
            ps.setInt(colIndex++, lockModel.getLock_count());
            ps.setLong(colIndex++, lockModel.getTimeout());
            ps.setString(colIndex++, lockModel.getLock_key());
            ps.setInt(colIndex++, lockModel.getVersion());
            return ps.executeUpdate();
        });
    }

    public static LockModel get(String lock_key) throws Exception {
        return exec(conn -> {
            String sql = "select * from t_lock t WHERE t.lock_key=?";
            PreparedStatement ps = conn.prepareStatement(sql);
            int colIndex = 1;
            ps.setString(colIndex++, lock_key);
            ResultSet rs = ps.executeQuery();
            if (rs.next()) {
                return LockModel.builder().
                        lock_key(lock_key).
                        request_id(rs.getString("request_id")).
                        lock_count(rs.getInt("lock_count")).
                        timeout(rs.getLong("timeout")).
                        version(rs.getInt("version")).build();
            }
            return null;
        });
    }

    public static int insert(LockModel lockModel) throws Exception {
        return exec(conn -> {
            String sql = "insert into t_lock (lock_key, request_id, lock_count, timeout, version) VALUES (?,?,?,?,?)";
            PreparedStatement ps = conn.prepareStatement(sql);
            int colIndex = 1;
            ps.setString(colIndex++, lockModel.getLock_key());
            ps.setString(colIndex++, lockModel.getRequest_id());
            ps.setInt(colIndex++, lockModel.getLock_count());
            ps.setLong(colIndex++, lockModel.getTimeout());
            ps.setInt(colIndex++, lockModel.getVersion());
            return ps.executeUpdate();
        });
    }

    public static <T> T exec(SqlExec<T> sqlExec) throws Exception {
        Connection conn = getConn();
        try {
            return sqlExec.exec(conn);
        } finally {
            closeConn(conn);
        }
    }

    @FunctionalInterface
    public interface SqlExec<T> {
        T exec(Connection conn) throws Exception;
    }

    @Getter
    @Setter
    @Builder
    public static class LockModel {
        private String lock_key;
        private String request_id;
        private Integer lock_count;
        private Long timeout;
        private Integer version;
    }

    private static final String url = "jdbc:mysql://devos:3306/test?useSSL=false";        //数据库地址
    private static final String username = "root";        //数据库用户名
    private static final String password = "123456";        //数据库密码
    private static final String driver = "com.mysql.jdbc.Driver";        //mysql驱动

    /**
     * 连接数据库
     *
     * @return
     */
    public static Connection getConn() {
        Connection conn = null;
        try {
            Class.forName(driver);  //加载数据库驱动
            try {
                conn = DriverManager.getConnection(url, username, password);  //连接数据库
            } catch (SQLException e) {
                e.printStackTrace();
            }
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
        return conn;
    }

    /**
     * 关闭数据库链接
     *
     * @return
     */
    public static void closeConn(Connection conn) {
        if (conn != null) {
            try {
                conn.close();  //关闭数据库链接
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }
}
```

